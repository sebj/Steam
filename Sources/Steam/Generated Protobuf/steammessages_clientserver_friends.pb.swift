// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: steammessages_clientserver_friends.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct CMsgClientFriendMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var steamid: UInt64 {
    get {return _steamid ?? 0}
    set {_steamid = newValue}
  }
  /// Returns true if `steamid` has been explicitly set.
  var hasSteamid: Bool {return self._steamid != nil}
  /// Clears the value of `steamid`. Subsequent reads from it will return its default value.
  mutating func clearSteamid() {self._steamid = nil}

  var chatEntryType: Int32 {
    get {return _chatEntryType ?? 0}
    set {_chatEntryType = newValue}
  }
  /// Returns true if `chatEntryType` has been explicitly set.
  var hasChatEntryType: Bool {return self._chatEntryType != nil}
  /// Clears the value of `chatEntryType`. Subsequent reads from it will return its default value.
  mutating func clearChatEntryType() {self._chatEntryType = nil}

  var message: Data {
    get {return _message ?? Data()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  var rtime32ServerTimestamp: UInt32 {
    get {return _rtime32ServerTimestamp ?? 0}
    set {_rtime32ServerTimestamp = newValue}
  }
  /// Returns true if `rtime32ServerTimestamp` has been explicitly set.
  var hasRtime32ServerTimestamp: Bool {return self._rtime32ServerTimestamp != nil}
  /// Clears the value of `rtime32ServerTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearRtime32ServerTimestamp() {self._rtime32ServerTimestamp = nil}

  var echoToSender: Bool {
    get {return _echoToSender ?? false}
    set {_echoToSender = newValue}
  }
  /// Returns true if `echoToSender` has been explicitly set.
  var hasEchoToSender: Bool {return self._echoToSender != nil}
  /// Clears the value of `echoToSender`. Subsequent reads from it will return its default value.
  mutating func clearEchoToSender() {self._echoToSender = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _steamid: UInt64? = nil
  fileprivate var _chatEntryType: Int32? = nil
  fileprivate var _message: Data? = nil
  fileprivate var _rtime32ServerTimestamp: UInt32? = nil
  fileprivate var _echoToSender: Bool? = nil
}

struct CMsgClientFriendMsgIncoming {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var steamidFrom: UInt64 {
    get {return _steamidFrom ?? 0}
    set {_steamidFrom = newValue}
  }
  /// Returns true if `steamidFrom` has been explicitly set.
  var hasSteamidFrom: Bool {return self._steamidFrom != nil}
  /// Clears the value of `steamidFrom`. Subsequent reads from it will return its default value.
  mutating func clearSteamidFrom() {self._steamidFrom = nil}

  var chatEntryType: Int32 {
    get {return _chatEntryType ?? 0}
    set {_chatEntryType = newValue}
  }
  /// Returns true if `chatEntryType` has been explicitly set.
  var hasChatEntryType: Bool {return self._chatEntryType != nil}
  /// Clears the value of `chatEntryType`. Subsequent reads from it will return its default value.
  mutating func clearChatEntryType() {self._chatEntryType = nil}

  var fromLimitedAccount: Bool {
    get {return _fromLimitedAccount ?? false}
    set {_fromLimitedAccount = newValue}
  }
  /// Returns true if `fromLimitedAccount` has been explicitly set.
  var hasFromLimitedAccount: Bool {return self._fromLimitedAccount != nil}
  /// Clears the value of `fromLimitedAccount`. Subsequent reads from it will return its default value.
  mutating func clearFromLimitedAccount() {self._fromLimitedAccount = nil}

  var message: Data {
    get {return _message ?? Data()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  var rtime32ServerTimestamp: UInt32 {
    get {return _rtime32ServerTimestamp ?? 0}
    set {_rtime32ServerTimestamp = newValue}
  }
  /// Returns true if `rtime32ServerTimestamp` has been explicitly set.
  var hasRtime32ServerTimestamp: Bool {return self._rtime32ServerTimestamp != nil}
  /// Clears the value of `rtime32ServerTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearRtime32ServerTimestamp() {self._rtime32ServerTimestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _steamidFrom: UInt64? = nil
  fileprivate var _chatEntryType: Int32? = nil
  fileprivate var _fromLimitedAccount: Bool? = nil
  fileprivate var _message: Data? = nil
  fileprivate var _rtime32ServerTimestamp: UInt32? = nil
}

struct CMsgClientAddFriend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var steamidToAdd: UInt64 {
    get {return _steamidToAdd ?? 0}
    set {_steamidToAdd = newValue}
  }
  /// Returns true if `steamidToAdd` has been explicitly set.
  var hasSteamidToAdd: Bool {return self._steamidToAdd != nil}
  /// Clears the value of `steamidToAdd`. Subsequent reads from it will return its default value.
  mutating func clearSteamidToAdd() {self._steamidToAdd = nil}

  var accountnameOrEmailToAdd: String {
    get {return _accountnameOrEmailToAdd ?? String()}
    set {_accountnameOrEmailToAdd = newValue}
  }
  /// Returns true if `accountnameOrEmailToAdd` has been explicitly set.
  var hasAccountnameOrEmailToAdd: Bool {return self._accountnameOrEmailToAdd != nil}
  /// Clears the value of `accountnameOrEmailToAdd`. Subsequent reads from it will return its default value.
  mutating func clearAccountnameOrEmailToAdd() {self._accountnameOrEmailToAdd = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _steamidToAdd: UInt64? = nil
  fileprivate var _accountnameOrEmailToAdd: String? = nil
}

struct CMsgClientAddFriendResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var steamIDAdded: UInt64 {
    get {return _steamIDAdded ?? 0}
    set {_steamIDAdded = newValue}
  }
  /// Returns true if `steamIDAdded` has been explicitly set.
  var hasSteamIDAdded: Bool {return self._steamIDAdded != nil}
  /// Clears the value of `steamIDAdded`. Subsequent reads from it will return its default value.
  mutating func clearSteamIDAdded() {self._steamIDAdded = nil}

  var personaNameAdded: String {
    get {return _personaNameAdded ?? String()}
    set {_personaNameAdded = newValue}
  }
  /// Returns true if `personaNameAdded` has been explicitly set.
  var hasPersonaNameAdded: Bool {return self._personaNameAdded != nil}
  /// Clears the value of `personaNameAdded`. Subsequent reads from it will return its default value.
  mutating func clearPersonaNameAdded() {self._personaNameAdded = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: Int32? = nil
  fileprivate var _steamIDAdded: UInt64? = nil
  fileprivate var _personaNameAdded: String? = nil
}

struct CMsgClientRemoveFriend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var friendid: UInt64 {
    get {return _friendid ?? 0}
    set {_friendid = newValue}
  }
  /// Returns true if `friendid` has been explicitly set.
  var hasFriendid: Bool {return self._friendid != nil}
  /// Clears the value of `friendid`. Subsequent reads from it will return its default value.
  mutating func clearFriendid() {self._friendid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _friendid: UInt64? = nil
}

struct CMsgClientHideFriend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var friendid: UInt64 {
    get {return _friendid ?? 0}
    set {_friendid = newValue}
  }
  /// Returns true if `friendid` has been explicitly set.
  var hasFriendid: Bool {return self._friendid != nil}
  /// Clears the value of `friendid`. Subsequent reads from it will return its default value.
  mutating func clearFriendid() {self._friendid = nil}

  var hide: Bool {
    get {return _hide ?? false}
    set {_hide = newValue}
  }
  /// Returns true if `hide` has been explicitly set.
  var hasHide: Bool {return self._hide != nil}
  /// Clears the value of `hide`. Subsequent reads from it will return its default value.
  mutating func clearHide() {self._hide = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _friendid: UInt64? = nil
  fileprivate var _hide: Bool? = nil
}

struct CMsgClientFriendsList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bincremental: Bool {
    get {return _bincremental ?? false}
    set {_bincremental = newValue}
  }
  /// Returns true if `bincremental` has been explicitly set.
  var hasBincremental: Bool {return self._bincremental != nil}
  /// Clears the value of `bincremental`. Subsequent reads from it will return its default value.
  mutating func clearBincremental() {self._bincremental = nil}

  var friends: [CMsgClientFriendsList.Friend] = []

  var maxFriendCount: UInt32 {
    get {return _maxFriendCount ?? 0}
    set {_maxFriendCount = newValue}
  }
  /// Returns true if `maxFriendCount` has been explicitly set.
  var hasMaxFriendCount: Bool {return self._maxFriendCount != nil}
  /// Clears the value of `maxFriendCount`. Subsequent reads from it will return its default value.
  mutating func clearMaxFriendCount() {self._maxFriendCount = nil}

  var activeFriendCount: UInt32 {
    get {return _activeFriendCount ?? 0}
    set {_activeFriendCount = newValue}
  }
  /// Returns true if `activeFriendCount` has been explicitly set.
  var hasActiveFriendCount: Bool {return self._activeFriendCount != nil}
  /// Clears the value of `activeFriendCount`. Subsequent reads from it will return its default value.
  mutating func clearActiveFriendCount() {self._activeFriendCount = nil}

  var friendsLimitHit: Bool {
    get {return _friendsLimitHit ?? false}
    set {_friendsLimitHit = newValue}
  }
  /// Returns true if `friendsLimitHit` has been explicitly set.
  var hasFriendsLimitHit: Bool {return self._friendsLimitHit != nil}
  /// Clears the value of `friendsLimitHit`. Subsequent reads from it will return its default value.
  mutating func clearFriendsLimitHit() {self._friendsLimitHit = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Friend {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ulfriendid: UInt64 {
      get {return _ulfriendid ?? 0}
      set {_ulfriendid = newValue}
    }
    /// Returns true if `ulfriendid` has been explicitly set.
    var hasUlfriendid: Bool {return self._ulfriendid != nil}
    /// Clears the value of `ulfriendid`. Subsequent reads from it will return its default value.
    mutating func clearUlfriendid() {self._ulfriendid = nil}

    var efriendrelationship: UInt32 {
      get {return _efriendrelationship ?? 0}
      set {_efriendrelationship = newValue}
    }
    /// Returns true if `efriendrelationship` has been explicitly set.
    var hasEfriendrelationship: Bool {return self._efriendrelationship != nil}
    /// Clears the value of `efriendrelationship`. Subsequent reads from it will return its default value.
    mutating func clearEfriendrelationship() {self._efriendrelationship = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _ulfriendid: UInt64? = nil
    fileprivate var _efriendrelationship: UInt32? = nil
  }

  init() {}

  fileprivate var _bincremental: Bool? = nil
  fileprivate var _maxFriendCount: UInt32? = nil
  fileprivate var _activeFriendCount: UInt32? = nil
  fileprivate var _friendsLimitHit: Bool? = nil
}

struct CMsgClientFriendsGroupsList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bremoval: Bool {
    get {return _bremoval ?? false}
    set {_bremoval = newValue}
  }
  /// Returns true if `bremoval` has been explicitly set.
  var hasBremoval: Bool {return self._bremoval != nil}
  /// Clears the value of `bremoval`. Subsequent reads from it will return its default value.
  mutating func clearBremoval() {self._bremoval = nil}

  var bincremental: Bool {
    get {return _bincremental ?? false}
    set {_bincremental = newValue}
  }
  /// Returns true if `bincremental` has been explicitly set.
  var hasBincremental: Bool {return self._bincremental != nil}
  /// Clears the value of `bincremental`. Subsequent reads from it will return its default value.
  mutating func clearBincremental() {self._bincremental = nil}

  var friendGroups: [CMsgClientFriendsGroupsList.FriendGroup] = []

  var memberships: [CMsgClientFriendsGroupsList.FriendGroupsMembership] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct FriendGroup {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nGroupID: Int32 {
      get {return _nGroupID ?? 0}
      set {_nGroupID = newValue}
    }
    /// Returns true if `nGroupID` has been explicitly set.
    var hasNGroupID: Bool {return self._nGroupID != nil}
    /// Clears the value of `nGroupID`. Subsequent reads from it will return its default value.
    mutating func clearNGroupID() {self._nGroupID = nil}

    var strGroupName: String {
      get {return _strGroupName ?? String()}
      set {_strGroupName = newValue}
    }
    /// Returns true if `strGroupName` has been explicitly set.
    var hasStrGroupName: Bool {return self._strGroupName != nil}
    /// Clears the value of `strGroupName`. Subsequent reads from it will return its default value.
    mutating func clearStrGroupName() {self._strGroupName = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _nGroupID: Int32? = nil
    fileprivate var _strGroupName: String? = nil
  }

  struct FriendGroupsMembership {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ulSteamID: UInt64 {
      get {return _ulSteamID ?? 0}
      set {_ulSteamID = newValue}
    }
    /// Returns true if `ulSteamID` has been explicitly set.
    var hasUlSteamID: Bool {return self._ulSteamID != nil}
    /// Clears the value of `ulSteamID`. Subsequent reads from it will return its default value.
    mutating func clearUlSteamID() {self._ulSteamID = nil}

    var nGroupID: Int32 {
      get {return _nGroupID ?? 0}
      set {_nGroupID = newValue}
    }
    /// Returns true if `nGroupID` has been explicitly set.
    var hasNGroupID: Bool {return self._nGroupID != nil}
    /// Clears the value of `nGroupID`. Subsequent reads from it will return its default value.
    mutating func clearNGroupID() {self._nGroupID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _ulSteamID: UInt64? = nil
    fileprivate var _nGroupID: Int32? = nil
  }

  init() {}

  fileprivate var _bremoval: Bool? = nil
  fileprivate var _bincremental: Bool? = nil
}

struct CMsgClientPlayerNicknameList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var removal: Bool {
    get {return _removal ?? false}
    set {_removal = newValue}
  }
  /// Returns true if `removal` has been explicitly set.
  var hasRemoval: Bool {return self._removal != nil}
  /// Clears the value of `removal`. Subsequent reads from it will return its default value.
  mutating func clearRemoval() {self._removal = nil}

  var incremental: Bool {
    get {return _incremental ?? false}
    set {_incremental = newValue}
  }
  /// Returns true if `incremental` has been explicitly set.
  var hasIncremental: Bool {return self._incremental != nil}
  /// Clears the value of `incremental`. Subsequent reads from it will return its default value.
  mutating func clearIncremental() {self._incremental = nil}

  var nicknames: [CMsgClientPlayerNicknameList.PlayerNickname] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PlayerNickname {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var steamid: UInt64 {
      get {return _steamid ?? 0}
      set {_steamid = newValue}
    }
    /// Returns true if `steamid` has been explicitly set.
    var hasSteamid: Bool {return self._steamid != nil}
    /// Clears the value of `steamid`. Subsequent reads from it will return its default value.
    mutating func clearSteamid() {self._steamid = nil}

    var nickname: String {
      get {return _nickname ?? String()}
      set {_nickname = newValue}
    }
    /// Returns true if `nickname` has been explicitly set.
    var hasNickname: Bool {return self._nickname != nil}
    /// Clears the value of `nickname`. Subsequent reads from it will return its default value.
    mutating func clearNickname() {self._nickname = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _steamid: UInt64? = nil
    fileprivate var _nickname: String? = nil
  }

  init() {}

  fileprivate var _removal: Bool? = nil
  fileprivate var _incremental: Bool? = nil
}

struct CMsgClientSetPlayerNickname {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var steamid: UInt64 {
    get {return _steamid ?? 0}
    set {_steamid = newValue}
  }
  /// Returns true if `steamid` has been explicitly set.
  var hasSteamid: Bool {return self._steamid != nil}
  /// Clears the value of `steamid`. Subsequent reads from it will return its default value.
  mutating func clearSteamid() {self._steamid = nil}

  var nickname: String {
    get {return _nickname ?? String()}
    set {_nickname = newValue}
  }
  /// Returns true if `nickname` has been explicitly set.
  var hasNickname: Bool {return self._nickname != nil}
  /// Clears the value of `nickname`. Subsequent reads from it will return its default value.
  mutating func clearNickname() {self._nickname = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _steamid: UInt64? = nil
  fileprivate var _nickname: String? = nil
}

struct CMsgClientSetPlayerNicknameResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: UInt32 {
    get {return _eresult ?? 0}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: UInt32? = nil
}

struct CMsgClientRequestFriendData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var personaStateRequested: UInt32 {
    get {return _personaStateRequested ?? 0}
    set {_personaStateRequested = newValue}
  }
  /// Returns true if `personaStateRequested` has been explicitly set.
  var hasPersonaStateRequested: Bool {return self._personaStateRequested != nil}
  /// Clears the value of `personaStateRequested`. Subsequent reads from it will return its default value.
  mutating func clearPersonaStateRequested() {self._personaStateRequested = nil}

  var friends: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _personaStateRequested: UInt32? = nil
}

struct CMsgClientChangeStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var personaState: UInt32 {
    get {return _personaState ?? 0}
    set {_personaState = newValue}
  }
  /// Returns true if `personaState` has been explicitly set.
  var hasPersonaState: Bool {return self._personaState != nil}
  /// Clears the value of `personaState`. Subsequent reads from it will return its default value.
  mutating func clearPersonaState() {self._personaState = nil}

  var playerName: String {
    get {return _playerName ?? String()}
    set {_playerName = newValue}
  }
  /// Returns true if `playerName` has been explicitly set.
  var hasPlayerName: Bool {return self._playerName != nil}
  /// Clears the value of `playerName`. Subsequent reads from it will return its default value.
  mutating func clearPlayerName() {self._playerName = nil}

  var isAutoGeneratedName: Bool {
    get {return _isAutoGeneratedName ?? false}
    set {_isAutoGeneratedName = newValue}
  }
  /// Returns true if `isAutoGeneratedName` has been explicitly set.
  var hasIsAutoGeneratedName: Bool {return self._isAutoGeneratedName != nil}
  /// Clears the value of `isAutoGeneratedName`. Subsequent reads from it will return its default value.
  mutating func clearIsAutoGeneratedName() {self._isAutoGeneratedName = nil}

  var highPriority: Bool {
    get {return _highPriority ?? false}
    set {_highPriority = newValue}
  }
  /// Returns true if `highPriority` has been explicitly set.
  var hasHighPriority: Bool {return self._highPriority != nil}
  /// Clears the value of `highPriority`. Subsequent reads from it will return its default value.
  mutating func clearHighPriority() {self._highPriority = nil}

  var personaSetByUser: Bool {
    get {return _personaSetByUser ?? false}
    set {_personaSetByUser = newValue}
  }
  /// Returns true if `personaSetByUser` has been explicitly set.
  var hasPersonaSetByUser: Bool {return self._personaSetByUser != nil}
  /// Clears the value of `personaSetByUser`. Subsequent reads from it will return its default value.
  mutating func clearPersonaSetByUser() {self._personaSetByUser = nil}

  var personaStateFlags: UInt32 {
    get {return _personaStateFlags ?? 0}
    set {_personaStateFlags = newValue}
  }
  /// Returns true if `personaStateFlags` has been explicitly set.
  var hasPersonaStateFlags: Bool {return self._personaStateFlags != nil}
  /// Clears the value of `personaStateFlags`. Subsequent reads from it will return its default value.
  mutating func clearPersonaStateFlags() {self._personaStateFlags = nil}

  var needPersonaResponse: Bool {
    get {return _needPersonaResponse ?? false}
    set {_needPersonaResponse = newValue}
  }
  /// Returns true if `needPersonaResponse` has been explicitly set.
  var hasNeedPersonaResponse: Bool {return self._needPersonaResponse != nil}
  /// Clears the value of `needPersonaResponse`. Subsequent reads from it will return its default value.
  mutating func clearNeedPersonaResponse() {self._needPersonaResponse = nil}

  var isClientIdle: Bool {
    get {return _isClientIdle ?? false}
    set {_isClientIdle = newValue}
  }
  /// Returns true if `isClientIdle` has been explicitly set.
  var hasIsClientIdle: Bool {return self._isClientIdle != nil}
  /// Clears the value of `isClientIdle`. Subsequent reads from it will return its default value.
  mutating func clearIsClientIdle() {self._isClientIdle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _personaState: UInt32? = nil
  fileprivate var _playerName: String? = nil
  fileprivate var _isAutoGeneratedName: Bool? = nil
  fileprivate var _highPriority: Bool? = nil
  fileprivate var _personaSetByUser: Bool? = nil
  fileprivate var _personaStateFlags: UInt32? = nil
  fileprivate var _needPersonaResponse: Bool? = nil
  fileprivate var _isClientIdle: Bool? = nil
}

struct CMsgPersonaChangeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: UInt32 {
    get {return _result ?? 0}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var playerName: String {
    get {return _playerName ?? String()}
    set {_playerName = newValue}
  }
  /// Returns true if `playerName` has been explicitly set.
  var hasPlayerName: Bool {return self._playerName != nil}
  /// Clears the value of `playerName`. Subsequent reads from it will return its default value.
  mutating func clearPlayerName() {self._playerName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _result: UInt32? = nil
  fileprivate var _playerName: String? = nil
}

struct CMsgClientPersonaState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var statusFlags: UInt32 {
    get {return _statusFlags ?? 0}
    set {_statusFlags = newValue}
  }
  /// Returns true if `statusFlags` has been explicitly set.
  var hasStatusFlags: Bool {return self._statusFlags != nil}
  /// Clears the value of `statusFlags`. Subsequent reads from it will return its default value.
  mutating func clearStatusFlags() {self._statusFlags = nil}

  var friends: [CMsgClientPersonaState.Friend] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Friend {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var friendid: UInt64 {
      get {return _storage._friendid ?? 0}
      set {_uniqueStorage()._friendid = newValue}
    }
    /// Returns true if `friendid` has been explicitly set.
    var hasFriendid: Bool {return _storage._friendid != nil}
    /// Clears the value of `friendid`. Subsequent reads from it will return its default value.
    mutating func clearFriendid() {_uniqueStorage()._friendid = nil}

    var personaState: UInt32 {
      get {return _storage._personaState ?? 0}
      set {_uniqueStorage()._personaState = newValue}
    }
    /// Returns true if `personaState` has been explicitly set.
    var hasPersonaState: Bool {return _storage._personaState != nil}
    /// Clears the value of `personaState`. Subsequent reads from it will return its default value.
    mutating func clearPersonaState() {_uniqueStorage()._personaState = nil}

    var gamePlayedAppID: UInt32 {
      get {return _storage._gamePlayedAppID ?? 0}
      set {_uniqueStorage()._gamePlayedAppID = newValue}
    }
    /// Returns true if `gamePlayedAppID` has been explicitly set.
    var hasGamePlayedAppID: Bool {return _storage._gamePlayedAppID != nil}
    /// Clears the value of `gamePlayedAppID`. Subsequent reads from it will return its default value.
    mutating func clearGamePlayedAppID() {_uniqueStorage()._gamePlayedAppID = nil}

    var gameServerIp: UInt32 {
      get {return _storage._gameServerIp ?? 0}
      set {_uniqueStorage()._gameServerIp = newValue}
    }
    /// Returns true if `gameServerIp` has been explicitly set.
    var hasGameServerIp: Bool {return _storage._gameServerIp != nil}
    /// Clears the value of `gameServerIp`. Subsequent reads from it will return its default value.
    mutating func clearGameServerIp() {_uniqueStorage()._gameServerIp = nil}

    var gameServerPort: UInt32 {
      get {return _storage._gameServerPort ?? 0}
      set {_uniqueStorage()._gameServerPort = newValue}
    }
    /// Returns true if `gameServerPort` has been explicitly set.
    var hasGameServerPort: Bool {return _storage._gameServerPort != nil}
    /// Clears the value of `gameServerPort`. Subsequent reads from it will return its default value.
    mutating func clearGameServerPort() {_uniqueStorage()._gameServerPort = nil}

    var personaStateFlags: UInt32 {
      get {return _storage._personaStateFlags ?? 0}
      set {_uniqueStorage()._personaStateFlags = newValue}
    }
    /// Returns true if `personaStateFlags` has been explicitly set.
    var hasPersonaStateFlags: Bool {return _storage._personaStateFlags != nil}
    /// Clears the value of `personaStateFlags`. Subsequent reads from it will return its default value.
    mutating func clearPersonaStateFlags() {_uniqueStorage()._personaStateFlags = nil}

    var onlineSessionInstances: UInt32 {
      get {return _storage._onlineSessionInstances ?? 0}
      set {_uniqueStorage()._onlineSessionInstances = newValue}
    }
    /// Returns true if `onlineSessionInstances` has been explicitly set.
    var hasOnlineSessionInstances: Bool {return _storage._onlineSessionInstances != nil}
    /// Clears the value of `onlineSessionInstances`. Subsequent reads from it will return its default value.
    mutating func clearOnlineSessionInstances() {_uniqueStorage()._onlineSessionInstances = nil}

    var personaSetByUser: Bool {
      get {return _storage._personaSetByUser ?? false}
      set {_uniqueStorage()._personaSetByUser = newValue}
    }
    /// Returns true if `personaSetByUser` has been explicitly set.
    var hasPersonaSetByUser: Bool {return _storage._personaSetByUser != nil}
    /// Clears the value of `personaSetByUser`. Subsequent reads from it will return its default value.
    mutating func clearPersonaSetByUser() {_uniqueStorage()._personaSetByUser = nil}

    var playerName: String {
      get {return _storage._playerName ?? String()}
      set {_uniqueStorage()._playerName = newValue}
    }
    /// Returns true if `playerName` has been explicitly set.
    var hasPlayerName: Bool {return _storage._playerName != nil}
    /// Clears the value of `playerName`. Subsequent reads from it will return its default value.
    mutating func clearPlayerName() {_uniqueStorage()._playerName = nil}

    var queryPort: UInt32 {
      get {return _storage._queryPort ?? 0}
      set {_uniqueStorage()._queryPort = newValue}
    }
    /// Returns true if `queryPort` has been explicitly set.
    var hasQueryPort: Bool {return _storage._queryPort != nil}
    /// Clears the value of `queryPort`. Subsequent reads from it will return its default value.
    mutating func clearQueryPort() {_uniqueStorage()._queryPort = nil}

    var steamidSource: UInt64 {
      get {return _storage._steamidSource ?? 0}
      set {_uniqueStorage()._steamidSource = newValue}
    }
    /// Returns true if `steamidSource` has been explicitly set.
    var hasSteamidSource: Bool {return _storage._steamidSource != nil}
    /// Clears the value of `steamidSource`. Subsequent reads from it will return its default value.
    mutating func clearSteamidSource() {_uniqueStorage()._steamidSource = nil}

    var avatarHash: Data {
      get {return _storage._avatarHash ?? Data()}
      set {_uniqueStorage()._avatarHash = newValue}
    }
    /// Returns true if `avatarHash` has been explicitly set.
    var hasAvatarHash: Bool {return _storage._avatarHash != nil}
    /// Clears the value of `avatarHash`. Subsequent reads from it will return its default value.
    mutating func clearAvatarHash() {_uniqueStorage()._avatarHash = nil}

    var lastLogoff: UInt32 {
      get {return _storage._lastLogoff ?? 0}
      set {_uniqueStorage()._lastLogoff = newValue}
    }
    /// Returns true if `lastLogoff` has been explicitly set.
    var hasLastLogoff: Bool {return _storage._lastLogoff != nil}
    /// Clears the value of `lastLogoff`. Subsequent reads from it will return its default value.
    mutating func clearLastLogoff() {_uniqueStorage()._lastLogoff = nil}

    var lastLogon: UInt32 {
      get {return _storage._lastLogon ?? 0}
      set {_uniqueStorage()._lastLogon = newValue}
    }
    /// Returns true if `lastLogon` has been explicitly set.
    var hasLastLogon: Bool {return _storage._lastLogon != nil}
    /// Clears the value of `lastLogon`. Subsequent reads from it will return its default value.
    mutating func clearLastLogon() {_uniqueStorage()._lastLogon = nil}

    var lastSeenOnline: UInt32 {
      get {return _storage._lastSeenOnline ?? 0}
      set {_uniqueStorage()._lastSeenOnline = newValue}
    }
    /// Returns true if `lastSeenOnline` has been explicitly set.
    var hasLastSeenOnline: Bool {return _storage._lastSeenOnline != nil}
    /// Clears the value of `lastSeenOnline`. Subsequent reads from it will return its default value.
    mutating func clearLastSeenOnline() {_uniqueStorage()._lastSeenOnline = nil}

    var clanRank: UInt32 {
      get {return _storage._clanRank ?? 0}
      set {_uniqueStorage()._clanRank = newValue}
    }
    /// Returns true if `clanRank` has been explicitly set.
    var hasClanRank: Bool {return _storage._clanRank != nil}
    /// Clears the value of `clanRank`. Subsequent reads from it will return its default value.
    mutating func clearClanRank() {_uniqueStorage()._clanRank = nil}

    var gameName: String {
      get {return _storage._gameName ?? String()}
      set {_uniqueStorage()._gameName = newValue}
    }
    /// Returns true if `gameName` has been explicitly set.
    var hasGameName: Bool {return _storage._gameName != nil}
    /// Clears the value of `gameName`. Subsequent reads from it will return its default value.
    mutating func clearGameName() {_uniqueStorage()._gameName = nil}

    var gameid: UInt64 {
      get {return _storage._gameid ?? 0}
      set {_uniqueStorage()._gameid = newValue}
    }
    /// Returns true if `gameid` has been explicitly set.
    var hasGameid: Bool {return _storage._gameid != nil}
    /// Clears the value of `gameid`. Subsequent reads from it will return its default value.
    mutating func clearGameid() {_uniqueStorage()._gameid = nil}

    var gameDataBlob: Data {
      get {return _storage._gameDataBlob ?? Data()}
      set {_uniqueStorage()._gameDataBlob = newValue}
    }
    /// Returns true if `gameDataBlob` has been explicitly set.
    var hasGameDataBlob: Bool {return _storage._gameDataBlob != nil}
    /// Clears the value of `gameDataBlob`. Subsequent reads from it will return its default value.
    mutating func clearGameDataBlob() {_uniqueStorage()._gameDataBlob = nil}

    var clanData: CMsgClientPersonaState.Friend.ClanData {
      get {return _storage._clanData ?? CMsgClientPersonaState.Friend.ClanData()}
      set {_uniqueStorage()._clanData = newValue}
    }
    /// Returns true if `clanData` has been explicitly set.
    var hasClanData: Bool {return _storage._clanData != nil}
    /// Clears the value of `clanData`. Subsequent reads from it will return its default value.
    mutating func clearClanData() {_uniqueStorage()._clanData = nil}

    var clanTag: String {
      get {return _storage._clanTag ?? String()}
      set {_uniqueStorage()._clanTag = newValue}
    }
    /// Returns true if `clanTag` has been explicitly set.
    var hasClanTag: Bool {return _storage._clanTag != nil}
    /// Clears the value of `clanTag`. Subsequent reads from it will return its default value.
    mutating func clearClanTag() {_uniqueStorage()._clanTag = nil}

    var richPresence: [CMsgClientPersonaState.Friend.KV] {
      get {return _storage._richPresence}
      set {_uniqueStorage()._richPresence = newValue}
    }

    var broadcastID: UInt64 {
      get {return _storage._broadcastID ?? 0}
      set {_uniqueStorage()._broadcastID = newValue}
    }
    /// Returns true if `broadcastID` has been explicitly set.
    var hasBroadcastID: Bool {return _storage._broadcastID != nil}
    /// Clears the value of `broadcastID`. Subsequent reads from it will return its default value.
    mutating func clearBroadcastID() {_uniqueStorage()._broadcastID = nil}

    var gameLobbyID: UInt64 {
      get {return _storage._gameLobbyID ?? 0}
      set {_uniqueStorage()._gameLobbyID = newValue}
    }
    /// Returns true if `gameLobbyID` has been explicitly set.
    var hasGameLobbyID: Bool {return _storage._gameLobbyID != nil}
    /// Clears the value of `gameLobbyID`. Subsequent reads from it will return its default value.
    mutating func clearGameLobbyID() {_uniqueStorage()._gameLobbyID = nil}

    var watchingBroadcastAccountid: UInt32 {
      get {return _storage._watchingBroadcastAccountid ?? 0}
      set {_uniqueStorage()._watchingBroadcastAccountid = newValue}
    }
    /// Returns true if `watchingBroadcastAccountid` has been explicitly set.
    var hasWatchingBroadcastAccountid: Bool {return _storage._watchingBroadcastAccountid != nil}
    /// Clears the value of `watchingBroadcastAccountid`. Subsequent reads from it will return its default value.
    mutating func clearWatchingBroadcastAccountid() {_uniqueStorage()._watchingBroadcastAccountid = nil}

    var watchingBroadcastAppid: UInt32 {
      get {return _storage._watchingBroadcastAppid ?? 0}
      set {_uniqueStorage()._watchingBroadcastAppid = newValue}
    }
    /// Returns true if `watchingBroadcastAppid` has been explicitly set.
    var hasWatchingBroadcastAppid: Bool {return _storage._watchingBroadcastAppid != nil}
    /// Clears the value of `watchingBroadcastAppid`. Subsequent reads from it will return its default value.
    mutating func clearWatchingBroadcastAppid() {_uniqueStorage()._watchingBroadcastAppid = nil}

    var watchingBroadcastViewers: UInt32 {
      get {return _storage._watchingBroadcastViewers ?? 0}
      set {_uniqueStorage()._watchingBroadcastViewers = newValue}
    }
    /// Returns true if `watchingBroadcastViewers` has been explicitly set.
    var hasWatchingBroadcastViewers: Bool {return _storage._watchingBroadcastViewers != nil}
    /// Clears the value of `watchingBroadcastViewers`. Subsequent reads from it will return its default value.
    mutating func clearWatchingBroadcastViewers() {_uniqueStorage()._watchingBroadcastViewers = nil}

    var watchingBroadcastTitle: String {
      get {return _storage._watchingBroadcastTitle ?? String()}
      set {_uniqueStorage()._watchingBroadcastTitle = newValue}
    }
    /// Returns true if `watchingBroadcastTitle` has been explicitly set.
    var hasWatchingBroadcastTitle: Bool {return _storage._watchingBroadcastTitle != nil}
    /// Clears the value of `watchingBroadcastTitle`. Subsequent reads from it will return its default value.
    mutating func clearWatchingBroadcastTitle() {_uniqueStorage()._watchingBroadcastTitle = nil}

    var isCommunityBanned: Bool {
      get {return _storage._isCommunityBanned ?? false}
      set {_uniqueStorage()._isCommunityBanned = newValue}
    }
    /// Returns true if `isCommunityBanned` has been explicitly set.
    var hasIsCommunityBanned: Bool {return _storage._isCommunityBanned != nil}
    /// Clears the value of `isCommunityBanned`. Subsequent reads from it will return its default value.
    mutating func clearIsCommunityBanned() {_uniqueStorage()._isCommunityBanned = nil}

    var playerNamePendingReview: Bool {
      get {return _storage._playerNamePendingReview ?? false}
      set {_uniqueStorage()._playerNamePendingReview = newValue}
    }
    /// Returns true if `playerNamePendingReview` has been explicitly set.
    var hasPlayerNamePendingReview: Bool {return _storage._playerNamePendingReview != nil}
    /// Clears the value of `playerNamePendingReview`. Subsequent reads from it will return its default value.
    mutating func clearPlayerNamePendingReview() {_uniqueStorage()._playerNamePendingReview = nil}

    var avatarPendingReview: Bool {
      get {return _storage._avatarPendingReview ?? false}
      set {_uniqueStorage()._avatarPendingReview = newValue}
    }
    /// Returns true if `avatarPendingReview` has been explicitly set.
    var hasAvatarPendingReview: Bool {return _storage._avatarPendingReview != nil}
    /// Clears the value of `avatarPendingReview`. Subsequent reads from it will return its default value.
    mutating func clearAvatarPendingReview() {_uniqueStorage()._avatarPendingReview = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct ClanData {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var oggAppID: UInt32 {
        get {return _oggAppID ?? 0}
        set {_oggAppID = newValue}
      }
      /// Returns true if `oggAppID` has been explicitly set.
      var hasOggAppID: Bool {return self._oggAppID != nil}
      /// Clears the value of `oggAppID`. Subsequent reads from it will return its default value.
      mutating func clearOggAppID() {self._oggAppID = nil}

      var chatGroupID: UInt64 {
        get {return _chatGroupID ?? 0}
        set {_chatGroupID = newValue}
      }
      /// Returns true if `chatGroupID` has been explicitly set.
      var hasChatGroupID: Bool {return self._chatGroupID != nil}
      /// Clears the value of `chatGroupID`. Subsequent reads from it will return its default value.
      mutating func clearChatGroupID() {self._chatGroupID = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _oggAppID: UInt32? = nil
      fileprivate var _chatGroupID: UInt64? = nil
    }

    struct KV {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var key: String {
        get {return _key ?? String()}
        set {_key = newValue}
      }
      /// Returns true if `key` has been explicitly set.
      var hasKey: Bool {return self._key != nil}
      /// Clears the value of `key`. Subsequent reads from it will return its default value.
      mutating func clearKey() {self._key = nil}

      var value: String {
        get {return _value ?? String()}
        set {_value = newValue}
      }
      /// Returns true if `value` has been explicitly set.
      var hasValue: Bool {return self._value != nil}
      /// Clears the value of `value`. Subsequent reads from it will return its default value.
      mutating func clearValue() {self._value = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _key: String? = nil
      fileprivate var _value: String? = nil
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _statusFlags: UInt32? = nil
}

struct CMsgClientFriendProfileInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var steamidFriend: UInt64 {
    get {return _steamidFriend ?? 0}
    set {_steamidFriend = newValue}
  }
  /// Returns true if `steamidFriend` has been explicitly set.
  var hasSteamidFriend: Bool {return self._steamidFriend != nil}
  /// Clears the value of `steamidFriend`. Subsequent reads from it will return its default value.
  mutating func clearSteamidFriend() {self._steamidFriend = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _steamidFriend: UInt64? = nil
}

struct CMsgClientFriendProfileInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var steamidFriend: UInt64 {
    get {return _steamidFriend ?? 0}
    set {_steamidFriend = newValue}
  }
  /// Returns true if `steamidFriend` has been explicitly set.
  var hasSteamidFriend: Bool {return self._steamidFriend != nil}
  /// Clears the value of `steamidFriend`. Subsequent reads from it will return its default value.
  mutating func clearSteamidFriend() {self._steamidFriend = nil}

  var timeCreated: UInt32 {
    get {return _timeCreated ?? 0}
    set {_timeCreated = newValue}
  }
  /// Returns true if `timeCreated` has been explicitly set.
  var hasTimeCreated: Bool {return self._timeCreated != nil}
  /// Clears the value of `timeCreated`. Subsequent reads from it will return its default value.
  mutating func clearTimeCreated() {self._timeCreated = nil}

  var realName: String {
    get {return _realName ?? String()}
    set {_realName = newValue}
  }
  /// Returns true if `realName` has been explicitly set.
  var hasRealName: Bool {return self._realName != nil}
  /// Clears the value of `realName`. Subsequent reads from it will return its default value.
  mutating func clearRealName() {self._realName = nil}

  var cityName: String {
    get {return _cityName ?? String()}
    set {_cityName = newValue}
  }
  /// Returns true if `cityName` has been explicitly set.
  var hasCityName: Bool {return self._cityName != nil}
  /// Clears the value of `cityName`. Subsequent reads from it will return its default value.
  mutating func clearCityName() {self._cityName = nil}

  var stateName: String {
    get {return _stateName ?? String()}
    set {_stateName = newValue}
  }
  /// Returns true if `stateName` has been explicitly set.
  var hasStateName: Bool {return self._stateName != nil}
  /// Clears the value of `stateName`. Subsequent reads from it will return its default value.
  mutating func clearStateName() {self._stateName = nil}

  var countryName: String {
    get {return _countryName ?? String()}
    set {_countryName = newValue}
  }
  /// Returns true if `countryName` has been explicitly set.
  var hasCountryName: Bool {return self._countryName != nil}
  /// Clears the value of `countryName`. Subsequent reads from it will return its default value.
  mutating func clearCountryName() {self._countryName = nil}

  var headline: String {
    get {return _headline ?? String()}
    set {_headline = newValue}
  }
  /// Returns true if `headline` has been explicitly set.
  var hasHeadline: Bool {return self._headline != nil}
  /// Clears the value of `headline`. Subsequent reads from it will return its default value.
  mutating func clearHeadline() {self._headline = nil}

  var summary: String {
    get {return _summary ?? String()}
    set {_summary = newValue}
  }
  /// Returns true if `summary` has been explicitly set.
  var hasSummary: Bool {return self._summary != nil}
  /// Clears the value of `summary`. Subsequent reads from it will return its default value.
  mutating func clearSummary() {self._summary = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: Int32? = nil
  fileprivate var _steamidFriend: UInt64? = nil
  fileprivate var _timeCreated: UInt32? = nil
  fileprivate var _realName: String? = nil
  fileprivate var _cityName: String? = nil
  fileprivate var _stateName: String? = nil
  fileprivate var _countryName: String? = nil
  fileprivate var _headline: String? = nil
  fileprivate var _summary: String? = nil
}

struct CMsgClientCreateFriendsGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var steamid: UInt64 {
    get {return _steamid ?? 0}
    set {_steamid = newValue}
  }
  /// Returns true if `steamid` has been explicitly set.
  var hasSteamid: Bool {return self._steamid != nil}
  /// Clears the value of `steamid`. Subsequent reads from it will return its default value.
  mutating func clearSteamid() {self._steamid = nil}

  var groupname: String {
    get {return _groupname ?? String()}
    set {_groupname = newValue}
  }
  /// Returns true if `groupname` has been explicitly set.
  var hasGroupname: Bool {return self._groupname != nil}
  /// Clears the value of `groupname`. Subsequent reads from it will return its default value.
  mutating func clearGroupname() {self._groupname = nil}

  var steamidFriends: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _steamid: UInt64? = nil
  fileprivate var _groupname: String? = nil
}

struct CMsgClientCreateFriendsGroupResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: UInt32 {
    get {return _eresult ?? 0}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var groupid: Int32 {
    get {return _groupid ?? 0}
    set {_groupid = newValue}
  }
  /// Returns true if `groupid` has been explicitly set.
  var hasGroupid: Bool {return self._groupid != nil}
  /// Clears the value of `groupid`. Subsequent reads from it will return its default value.
  mutating func clearGroupid() {self._groupid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: UInt32? = nil
  fileprivate var _groupid: Int32? = nil
}

struct CMsgClientDeleteFriendsGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var steamid: UInt64 {
    get {return _steamid ?? 0}
    set {_steamid = newValue}
  }
  /// Returns true if `steamid` has been explicitly set.
  var hasSteamid: Bool {return self._steamid != nil}
  /// Clears the value of `steamid`. Subsequent reads from it will return its default value.
  mutating func clearSteamid() {self._steamid = nil}

  var groupid: Int32 {
    get {return _groupid ?? 0}
    set {_groupid = newValue}
  }
  /// Returns true if `groupid` has been explicitly set.
  var hasGroupid: Bool {return self._groupid != nil}
  /// Clears the value of `groupid`. Subsequent reads from it will return its default value.
  mutating func clearGroupid() {self._groupid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _steamid: UInt64? = nil
  fileprivate var _groupid: Int32? = nil
}

struct CMsgClientDeleteFriendsGroupResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: UInt32 {
    get {return _eresult ?? 0}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: UInt32? = nil
}

struct CMsgClientManageFriendsGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groupid: Int32 {
    get {return _groupid ?? 0}
    set {_groupid = newValue}
  }
  /// Returns true if `groupid` has been explicitly set.
  var hasGroupid: Bool {return self._groupid != nil}
  /// Clears the value of `groupid`. Subsequent reads from it will return its default value.
  mutating func clearGroupid() {self._groupid = nil}

  var groupname: String {
    get {return _groupname ?? String()}
    set {_groupname = newValue}
  }
  /// Returns true if `groupname` has been explicitly set.
  var hasGroupname: Bool {return self._groupname != nil}
  /// Clears the value of `groupname`. Subsequent reads from it will return its default value.
  mutating func clearGroupname() {self._groupname = nil}

  var steamidFriendsAdded: [UInt64] = []

  var steamidFriendsRemoved: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _groupid: Int32? = nil
  fileprivate var _groupname: String? = nil
}

struct CMsgClientManageFriendsGroupResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: UInt32 {
    get {return _eresult ?? 0}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: UInt32? = nil
}

struct CMsgClientAddFriendToGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groupid: Int32 {
    get {return _groupid ?? 0}
    set {_groupid = newValue}
  }
  /// Returns true if `groupid` has been explicitly set.
  var hasGroupid: Bool {return self._groupid != nil}
  /// Clears the value of `groupid`. Subsequent reads from it will return its default value.
  mutating func clearGroupid() {self._groupid = nil}

  var steamiduser: UInt64 {
    get {return _steamiduser ?? 0}
    set {_steamiduser = newValue}
  }
  /// Returns true if `steamiduser` has been explicitly set.
  var hasSteamiduser: Bool {return self._steamiduser != nil}
  /// Clears the value of `steamiduser`. Subsequent reads from it will return its default value.
  mutating func clearSteamiduser() {self._steamiduser = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _groupid: Int32? = nil
  fileprivate var _steamiduser: UInt64? = nil
}

struct CMsgClientAddFriendToGroupResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: UInt32 {
    get {return _eresult ?? 0}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: UInt32? = nil
}

struct CMsgClientRemoveFriendFromGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groupid: Int32 {
    get {return _groupid ?? 0}
    set {_groupid = newValue}
  }
  /// Returns true if `groupid` has been explicitly set.
  var hasGroupid: Bool {return self._groupid != nil}
  /// Clears the value of `groupid`. Subsequent reads from it will return its default value.
  mutating func clearGroupid() {self._groupid = nil}

  var steamiduser: UInt64 {
    get {return _steamiduser ?? 0}
    set {_steamiduser = newValue}
  }
  /// Returns true if `steamiduser` has been explicitly set.
  var hasSteamiduser: Bool {return self._steamiduser != nil}
  /// Clears the value of `steamiduser`. Subsequent reads from it will return its default value.
  mutating func clearSteamiduser() {self._steamiduser = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _groupid: Int32? = nil
  fileprivate var _steamiduser: UInt64? = nil
}

struct CMsgClientRemoveFriendFromGroupResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: UInt32 {
    get {return _eresult ?? 0}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: UInt32? = nil
}

struct CMsgClientGetEmoticonList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CMsgClientEmoticonList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var emoticons: [CMsgClientEmoticonList.Emoticon] = []

  var stickers: [CMsgClientEmoticonList.Sticker] = []

  var effects: [CMsgClientEmoticonList.Effect] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Emoticon {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var count: Int32 {
      get {return _count ?? 0}
      set {_count = newValue}
    }
    /// Returns true if `count` has been explicitly set.
    var hasCount: Bool {return self._count != nil}
    /// Clears the value of `count`. Subsequent reads from it will return its default value.
    mutating func clearCount() {self._count = nil}

    var timeLastUsed: UInt32 {
      get {return _timeLastUsed ?? 0}
      set {_timeLastUsed = newValue}
    }
    /// Returns true if `timeLastUsed` has been explicitly set.
    var hasTimeLastUsed: Bool {return self._timeLastUsed != nil}
    /// Clears the value of `timeLastUsed`. Subsequent reads from it will return its default value.
    mutating func clearTimeLastUsed() {self._timeLastUsed = nil}

    var useCount: UInt32 {
      get {return _useCount ?? 0}
      set {_useCount = newValue}
    }
    /// Returns true if `useCount` has been explicitly set.
    var hasUseCount: Bool {return self._useCount != nil}
    /// Clears the value of `useCount`. Subsequent reads from it will return its default value.
    mutating func clearUseCount() {self._useCount = nil}

    var timeReceived: UInt32 {
      get {return _timeReceived ?? 0}
      set {_timeReceived = newValue}
    }
    /// Returns true if `timeReceived` has been explicitly set.
    var hasTimeReceived: Bool {return self._timeReceived != nil}
    /// Clears the value of `timeReceived`. Subsequent reads from it will return its default value.
    mutating func clearTimeReceived() {self._timeReceived = nil}

    var appid: UInt32 {
      get {return _appid ?? 0}
      set {_appid = newValue}
    }
    /// Returns true if `appid` has been explicitly set.
    var hasAppid: Bool {return self._appid != nil}
    /// Clears the value of `appid`. Subsequent reads from it will return its default value.
    mutating func clearAppid() {self._appid = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _name: String? = nil
    fileprivate var _count: Int32? = nil
    fileprivate var _timeLastUsed: UInt32? = nil
    fileprivate var _useCount: UInt32? = nil
    fileprivate var _timeReceived: UInt32? = nil
    fileprivate var _appid: UInt32? = nil
  }

  struct Sticker {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var count: Int32 {
      get {return _count ?? 0}
      set {_count = newValue}
    }
    /// Returns true if `count` has been explicitly set.
    var hasCount: Bool {return self._count != nil}
    /// Clears the value of `count`. Subsequent reads from it will return its default value.
    mutating func clearCount() {self._count = nil}

    var timeReceived: UInt32 {
      get {return _timeReceived ?? 0}
      set {_timeReceived = newValue}
    }
    /// Returns true if `timeReceived` has been explicitly set.
    var hasTimeReceived: Bool {return self._timeReceived != nil}
    /// Clears the value of `timeReceived`. Subsequent reads from it will return its default value.
    mutating func clearTimeReceived() {self._timeReceived = nil}

    var appid: UInt32 {
      get {return _appid ?? 0}
      set {_appid = newValue}
    }
    /// Returns true if `appid` has been explicitly set.
    var hasAppid: Bool {return self._appid != nil}
    /// Clears the value of `appid`. Subsequent reads from it will return its default value.
    mutating func clearAppid() {self._appid = nil}

    var timeLastUsed: UInt32 {
      get {return _timeLastUsed ?? 0}
      set {_timeLastUsed = newValue}
    }
    /// Returns true if `timeLastUsed` has been explicitly set.
    var hasTimeLastUsed: Bool {return self._timeLastUsed != nil}
    /// Clears the value of `timeLastUsed`. Subsequent reads from it will return its default value.
    mutating func clearTimeLastUsed() {self._timeLastUsed = nil}

    var useCount: UInt32 {
      get {return _useCount ?? 0}
      set {_useCount = newValue}
    }
    /// Returns true if `useCount` has been explicitly set.
    var hasUseCount: Bool {return self._useCount != nil}
    /// Clears the value of `useCount`. Subsequent reads from it will return its default value.
    mutating func clearUseCount() {self._useCount = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _name: String? = nil
    fileprivate var _count: Int32? = nil
    fileprivate var _timeReceived: UInt32? = nil
    fileprivate var _appid: UInt32? = nil
    fileprivate var _timeLastUsed: UInt32? = nil
    fileprivate var _useCount: UInt32? = nil
  }

  struct Effect {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var count: Int32 {
      get {return _count ?? 0}
      set {_count = newValue}
    }
    /// Returns true if `count` has been explicitly set.
    var hasCount: Bool {return self._count != nil}
    /// Clears the value of `count`. Subsequent reads from it will return its default value.
    mutating func clearCount() {self._count = nil}

    var timeReceived: UInt32 {
      get {return _timeReceived ?? 0}
      set {_timeReceived = newValue}
    }
    /// Returns true if `timeReceived` has been explicitly set.
    var hasTimeReceived: Bool {return self._timeReceived != nil}
    /// Clears the value of `timeReceived`. Subsequent reads from it will return its default value.
    mutating func clearTimeReceived() {self._timeReceived = nil}

    var infiniteUse: Bool {
      get {return _infiniteUse ?? false}
      set {_infiniteUse = newValue}
    }
    /// Returns true if `infiniteUse` has been explicitly set.
    var hasInfiniteUse: Bool {return self._infiniteUse != nil}
    /// Clears the value of `infiniteUse`. Subsequent reads from it will return its default value.
    mutating func clearInfiniteUse() {self._infiniteUse = nil}

    var appid: UInt32 {
      get {return _appid ?? 0}
      set {_appid = newValue}
    }
    /// Returns true if `appid` has been explicitly set.
    var hasAppid: Bool {return self._appid != nil}
    /// Clears the value of `appid`. Subsequent reads from it will return its default value.
    mutating func clearAppid() {self._appid = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _name: String? = nil
    fileprivate var _count: Int32? = nil
    fileprivate var _timeReceived: UInt32? = nil
    fileprivate var _infiniteUse: Bool? = nil
    fileprivate var _appid: UInt32? = nil
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension CMsgClientFriendMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientFriendMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "steamid"),
    2: .standard(proto: "chat_entry_type"),
    3: .same(proto: "message"),
    4: .standard(proto: "rtime32_server_timestamp"),
    5: .standard(proto: "echo_to_sender"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._steamid) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._chatEntryType) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._message) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._rtime32ServerTimestamp) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._echoToSender) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._steamid {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._chatEntryType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._message {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    if let v = self._rtime32ServerTimestamp {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    }
    if let v = self._echoToSender {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientFriendMsg, rhs: CMsgClientFriendMsg) -> Bool {
    if lhs._steamid != rhs._steamid {return false}
    if lhs._chatEntryType != rhs._chatEntryType {return false}
    if lhs._message != rhs._message {return false}
    if lhs._rtime32ServerTimestamp != rhs._rtime32ServerTimestamp {return false}
    if lhs._echoToSender != rhs._echoToSender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientFriendMsgIncoming: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientFriendMsgIncoming"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "steamid_from"),
    2: .standard(proto: "chat_entry_type"),
    3: .standard(proto: "from_limited_account"),
    4: .same(proto: "message"),
    5: .standard(proto: "rtime32_server_timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._steamidFrom) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._chatEntryType) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._fromLimitedAccount) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._message) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._rtime32ServerTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._steamidFrom {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._chatEntryType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._fromLimitedAccount {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._message {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }
    if let v = self._rtime32ServerTimestamp {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientFriendMsgIncoming, rhs: CMsgClientFriendMsgIncoming) -> Bool {
    if lhs._steamidFrom != rhs._steamidFrom {return false}
    if lhs._chatEntryType != rhs._chatEntryType {return false}
    if lhs._fromLimitedAccount != rhs._fromLimitedAccount {return false}
    if lhs._message != rhs._message {return false}
    if lhs._rtime32ServerTimestamp != rhs._rtime32ServerTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientAddFriend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientAddFriend"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "steamid_to_add"),
    2: .standard(proto: "accountname_or_email_to_add"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._steamidToAdd) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._accountnameOrEmailToAdd) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._steamidToAdd {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._accountnameOrEmailToAdd {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientAddFriend, rhs: CMsgClientAddFriend) -> Bool {
    if lhs._steamidToAdd != rhs._steamidToAdd {return false}
    if lhs._accountnameOrEmailToAdd != rhs._accountnameOrEmailToAdd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientAddFriendResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientAddFriendResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "steam_id_added"),
    3: .standard(proto: "persona_name_added"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self._steamIDAdded) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._personaNameAdded) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._steamIDAdded {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 2)
    }
    if let v = self._personaNameAdded {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientAddFriendResponse, rhs: CMsgClientAddFriendResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs._steamIDAdded != rhs._steamIDAdded {return false}
    if lhs._personaNameAdded != rhs._personaNameAdded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRemoveFriend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRemoveFriend"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "friendid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._friendid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._friendid {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRemoveFriend, rhs: CMsgClientRemoveFriend) -> Bool {
    if lhs._friendid != rhs._friendid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientHideFriend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientHideFriend"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "friendid"),
    2: .same(proto: "hide"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._friendid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._hide) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._friendid {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._hide {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientHideFriend, rhs: CMsgClientHideFriend) -> Bool {
    if lhs._friendid != rhs._friendid {return false}
    if lhs._hide != rhs._hide {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientFriendsList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientFriendsList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bincremental"),
    2: .same(proto: "friends"),
    3: .standard(proto: "max_friend_count"),
    4: .standard(proto: "active_friend_count"),
    5: .standard(proto: "friends_limit_hit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._bincremental) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.friends) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._maxFriendCount) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._activeFriendCount) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._friendsLimitHit) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._bincremental {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if !self.friends.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.friends, fieldNumber: 2)
    }
    if let v = self._maxFriendCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._activeFriendCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._friendsLimitHit {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientFriendsList, rhs: CMsgClientFriendsList) -> Bool {
    if lhs._bincremental != rhs._bincremental {return false}
    if lhs.friends != rhs.friends {return false}
    if lhs._maxFriendCount != rhs._maxFriendCount {return false}
    if lhs._activeFriendCount != rhs._activeFriendCount {return false}
    if lhs._friendsLimitHit != rhs._friendsLimitHit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientFriendsList.Friend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientFriendsList.protoMessageName + ".Friend"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ulfriendid"),
    2: .same(proto: "efriendrelationship"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._ulfriendid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._efriendrelationship) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._ulfriendid {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._efriendrelationship {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientFriendsList.Friend, rhs: CMsgClientFriendsList.Friend) -> Bool {
    if lhs._ulfriendid != rhs._ulfriendid {return false}
    if lhs._efriendrelationship != rhs._efriendrelationship {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientFriendsGroupsList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientFriendsGroupsList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bremoval"),
    2: .same(proto: "bincremental"),
    3: .same(proto: "friendGroups"),
    4: .same(proto: "memberships"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._bremoval) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._bincremental) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.friendGroups) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.memberships) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._bremoval {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._bincremental {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if !self.friendGroups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.friendGroups, fieldNumber: 3)
    }
    if !self.memberships.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.memberships, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientFriendsGroupsList, rhs: CMsgClientFriendsGroupsList) -> Bool {
    if lhs._bremoval != rhs._bremoval {return false}
    if lhs._bincremental != rhs._bincremental {return false}
    if lhs.friendGroups != rhs.friendGroups {return false}
    if lhs.memberships != rhs.memberships {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientFriendsGroupsList.FriendGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientFriendsGroupsList.protoMessageName + ".FriendGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nGroupID"),
    2: .same(proto: "strGroupName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._nGroupID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._strGroupName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._nGroupID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._strGroupName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientFriendsGroupsList.FriendGroup, rhs: CMsgClientFriendsGroupsList.FriendGroup) -> Bool {
    if lhs._nGroupID != rhs._nGroupID {return false}
    if lhs._strGroupName != rhs._strGroupName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientFriendsGroupsList.FriendGroupsMembership: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientFriendsGroupsList.protoMessageName + ".FriendGroupsMembership"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ulSteamID"),
    2: .same(proto: "nGroupID"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._ulSteamID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._nGroupID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._ulSteamID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._nGroupID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientFriendsGroupsList.FriendGroupsMembership, rhs: CMsgClientFriendsGroupsList.FriendGroupsMembership) -> Bool {
    if lhs._ulSteamID != rhs._ulSteamID {return false}
    if lhs._nGroupID != rhs._nGroupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientPlayerNicknameList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientPlayerNicknameList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "removal"),
    2: .same(proto: "incremental"),
    3: .same(proto: "nicknames"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._removal) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._incremental) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.nicknames) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._removal {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._incremental {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if !self.nicknames.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nicknames, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientPlayerNicknameList, rhs: CMsgClientPlayerNicknameList) -> Bool {
    if lhs._removal != rhs._removal {return false}
    if lhs._incremental != rhs._incremental {return false}
    if lhs.nicknames != rhs.nicknames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientPlayerNicknameList.PlayerNickname: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientPlayerNicknameList.protoMessageName + ".PlayerNickname"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "steamid"),
    3: .same(proto: "nickname"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._steamid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._nickname) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._steamid {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._nickname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientPlayerNicknameList.PlayerNickname, rhs: CMsgClientPlayerNicknameList.PlayerNickname) -> Bool {
    if lhs._steamid != rhs._steamid {return false}
    if lhs._nickname != rhs._nickname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientSetPlayerNickname: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientSetPlayerNickname"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "steamid"),
    2: .same(proto: "nickname"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._steamid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._nickname) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._steamid {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._nickname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientSetPlayerNickname, rhs: CMsgClientSetPlayerNickname) -> Bool {
    if lhs._steamid != rhs._steamid {return false}
    if lhs._nickname != rhs._nickname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientSetPlayerNicknameResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientSetPlayerNicknameResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._eresult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientSetPlayerNicknameResponse, rhs: CMsgClientSetPlayerNicknameResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRequestFriendData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRequestFriendData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "persona_state_requested"),
    2: .same(proto: "friends"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._personaStateRequested) }()
      case 2: try { try decoder.decodeRepeatedFixed64Field(value: &self.friends) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._personaStateRequested {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if !self.friends.isEmpty {
      try visitor.visitRepeatedFixed64Field(value: self.friends, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRequestFriendData, rhs: CMsgClientRequestFriendData) -> Bool {
    if lhs._personaStateRequested != rhs._personaStateRequested {return false}
    if lhs.friends != rhs.friends {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientChangeStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientChangeStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "persona_state"),
    2: .standard(proto: "player_name"),
    3: .standard(proto: "is_auto_generated_name"),
    4: .standard(proto: "high_priority"),
    5: .standard(proto: "persona_set_by_user"),
    6: .standard(proto: "persona_state_flags"),
    7: .standard(proto: "need_persona_response"),
    8: .standard(proto: "is_client_idle"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._personaState) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._playerName) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._isAutoGeneratedName) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._highPriority) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._personaSetByUser) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._personaStateFlags) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._needPersonaResponse) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._isClientIdle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._personaState {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._playerName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._isAutoGeneratedName {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._highPriority {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if let v = self._personaSetByUser {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    if let v = self._personaStateFlags {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._needPersonaResponse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    }
    if let v = self._isClientIdle {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientChangeStatus, rhs: CMsgClientChangeStatus) -> Bool {
    if lhs._personaState != rhs._personaState {return false}
    if lhs._playerName != rhs._playerName {return false}
    if lhs._isAutoGeneratedName != rhs._isAutoGeneratedName {return false}
    if lhs._highPriority != rhs._highPriority {return false}
    if lhs._personaSetByUser != rhs._personaSetByUser {return false}
    if lhs._personaStateFlags != rhs._personaStateFlags {return false}
    if lhs._needPersonaResponse != rhs._needPersonaResponse {return false}
    if lhs._isClientIdle != rhs._isClientIdle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgPersonaChangeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgPersonaChangeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "player_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._playerName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._result {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._playerName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgPersonaChangeResponse, rhs: CMsgPersonaChangeResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs._playerName != rhs._playerName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientPersonaState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientPersonaState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "status_flags"),
    2: .same(proto: "friends"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._statusFlags) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.friends) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._statusFlags {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if !self.friends.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.friends, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientPersonaState, rhs: CMsgClientPersonaState) -> Bool {
    if lhs._statusFlags != rhs._statusFlags {return false}
    if lhs.friends != rhs.friends {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientPersonaState.Friend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientPersonaState.protoMessageName + ".Friend"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "friendid"),
    2: .standard(proto: "persona_state"),
    3: .standard(proto: "game_played_app_id"),
    4: .standard(proto: "game_server_ip"),
    5: .standard(proto: "game_server_port"),
    6: .standard(proto: "persona_state_flags"),
    7: .standard(proto: "online_session_instances"),
    10: .standard(proto: "persona_set_by_user"),
    15: .standard(proto: "player_name"),
    20: .standard(proto: "query_port"),
    25: .standard(proto: "steamid_source"),
    31: .standard(proto: "avatar_hash"),
    45: .standard(proto: "last_logoff"),
    46: .standard(proto: "last_logon"),
    47: .standard(proto: "last_seen_online"),
    50: .standard(proto: "clan_rank"),
    55: .standard(proto: "game_name"),
    56: .same(proto: "gameid"),
    60: .standard(proto: "game_data_blob"),
    64: .standard(proto: "clan_data"),
    65: .standard(proto: "clan_tag"),
    71: .standard(proto: "rich_presence"),
    72: .standard(proto: "broadcast_id"),
    73: .standard(proto: "game_lobby_id"),
    74: .standard(proto: "watching_broadcast_accountid"),
    75: .standard(proto: "watching_broadcast_appid"),
    76: .standard(proto: "watching_broadcast_viewers"),
    77: .standard(proto: "watching_broadcast_title"),
    78: .standard(proto: "is_community_banned"),
    79: .standard(proto: "player_name_pending_review"),
    80: .standard(proto: "avatar_pending_review"),
  ]

  fileprivate class _StorageClass {
    var _friendid: UInt64? = nil
    var _personaState: UInt32? = nil
    var _gamePlayedAppID: UInt32? = nil
    var _gameServerIp: UInt32? = nil
    var _gameServerPort: UInt32? = nil
    var _personaStateFlags: UInt32? = nil
    var _onlineSessionInstances: UInt32? = nil
    var _personaSetByUser: Bool? = nil
    var _playerName: String? = nil
    var _queryPort: UInt32? = nil
    var _steamidSource: UInt64? = nil
    var _avatarHash: Data? = nil
    var _lastLogoff: UInt32? = nil
    var _lastLogon: UInt32? = nil
    var _lastSeenOnline: UInt32? = nil
    var _clanRank: UInt32? = nil
    var _gameName: String? = nil
    var _gameid: UInt64? = nil
    var _gameDataBlob: Data? = nil
    var _clanData: CMsgClientPersonaState.Friend.ClanData? = nil
    var _clanTag: String? = nil
    var _richPresence: [CMsgClientPersonaState.Friend.KV] = []
    var _broadcastID: UInt64? = nil
    var _gameLobbyID: UInt64? = nil
    var _watchingBroadcastAccountid: UInt32? = nil
    var _watchingBroadcastAppid: UInt32? = nil
    var _watchingBroadcastViewers: UInt32? = nil
    var _watchingBroadcastTitle: String? = nil
    var _isCommunityBanned: Bool? = nil
    var _playerNamePendingReview: Bool? = nil
    var _avatarPendingReview: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _friendid = source._friendid
      _personaState = source._personaState
      _gamePlayedAppID = source._gamePlayedAppID
      _gameServerIp = source._gameServerIp
      _gameServerPort = source._gameServerPort
      _personaStateFlags = source._personaStateFlags
      _onlineSessionInstances = source._onlineSessionInstances
      _personaSetByUser = source._personaSetByUser
      _playerName = source._playerName
      _queryPort = source._queryPort
      _steamidSource = source._steamidSource
      _avatarHash = source._avatarHash
      _lastLogoff = source._lastLogoff
      _lastLogon = source._lastLogon
      _lastSeenOnline = source._lastSeenOnline
      _clanRank = source._clanRank
      _gameName = source._gameName
      _gameid = source._gameid
      _gameDataBlob = source._gameDataBlob
      _clanData = source._clanData
      _clanTag = source._clanTag
      _richPresence = source._richPresence
      _broadcastID = source._broadcastID
      _gameLobbyID = source._gameLobbyID
      _watchingBroadcastAccountid = source._watchingBroadcastAccountid
      _watchingBroadcastAppid = source._watchingBroadcastAppid
      _watchingBroadcastViewers = source._watchingBroadcastViewers
      _watchingBroadcastTitle = source._watchingBroadcastTitle
      _isCommunityBanned = source._isCommunityBanned
      _playerNamePendingReview = source._playerNamePendingReview
      _avatarPendingReview = source._avatarPendingReview
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularFixed64Field(value: &_storage._friendid) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._personaState) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._gamePlayedAppID) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._gameServerIp) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._gameServerPort) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._personaStateFlags) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._onlineSessionInstances) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._personaSetByUser) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._playerName) }()
        case 20: try { try decoder.decodeSingularUInt32Field(value: &_storage._queryPort) }()
        case 25: try { try decoder.decodeSingularFixed64Field(value: &_storage._steamidSource) }()
        case 31: try { try decoder.decodeSingularBytesField(value: &_storage._avatarHash) }()
        case 45: try { try decoder.decodeSingularUInt32Field(value: &_storage._lastLogoff) }()
        case 46: try { try decoder.decodeSingularUInt32Field(value: &_storage._lastLogon) }()
        case 47: try { try decoder.decodeSingularUInt32Field(value: &_storage._lastSeenOnline) }()
        case 50: try { try decoder.decodeSingularUInt32Field(value: &_storage._clanRank) }()
        case 55: try { try decoder.decodeSingularStringField(value: &_storage._gameName) }()
        case 56: try { try decoder.decodeSingularFixed64Field(value: &_storage._gameid) }()
        case 60: try { try decoder.decodeSingularBytesField(value: &_storage._gameDataBlob) }()
        case 64: try { try decoder.decodeSingularMessageField(value: &_storage._clanData) }()
        case 65: try { try decoder.decodeSingularStringField(value: &_storage._clanTag) }()
        case 71: try { try decoder.decodeRepeatedMessageField(value: &_storage._richPresence) }()
        case 72: try { try decoder.decodeSingularFixed64Field(value: &_storage._broadcastID) }()
        case 73: try { try decoder.decodeSingularFixed64Field(value: &_storage._gameLobbyID) }()
        case 74: try { try decoder.decodeSingularUInt32Field(value: &_storage._watchingBroadcastAccountid) }()
        case 75: try { try decoder.decodeSingularUInt32Field(value: &_storage._watchingBroadcastAppid) }()
        case 76: try { try decoder.decodeSingularUInt32Field(value: &_storage._watchingBroadcastViewers) }()
        case 77: try { try decoder.decodeSingularStringField(value: &_storage._watchingBroadcastTitle) }()
        case 78: try { try decoder.decodeSingularBoolField(value: &_storage._isCommunityBanned) }()
        case 79: try { try decoder.decodeSingularBoolField(value: &_storage._playerNamePendingReview) }()
        case 80: try { try decoder.decodeSingularBoolField(value: &_storage._avatarPendingReview) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._friendid {
        try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._personaState {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._gamePlayedAppID {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      }
      if let v = _storage._gameServerIp {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      }
      if let v = _storage._gameServerPort {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      }
      if let v = _storage._personaStateFlags {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
      }
      if let v = _storage._onlineSessionInstances {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
      }
      if let v = _storage._personaSetByUser {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      }
      if let v = _storage._playerName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      }
      if let v = _storage._queryPort {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 20)
      }
      if let v = _storage._steamidSource {
        try visitor.visitSingularFixed64Field(value: v, fieldNumber: 25)
      }
      if let v = _storage._avatarHash {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 31)
      }
      if let v = _storage._lastLogoff {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 45)
      }
      if let v = _storage._lastLogon {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 46)
      }
      if let v = _storage._lastSeenOnline {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 47)
      }
      if let v = _storage._clanRank {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 50)
      }
      if let v = _storage._gameName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 55)
      }
      if let v = _storage._gameid {
        try visitor.visitSingularFixed64Field(value: v, fieldNumber: 56)
      }
      if let v = _storage._gameDataBlob {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 60)
      }
      if let v = _storage._clanData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
      }
      if let v = _storage._clanTag {
        try visitor.visitSingularStringField(value: v, fieldNumber: 65)
      }
      if !_storage._richPresence.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._richPresence, fieldNumber: 71)
      }
      if let v = _storage._broadcastID {
        try visitor.visitSingularFixed64Field(value: v, fieldNumber: 72)
      }
      if let v = _storage._gameLobbyID {
        try visitor.visitSingularFixed64Field(value: v, fieldNumber: 73)
      }
      if let v = _storage._watchingBroadcastAccountid {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 74)
      }
      if let v = _storage._watchingBroadcastAppid {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 75)
      }
      if let v = _storage._watchingBroadcastViewers {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 76)
      }
      if let v = _storage._watchingBroadcastTitle {
        try visitor.visitSingularStringField(value: v, fieldNumber: 77)
      }
      if let v = _storage._isCommunityBanned {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 78)
      }
      if let v = _storage._playerNamePendingReview {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 79)
      }
      if let v = _storage._avatarPendingReview {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 80)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientPersonaState.Friend, rhs: CMsgClientPersonaState.Friend) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._friendid != rhs_storage._friendid {return false}
        if _storage._personaState != rhs_storage._personaState {return false}
        if _storage._gamePlayedAppID != rhs_storage._gamePlayedAppID {return false}
        if _storage._gameServerIp != rhs_storage._gameServerIp {return false}
        if _storage._gameServerPort != rhs_storage._gameServerPort {return false}
        if _storage._personaStateFlags != rhs_storage._personaStateFlags {return false}
        if _storage._onlineSessionInstances != rhs_storage._onlineSessionInstances {return false}
        if _storage._personaSetByUser != rhs_storage._personaSetByUser {return false}
        if _storage._playerName != rhs_storage._playerName {return false}
        if _storage._queryPort != rhs_storage._queryPort {return false}
        if _storage._steamidSource != rhs_storage._steamidSource {return false}
        if _storage._avatarHash != rhs_storage._avatarHash {return false}
        if _storage._lastLogoff != rhs_storage._lastLogoff {return false}
        if _storage._lastLogon != rhs_storage._lastLogon {return false}
        if _storage._lastSeenOnline != rhs_storage._lastSeenOnline {return false}
        if _storage._clanRank != rhs_storage._clanRank {return false}
        if _storage._gameName != rhs_storage._gameName {return false}
        if _storage._gameid != rhs_storage._gameid {return false}
        if _storage._gameDataBlob != rhs_storage._gameDataBlob {return false}
        if _storage._clanData != rhs_storage._clanData {return false}
        if _storage._clanTag != rhs_storage._clanTag {return false}
        if _storage._richPresence != rhs_storage._richPresence {return false}
        if _storage._broadcastID != rhs_storage._broadcastID {return false}
        if _storage._gameLobbyID != rhs_storage._gameLobbyID {return false}
        if _storage._watchingBroadcastAccountid != rhs_storage._watchingBroadcastAccountid {return false}
        if _storage._watchingBroadcastAppid != rhs_storage._watchingBroadcastAppid {return false}
        if _storage._watchingBroadcastViewers != rhs_storage._watchingBroadcastViewers {return false}
        if _storage._watchingBroadcastTitle != rhs_storage._watchingBroadcastTitle {return false}
        if _storage._isCommunityBanned != rhs_storage._isCommunityBanned {return false}
        if _storage._playerNamePendingReview != rhs_storage._playerNamePendingReview {return false}
        if _storage._avatarPendingReview != rhs_storage._avatarPendingReview {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientPersonaState.Friend.ClanData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientPersonaState.Friend.protoMessageName + ".ClanData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ogg_app_id"),
    2: .standard(proto: "chat_group_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._oggAppID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._chatGroupID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._oggAppID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._chatGroupID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientPersonaState.Friend.ClanData, rhs: CMsgClientPersonaState.Friend.ClanData) -> Bool {
    if lhs._oggAppID != rhs._oggAppID {return false}
    if lhs._chatGroupID != rhs._chatGroupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientPersonaState.Friend.KV: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientPersonaState.Friend.protoMessageName + ".KV"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientPersonaState.Friend.KV, rhs: CMsgClientPersonaState.Friend.KV) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientFriendProfileInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientFriendProfileInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "steamid_friend"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._steamidFriend) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._steamidFriend {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientFriendProfileInfo, rhs: CMsgClientFriendProfileInfo) -> Bool {
    if lhs._steamidFriend != rhs._steamidFriend {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientFriendProfileInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientFriendProfileInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "steamid_friend"),
    3: .standard(proto: "time_created"),
    4: .standard(proto: "real_name"),
    5: .standard(proto: "city_name"),
    6: .standard(proto: "state_name"),
    7: .standard(proto: "country_name"),
    8: .same(proto: "headline"),
    9: .same(proto: "summary"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self._steamidFriend) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._timeCreated) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._realName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._cityName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._stateName) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._countryName) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._headline) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._summary) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._steamidFriend {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 2)
    }
    if let v = self._timeCreated {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._realName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._cityName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._stateName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._countryName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }
    if let v = self._headline {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    }
    if let v = self._summary {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientFriendProfileInfoResponse, rhs: CMsgClientFriendProfileInfoResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs._steamidFriend != rhs._steamidFriend {return false}
    if lhs._timeCreated != rhs._timeCreated {return false}
    if lhs._realName != rhs._realName {return false}
    if lhs._cityName != rhs._cityName {return false}
    if lhs._stateName != rhs._stateName {return false}
    if lhs._countryName != rhs._countryName {return false}
    if lhs._headline != rhs._headline {return false}
    if lhs._summary != rhs._summary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientCreateFriendsGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientCreateFriendsGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "steamid"),
    2: .same(proto: "groupname"),
    3: .standard(proto: "steamid_friends"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._steamid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._groupname) }()
      case 3: try { try decoder.decodeRepeatedFixed64Field(value: &self.steamidFriends) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._steamid {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._groupname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if !self.steamidFriends.isEmpty {
      try visitor.visitRepeatedFixed64Field(value: self.steamidFriends, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientCreateFriendsGroup, rhs: CMsgClientCreateFriendsGroup) -> Bool {
    if lhs._steamid != rhs._steamid {return false}
    if lhs._groupname != rhs._groupname {return false}
    if lhs.steamidFriends != rhs.steamidFriends {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientCreateFriendsGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientCreateFriendsGroupResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .same(proto: "groupid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._groupid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._groupid {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientCreateFriendsGroupResponse, rhs: CMsgClientCreateFriendsGroupResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs._groupid != rhs._groupid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientDeleteFriendsGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientDeleteFriendsGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "steamid"),
    2: .same(proto: "groupid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._steamid) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._groupid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._steamid {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._groupid {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientDeleteFriendsGroup, rhs: CMsgClientDeleteFriendsGroup) -> Bool {
    if lhs._steamid != rhs._steamid {return false}
    if lhs._groupid != rhs._groupid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientDeleteFriendsGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientDeleteFriendsGroupResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._eresult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientDeleteFriendsGroupResponse, rhs: CMsgClientDeleteFriendsGroupResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientManageFriendsGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientManageFriendsGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupid"),
    2: .same(proto: "groupname"),
    3: .standard(proto: "steamid_friends_added"),
    4: .standard(proto: "steamid_friends_removed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._groupid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._groupname) }()
      case 3: try { try decoder.decodeRepeatedFixed64Field(value: &self.steamidFriendsAdded) }()
      case 4: try { try decoder.decodeRepeatedFixed64Field(value: &self.steamidFriendsRemoved) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._groupid {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._groupname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if !self.steamidFriendsAdded.isEmpty {
      try visitor.visitRepeatedFixed64Field(value: self.steamidFriendsAdded, fieldNumber: 3)
    }
    if !self.steamidFriendsRemoved.isEmpty {
      try visitor.visitRepeatedFixed64Field(value: self.steamidFriendsRemoved, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientManageFriendsGroup, rhs: CMsgClientManageFriendsGroup) -> Bool {
    if lhs._groupid != rhs._groupid {return false}
    if lhs._groupname != rhs._groupname {return false}
    if lhs.steamidFriendsAdded != rhs.steamidFriendsAdded {return false}
    if lhs.steamidFriendsRemoved != rhs.steamidFriendsRemoved {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientManageFriendsGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientManageFriendsGroupResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._eresult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientManageFriendsGroupResponse, rhs: CMsgClientManageFriendsGroupResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientAddFriendToGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientAddFriendToGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupid"),
    2: .same(proto: "steamiduser"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._groupid) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self._steamiduser) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._groupid {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._steamiduser {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientAddFriendToGroup, rhs: CMsgClientAddFriendToGroup) -> Bool {
    if lhs._groupid != rhs._groupid {return false}
    if lhs._steamiduser != rhs._steamiduser {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientAddFriendToGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientAddFriendToGroupResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._eresult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientAddFriendToGroupResponse, rhs: CMsgClientAddFriendToGroupResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRemoveFriendFromGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRemoveFriendFromGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupid"),
    2: .same(proto: "steamiduser"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._groupid) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self._steamiduser) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._groupid {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._steamiduser {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRemoveFriendFromGroup, rhs: CMsgClientRemoveFriendFromGroup) -> Bool {
    if lhs._groupid != rhs._groupid {return false}
    if lhs._steamiduser != rhs._steamiduser {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRemoveFriendFromGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRemoveFriendFromGroupResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._eresult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRemoveFriendFromGroupResponse, rhs: CMsgClientRemoveFriendFromGroupResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientGetEmoticonList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientGetEmoticonList"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientGetEmoticonList, rhs: CMsgClientGetEmoticonList) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientEmoticonList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientEmoticonList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "emoticons"),
    2: .same(proto: "stickers"),
    3: .same(proto: "effects"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.emoticons) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.stickers) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.effects) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.emoticons.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.emoticons, fieldNumber: 1)
    }
    if !self.stickers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stickers, fieldNumber: 2)
    }
    if !self.effects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.effects, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientEmoticonList, rhs: CMsgClientEmoticonList) -> Bool {
    if lhs.emoticons != rhs.emoticons {return false}
    if lhs.stickers != rhs.stickers {return false}
    if lhs.effects != rhs.effects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientEmoticonList.Emoticon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientEmoticonList.protoMessageName + ".Emoticon"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "count"),
    3: .standard(proto: "time_last_used"),
    4: .standard(proto: "use_count"),
    5: .standard(proto: "time_received"),
    6: .same(proto: "appid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._count) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._timeLastUsed) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._useCount) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._timeReceived) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._appid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._count {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._timeLastUsed {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._useCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._timeReceived {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._appid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientEmoticonList.Emoticon, rhs: CMsgClientEmoticonList.Emoticon) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._count != rhs._count {return false}
    if lhs._timeLastUsed != rhs._timeLastUsed {return false}
    if lhs._useCount != rhs._useCount {return false}
    if lhs._timeReceived != rhs._timeReceived {return false}
    if lhs._appid != rhs._appid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientEmoticonList.Sticker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientEmoticonList.protoMessageName + ".Sticker"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "count"),
    3: .standard(proto: "time_received"),
    4: .same(proto: "appid"),
    5: .standard(proto: "time_last_used"),
    6: .standard(proto: "use_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._count) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._timeReceived) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._appid) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._timeLastUsed) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._useCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._count {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._timeReceived {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._appid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._timeLastUsed {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._useCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientEmoticonList.Sticker, rhs: CMsgClientEmoticonList.Sticker) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._count != rhs._count {return false}
    if lhs._timeReceived != rhs._timeReceived {return false}
    if lhs._appid != rhs._appid {return false}
    if lhs._timeLastUsed != rhs._timeLastUsed {return false}
    if lhs._useCount != rhs._useCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientEmoticonList.Effect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientEmoticonList.protoMessageName + ".Effect"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "count"),
    3: .standard(proto: "time_received"),
    4: .standard(proto: "infinite_use"),
    5: .same(proto: "appid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._count) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._timeReceived) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._infiniteUse) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._appid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._count {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._timeReceived {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._infiniteUse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if let v = self._appid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientEmoticonList.Effect, rhs: CMsgClientEmoticonList.Effect) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._count != rhs._count {return false}
    if lhs._timeReceived != rhs._timeReceived {return false}
    if lhs._infiniteUse != rhs._infiniteUse {return false}
    if lhs._appid != rhs._appid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
