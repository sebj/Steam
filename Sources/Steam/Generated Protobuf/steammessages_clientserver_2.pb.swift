// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: steammessages_clientserver_2.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct CMsgClientUCMAddScreenshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appid: UInt32 {
    get {return _appid ?? 0}
    set {_appid = newValue}
  }
  /// Returns true if `appid` has been explicitly set.
  var hasAppid: Bool {return self._appid != nil}
  /// Clears the value of `appid`. Subsequent reads from it will return its default value.
  mutating func clearAppid() {self._appid = nil}

  var filename: String {
    get {return _filename ?? String()}
    set {_filename = newValue}
  }
  /// Returns true if `filename` has been explicitly set.
  var hasFilename: Bool {return self._filename != nil}
  /// Clears the value of `filename`. Subsequent reads from it will return its default value.
  mutating func clearFilename() {self._filename = nil}

  var thumbname: String {
    get {return _thumbname ?? String()}
    set {_thumbname = newValue}
  }
  /// Returns true if `thumbname` has been explicitly set.
  var hasThumbname: Bool {return self._thumbname != nil}
  /// Clears the value of `thumbname`. Subsequent reads from it will return its default value.
  mutating func clearThumbname() {self._thumbname = nil}

  var vrFilename: String {
    get {return _vrFilename ?? String()}
    set {_vrFilename = newValue}
  }
  /// Returns true if `vrFilename` has been explicitly set.
  var hasVrFilename: Bool {return self._vrFilename != nil}
  /// Clears the value of `vrFilename`. Subsequent reads from it will return its default value.
  mutating func clearVrFilename() {self._vrFilename = nil}

  var rtime32Created: UInt32 {
    get {return _rtime32Created ?? 0}
    set {_rtime32Created = newValue}
  }
  /// Returns true if `rtime32Created` has been explicitly set.
  var hasRtime32Created: Bool {return self._rtime32Created != nil}
  /// Clears the value of `rtime32Created`. Subsequent reads from it will return its default value.
  mutating func clearRtime32Created() {self._rtime32Created = nil}

  var width: UInt32 {
    get {return _width ?? 0}
    set {_width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  var hasWidth: Bool {return self._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  mutating func clearWidth() {self._width = nil}

  var height: UInt32 {
    get {return _height ?? 0}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {self._height = nil}

  var permissions: UInt32 {
    get {return _permissions ?? 0}
    set {_permissions = newValue}
  }
  /// Returns true if `permissions` has been explicitly set.
  var hasPermissions: Bool {return self._permissions != nil}
  /// Clears the value of `permissions`. Subsequent reads from it will return its default value.
  mutating func clearPermissions() {self._permissions = nil}

  var caption: String {
    get {return _caption ?? String()}
    set {_caption = newValue}
  }
  /// Returns true if `caption` has been explicitly set.
  var hasCaption: Bool {return self._caption != nil}
  /// Clears the value of `caption`. Subsequent reads from it will return its default value.
  mutating func clearCaption() {self._caption = nil}

  var shortcutName: String {
    get {return _shortcutName ?? String()}
    set {_shortcutName = newValue}
  }
  /// Returns true if `shortcutName` has been explicitly set.
  var hasShortcutName: Bool {return self._shortcutName != nil}
  /// Clears the value of `shortcutName`. Subsequent reads from it will return its default value.
  mutating func clearShortcutName() {self._shortcutName = nil}

  var tag: [CMsgClientUCMAddScreenshot.Tag] = []

  var taggedSteamid: [UInt64] = []

  var spoilerTag: Bool {
    get {return _spoilerTag ?? false}
    set {_spoilerTag = newValue}
  }
  /// Returns true if `spoilerTag` has been explicitly set.
  var hasSpoilerTag: Bool {return self._spoilerTag != nil}
  /// Clears the value of `spoilerTag`. Subsequent reads from it will return its default value.
  mutating func clearSpoilerTag() {self._spoilerTag = nil}

  var taggedPublishedfileid: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Tag {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var tagName: String {
      get {return _tagName ?? String()}
      set {_tagName = newValue}
    }
    /// Returns true if `tagName` has been explicitly set.
    var hasTagName: Bool {return self._tagName != nil}
    /// Clears the value of `tagName`. Subsequent reads from it will return its default value.
    mutating func clearTagName() {self._tagName = nil}

    var tagValue: String {
      get {return _tagValue ?? String()}
      set {_tagValue = newValue}
    }
    /// Returns true if `tagValue` has been explicitly set.
    var hasTagValue: Bool {return self._tagValue != nil}
    /// Clears the value of `tagValue`. Subsequent reads from it will return its default value.
    mutating func clearTagValue() {self._tagValue = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _tagName: String? = nil
    fileprivate var _tagValue: String? = nil
  }

  init() {}

  fileprivate var _appid: UInt32? = nil
  fileprivate var _filename: String? = nil
  fileprivate var _thumbname: String? = nil
  fileprivate var _vrFilename: String? = nil
  fileprivate var _rtime32Created: UInt32? = nil
  fileprivate var _width: UInt32? = nil
  fileprivate var _height: UInt32? = nil
  fileprivate var _permissions: UInt32? = nil
  fileprivate var _caption: String? = nil
  fileprivate var _shortcutName: String? = nil
  fileprivate var _spoilerTag: Bool? = nil
}

struct CMsgClientUCMAddScreenshotResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var screenshotid: UInt64 {
    get {return _screenshotid ?? 18446744073709551615}
    set {_screenshotid = newValue}
  }
  /// Returns true if `screenshotid` has been explicitly set.
  var hasScreenshotid: Bool {return self._screenshotid != nil}
  /// Clears the value of `screenshotid`. Subsequent reads from it will return its default value.
  mutating func clearScreenshotid() {self._screenshotid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: Int32? = nil
  fileprivate var _screenshotid: UInt64? = nil
}

struct CMsgClientUCMDeleteScreenshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var screenshotid: UInt64 {
    get {return _screenshotid ?? 18446744073709551615}
    set {_screenshotid = newValue}
  }
  /// Returns true if `screenshotid` has been explicitly set.
  var hasScreenshotid: Bool {return self._screenshotid != nil}
  /// Clears the value of `screenshotid`. Subsequent reads from it will return its default value.
  mutating func clearScreenshotid() {self._screenshotid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _screenshotid: UInt64? = nil
}

struct CMsgClientUCMDeleteScreenshotResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: Int32? = nil
}

struct CMsgClientUCMPublishFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: UInt32 {
    get {return _appID ?? 0}
    set {_appID = newValue}
  }
  /// Returns true if `appID` has been explicitly set.
  var hasAppID: Bool {return self._appID != nil}
  /// Clears the value of `appID`. Subsequent reads from it will return its default value.
  mutating func clearAppID() {self._appID = nil}

  var fileName: String {
    get {return _fileName ?? String()}
    set {_fileName = newValue}
  }
  /// Returns true if `fileName` has been explicitly set.
  var hasFileName: Bool {return self._fileName != nil}
  /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
  mutating func clearFileName() {self._fileName = nil}

  var previewFileName: String {
    get {return _previewFileName ?? String()}
    set {_previewFileName = newValue}
  }
  /// Returns true if `previewFileName` has been explicitly set.
  var hasPreviewFileName: Bool {return self._previewFileName != nil}
  /// Clears the value of `previewFileName`. Subsequent reads from it will return its default value.
  mutating func clearPreviewFileName() {self._previewFileName = nil}

  var consumerAppID: UInt32 {
    get {return _consumerAppID ?? 0}
    set {_consumerAppID = newValue}
  }
  /// Returns true if `consumerAppID` has been explicitly set.
  var hasConsumerAppID: Bool {return self._consumerAppID != nil}
  /// Clears the value of `consumerAppID`. Subsequent reads from it will return its default value.
  mutating func clearConsumerAppID() {self._consumerAppID = nil}

  var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {self._title = nil}

  var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  var tags: [String] = []

  var workshopFile: Bool {
    get {return _workshopFile ?? false}
    set {_workshopFile = newValue}
  }
  /// Returns true if `workshopFile` has been explicitly set.
  var hasWorkshopFile: Bool {return self._workshopFile != nil}
  /// Clears the value of `workshopFile`. Subsequent reads from it will return its default value.
  mutating func clearWorkshopFile() {self._workshopFile = nil}

  var visibility: Int32 {
    get {return _visibility ?? 0}
    set {_visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  var hasVisibility: Bool {return self._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  mutating func clearVisibility() {self._visibility = nil}

  var fileType: UInt32 {
    get {return _fileType ?? 0}
    set {_fileType = newValue}
  }
  /// Returns true if `fileType` has been explicitly set.
  var hasFileType: Bool {return self._fileType != nil}
  /// Clears the value of `fileType`. Subsequent reads from it will return its default value.
  mutating func clearFileType() {self._fileType = nil}

  var url: String {
    get {return _url ?? String()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {self._url = nil}

  var videoProvider: UInt32 {
    get {return _videoProvider ?? 0}
    set {_videoProvider = newValue}
  }
  /// Returns true if `videoProvider` has been explicitly set.
  var hasVideoProvider: Bool {return self._videoProvider != nil}
  /// Clears the value of `videoProvider`. Subsequent reads from it will return its default value.
  mutating func clearVideoProvider() {self._videoProvider = nil}

  var videoAccountName: String {
    get {return _videoAccountName ?? String()}
    set {_videoAccountName = newValue}
  }
  /// Returns true if `videoAccountName` has been explicitly set.
  var hasVideoAccountName: Bool {return self._videoAccountName != nil}
  /// Clears the value of `videoAccountName`. Subsequent reads from it will return its default value.
  mutating func clearVideoAccountName() {self._videoAccountName = nil}

  var videoIdentifier: String {
    get {return _videoIdentifier ?? String()}
    set {_videoIdentifier = newValue}
  }
  /// Returns true if `videoIdentifier` has been explicitly set.
  var hasVideoIdentifier: Bool {return self._videoIdentifier != nil}
  /// Clears the value of `videoIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearVideoIdentifier() {self._videoIdentifier = nil}

  var inProgress: Bool {
    get {return _inProgress ?? false}
    set {_inProgress = newValue}
  }
  /// Returns true if `inProgress` has been explicitly set.
  var hasInProgress: Bool {return self._inProgress != nil}
  /// Clears the value of `inProgress`. Subsequent reads from it will return its default value.
  mutating func clearInProgress() {self._inProgress = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _appID: UInt32? = nil
  fileprivate var _fileName: String? = nil
  fileprivate var _previewFileName: String? = nil
  fileprivate var _consumerAppID: UInt32? = nil
  fileprivate var _title: String? = nil
  fileprivate var _description_p: String? = nil
  fileprivate var _workshopFile: Bool? = nil
  fileprivate var _visibility: Int32? = nil
  fileprivate var _fileType: UInt32? = nil
  fileprivate var _url: String? = nil
  fileprivate var _videoProvider: UInt32? = nil
  fileprivate var _videoAccountName: String? = nil
  fileprivate var _videoIdentifier: String? = nil
  fileprivate var _inProgress: Bool? = nil
}

struct CMsgClientUCMPublishFileResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var publishedFileID: UInt64 {
    get {return _publishedFileID ?? 18446744073709551615}
    set {_publishedFileID = newValue}
  }
  /// Returns true if `publishedFileID` has been explicitly set.
  var hasPublishedFileID: Bool {return self._publishedFileID != nil}
  /// Clears the value of `publishedFileID`. Subsequent reads from it will return its default value.
  mutating func clearPublishedFileID() {self._publishedFileID = nil}

  var needsWorkshopLegalAgreementAcceptance: Bool {
    get {return _needsWorkshopLegalAgreementAcceptance ?? false}
    set {_needsWorkshopLegalAgreementAcceptance = newValue}
  }
  /// Returns true if `needsWorkshopLegalAgreementAcceptance` has been explicitly set.
  var hasNeedsWorkshopLegalAgreementAcceptance: Bool {return self._needsWorkshopLegalAgreementAcceptance != nil}
  /// Clears the value of `needsWorkshopLegalAgreementAcceptance`. Subsequent reads from it will return its default value.
  mutating func clearNeedsWorkshopLegalAgreementAcceptance() {self._needsWorkshopLegalAgreementAcceptance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: Int32? = nil
  fileprivate var _publishedFileID: UInt64? = nil
  fileprivate var _needsWorkshopLegalAgreementAcceptance: Bool? = nil
}

struct CMsgClientUCMUpdatePublishedFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: UInt32 {
    get {return _storage._appID ?? 0}
    set {_uniqueStorage()._appID = newValue}
  }
  /// Returns true if `appID` has been explicitly set.
  var hasAppID: Bool {return _storage._appID != nil}
  /// Clears the value of `appID`. Subsequent reads from it will return its default value.
  mutating func clearAppID() {_uniqueStorage()._appID = nil}

  var publishedFileID: UInt64 {
    get {return _storage._publishedFileID ?? 0}
    set {_uniqueStorage()._publishedFileID = newValue}
  }
  /// Returns true if `publishedFileID` has been explicitly set.
  var hasPublishedFileID: Bool {return _storage._publishedFileID != nil}
  /// Clears the value of `publishedFileID`. Subsequent reads from it will return its default value.
  mutating func clearPublishedFileID() {_uniqueStorage()._publishedFileID = nil}

  var fileName: String {
    get {return _storage._fileName ?? String()}
    set {_uniqueStorage()._fileName = newValue}
  }
  /// Returns true if `fileName` has been explicitly set.
  var hasFileName: Bool {return _storage._fileName != nil}
  /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
  mutating func clearFileName() {_uniqueStorage()._fileName = nil}

  var previewFileName: String {
    get {return _storage._previewFileName ?? String()}
    set {_uniqueStorage()._previewFileName = newValue}
  }
  /// Returns true if `previewFileName` has been explicitly set.
  var hasPreviewFileName: Bool {return _storage._previewFileName != nil}
  /// Clears the value of `previewFileName`. Subsequent reads from it will return its default value.
  mutating func clearPreviewFileName() {_uniqueStorage()._previewFileName = nil}

  var title: String {
    get {return _storage._title ?? String()}
    set {_uniqueStorage()._title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return _storage._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {_uniqueStorage()._title = nil}

  var description_p: String {
    get {return _storage._description_p ?? String()}
    set {_uniqueStorage()._description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return _storage._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {_uniqueStorage()._description_p = nil}

  var tags: [String] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  var visibility: Int32 {
    get {return _storage._visibility ?? 0}
    set {_uniqueStorage()._visibility = newValue}
  }
  /// Returns true if `visibility` has been explicitly set.
  var hasVisibility: Bool {return _storage._visibility != nil}
  /// Clears the value of `visibility`. Subsequent reads from it will return its default value.
  mutating func clearVisibility() {_uniqueStorage()._visibility = nil}

  var updateFile: Bool {
    get {return _storage._updateFile ?? false}
    set {_uniqueStorage()._updateFile = newValue}
  }
  /// Returns true if `updateFile` has been explicitly set.
  var hasUpdateFile: Bool {return _storage._updateFile != nil}
  /// Clears the value of `updateFile`. Subsequent reads from it will return its default value.
  mutating func clearUpdateFile() {_uniqueStorage()._updateFile = nil}

  var updatePreviewFile: Bool {
    get {return _storage._updatePreviewFile ?? false}
    set {_uniqueStorage()._updatePreviewFile = newValue}
  }
  /// Returns true if `updatePreviewFile` has been explicitly set.
  var hasUpdatePreviewFile: Bool {return _storage._updatePreviewFile != nil}
  /// Clears the value of `updatePreviewFile`. Subsequent reads from it will return its default value.
  mutating func clearUpdatePreviewFile() {_uniqueStorage()._updatePreviewFile = nil}

  var updateTitle: Bool {
    get {return _storage._updateTitle ?? false}
    set {_uniqueStorage()._updateTitle = newValue}
  }
  /// Returns true if `updateTitle` has been explicitly set.
  var hasUpdateTitle: Bool {return _storage._updateTitle != nil}
  /// Clears the value of `updateTitle`. Subsequent reads from it will return its default value.
  mutating func clearUpdateTitle() {_uniqueStorage()._updateTitle = nil}

  var updateDescription: Bool {
    get {return _storage._updateDescription ?? false}
    set {_uniqueStorage()._updateDescription = newValue}
  }
  /// Returns true if `updateDescription` has been explicitly set.
  var hasUpdateDescription: Bool {return _storage._updateDescription != nil}
  /// Clears the value of `updateDescription`. Subsequent reads from it will return its default value.
  mutating func clearUpdateDescription() {_uniqueStorage()._updateDescription = nil}

  var updateTags: Bool {
    get {return _storage._updateTags ?? false}
    set {_uniqueStorage()._updateTags = newValue}
  }
  /// Returns true if `updateTags` has been explicitly set.
  var hasUpdateTags: Bool {return _storage._updateTags != nil}
  /// Clears the value of `updateTags`. Subsequent reads from it will return its default value.
  mutating func clearUpdateTags() {_uniqueStorage()._updateTags = nil}

  var updateVisibility: Bool {
    get {return _storage._updateVisibility ?? false}
    set {_uniqueStorage()._updateVisibility = newValue}
  }
  /// Returns true if `updateVisibility` has been explicitly set.
  var hasUpdateVisibility: Bool {return _storage._updateVisibility != nil}
  /// Clears the value of `updateVisibility`. Subsequent reads from it will return its default value.
  mutating func clearUpdateVisibility() {_uniqueStorage()._updateVisibility = nil}

  var changeDescription: String {
    get {return _storage._changeDescription ?? String()}
    set {_uniqueStorage()._changeDescription = newValue}
  }
  /// Returns true if `changeDescription` has been explicitly set.
  var hasChangeDescription: Bool {return _storage._changeDescription != nil}
  /// Clears the value of `changeDescription`. Subsequent reads from it will return its default value.
  mutating func clearChangeDescription() {_uniqueStorage()._changeDescription = nil}

  var updateURL: Bool {
    get {return _storage._updateURL ?? false}
    set {_uniqueStorage()._updateURL = newValue}
  }
  /// Returns true if `updateURL` has been explicitly set.
  var hasUpdateURL: Bool {return _storage._updateURL != nil}
  /// Clears the value of `updateURL`. Subsequent reads from it will return its default value.
  mutating func clearUpdateURL() {_uniqueStorage()._updateURL = nil}

  var url: String {
    get {return _storage._url ?? String()}
    set {_uniqueStorage()._url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return _storage._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {_uniqueStorage()._url = nil}

  var updateContentManifest: Bool {
    get {return _storage._updateContentManifest ?? false}
    set {_uniqueStorage()._updateContentManifest = newValue}
  }
  /// Returns true if `updateContentManifest` has been explicitly set.
  var hasUpdateContentManifest: Bool {return _storage._updateContentManifest != nil}
  /// Clears the value of `updateContentManifest`. Subsequent reads from it will return its default value.
  mutating func clearUpdateContentManifest() {_uniqueStorage()._updateContentManifest = nil}

  var contentManifest: UInt64 {
    get {return _storage._contentManifest ?? 0}
    set {_uniqueStorage()._contentManifest = newValue}
  }
  /// Returns true if `contentManifest` has been explicitly set.
  var hasContentManifest: Bool {return _storage._contentManifest != nil}
  /// Clears the value of `contentManifest`. Subsequent reads from it will return its default value.
  mutating func clearContentManifest() {_uniqueStorage()._contentManifest = nil}

  var metadata: String {
    get {return _storage._metadata ?? String()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  var updateMetadata: Bool {
    get {return _storage._updateMetadata ?? false}
    set {_uniqueStorage()._updateMetadata = newValue}
  }
  /// Returns true if `updateMetadata` has been explicitly set.
  var hasUpdateMetadata: Bool {return _storage._updateMetadata != nil}
  /// Clears the value of `updateMetadata`. Subsequent reads from it will return its default value.
  mutating func clearUpdateMetadata() {_uniqueStorage()._updateMetadata = nil}

  var language: Int32 {
    get {return _storage._language ?? 0}
    set {_uniqueStorage()._language = newValue}
  }
  /// Returns true if `language` has been explicitly set.
  var hasLanguage: Bool {return _storage._language != nil}
  /// Clears the value of `language`. Subsequent reads from it will return its default value.
  mutating func clearLanguage() {_uniqueStorage()._language = nil}

  var removedKvtags: [String] {
    get {return _storage._removedKvtags}
    set {_uniqueStorage()._removedKvtags = newValue}
  }

  var kvtags: [CMsgClientUCMUpdatePublishedFile.KeyValueTag] {
    get {return _storage._kvtags}
    set {_uniqueStorage()._kvtags = newValue}
  }

  var previews: [CMsgClientUCMUpdatePublishedFile.AdditionalPreview] {
    get {return _storage._previews}
    set {_uniqueStorage()._previews = newValue}
  }

  var previewsToRemove: [Int32] {
    get {return _storage._previewsToRemove}
    set {_uniqueStorage()._previewsToRemove = newValue}
  }

  var clearInProgress_p: Bool {
    get {return _storage._clearInProgress_p ?? false}
    set {_uniqueStorage()._clearInProgress_p = newValue}
  }
  /// Returns true if `clearInProgress_p` has been explicitly set.
  var hasClearInProgress_p: Bool {return _storage._clearInProgress_p != nil}
  /// Clears the value of `clearInProgress_p`. Subsequent reads from it will return its default value.
  mutating func clearClearInProgress_p() {_uniqueStorage()._clearInProgress_p = nil}

  var removeAllKvtags: Bool {
    get {return _storage._removeAllKvtags ?? false}
    set {_uniqueStorage()._removeAllKvtags = newValue}
  }
  /// Returns true if `removeAllKvtags` has been explicitly set.
  var hasRemoveAllKvtags: Bool {return _storage._removeAllKvtags != nil}
  /// Clears the value of `removeAllKvtags`. Subsequent reads from it will return its default value.
  mutating func clearRemoveAllKvtags() {_uniqueStorage()._removeAllKvtags = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct KeyValueTag {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var key: String {
      get {return _key ?? String()}
      set {_key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    var hasKey: Bool {return self._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    mutating func clearKey() {self._key = nil}

    var value: String {
      get {return _value ?? String()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    mutating func clearValue() {self._value = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _key: String? = nil
    fileprivate var _value: String? = nil
  }

  struct AdditionalPreview {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var originalFileName: String {
      get {return _originalFileName ?? String()}
      set {_originalFileName = newValue}
    }
    /// Returns true if `originalFileName` has been explicitly set.
    var hasOriginalFileName: Bool {return self._originalFileName != nil}
    /// Clears the value of `originalFileName`. Subsequent reads from it will return its default value.
    mutating func clearOriginalFileName() {self._originalFileName = nil}

    var internalFileName: String {
      get {return _internalFileName ?? String()}
      set {_internalFileName = newValue}
    }
    /// Returns true if `internalFileName` has been explicitly set.
    var hasInternalFileName: Bool {return self._internalFileName != nil}
    /// Clears the value of `internalFileName`. Subsequent reads from it will return its default value.
    mutating func clearInternalFileName() {self._internalFileName = nil}

    var videoid: String {
      get {return _videoid ?? String()}
      set {_videoid = newValue}
    }
    /// Returns true if `videoid` has been explicitly set.
    var hasVideoid: Bool {return self._videoid != nil}
    /// Clears the value of `videoid`. Subsequent reads from it will return its default value.
    mutating func clearVideoid() {self._videoid = nil}

    var previewType: UInt32 {
      get {return _previewType ?? 0}
      set {_previewType = newValue}
    }
    /// Returns true if `previewType` has been explicitly set.
    var hasPreviewType: Bool {return self._previewType != nil}
    /// Clears the value of `previewType`. Subsequent reads from it will return its default value.
    mutating func clearPreviewType() {self._previewType = nil}

    var updateIndex: Int32 {
      get {return _updateIndex ?? -1}
      set {_updateIndex = newValue}
    }
    /// Returns true if `updateIndex` has been explicitly set.
    var hasUpdateIndex: Bool {return self._updateIndex != nil}
    /// Clears the value of `updateIndex`. Subsequent reads from it will return its default value.
    mutating func clearUpdateIndex() {self._updateIndex = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _originalFileName: String? = nil
    fileprivate var _internalFileName: String? = nil
    fileprivate var _videoid: String? = nil
    fileprivate var _previewType: UInt32? = nil
    fileprivate var _updateIndex: Int32? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CMsgClientUCMUpdatePublishedFileResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var needsWorkshopLegalAgreementAcceptance: Bool {
    get {return _needsWorkshopLegalAgreementAcceptance ?? false}
    set {_needsWorkshopLegalAgreementAcceptance = newValue}
  }
  /// Returns true if `needsWorkshopLegalAgreementAcceptance` has been explicitly set.
  var hasNeedsWorkshopLegalAgreementAcceptance: Bool {return self._needsWorkshopLegalAgreementAcceptance != nil}
  /// Clears the value of `needsWorkshopLegalAgreementAcceptance`. Subsequent reads from it will return its default value.
  mutating func clearNeedsWorkshopLegalAgreementAcceptance() {self._needsWorkshopLegalAgreementAcceptance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: Int32? = nil
  fileprivate var _needsWorkshopLegalAgreementAcceptance: Bool? = nil
}

struct CMsgClientUCMDeletePublishedFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publishedFileID: UInt64 {
    get {return _publishedFileID ?? 0}
    set {_publishedFileID = newValue}
  }
  /// Returns true if `publishedFileID` has been explicitly set.
  var hasPublishedFileID: Bool {return self._publishedFileID != nil}
  /// Clears the value of `publishedFileID`. Subsequent reads from it will return its default value.
  mutating func clearPublishedFileID() {self._publishedFileID = nil}

  var appID: UInt32 {
    get {return _appID ?? 0}
    set {_appID = newValue}
  }
  /// Returns true if `appID` has been explicitly set.
  var hasAppID: Bool {return self._appID != nil}
  /// Clears the value of `appID`. Subsequent reads from it will return its default value.
  mutating func clearAppID() {self._appID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publishedFileID: UInt64? = nil
  fileprivate var _appID: UInt32? = nil
}

struct CMsgClientUCMDeletePublishedFileResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: Int32? = nil
}

struct CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: UInt32 {
    get {return _appID ?? 0}
    set {_appID = newValue}
  }
  /// Returns true if `appID` has been explicitly set.
  var hasAppID: Bool {return self._appID != nil}
  /// Clears the value of `appID`. Subsequent reads from it will return its default value.
  mutating func clearAppID() {self._appID = nil}

  var startIndex: UInt32 {
    get {return _startIndex ?? 0}
    set {_startIndex = newValue}
  }
  /// Returns true if `startIndex` has been explicitly set.
  var hasStartIndex: Bool {return self._startIndex != nil}
  /// Clears the value of `startIndex`. Subsequent reads from it will return its default value.
  mutating func clearStartIndex() {self._startIndex = nil}

  var startTime: UInt32 {
    get {return _startTime ?? 0}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {self._startTime = nil}

  var desiredRevision: UInt32 {
    get {return _desiredRevision ?? 0}
    set {_desiredRevision = newValue}
  }
  /// Returns true if `desiredRevision` has been explicitly set.
  var hasDesiredRevision: Bool {return self._desiredRevision != nil}
  /// Clears the value of `desiredRevision`. Subsequent reads from it will return its default value.
  mutating func clearDesiredRevision() {self._desiredRevision = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _appID: UInt32? = nil
  fileprivate var _startIndex: UInt32? = nil
  fileprivate var _startTime: UInt32? = nil
  fileprivate var _desiredRevision: UInt32? = nil
}

struct CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var subscribedFiles: [CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId] = []

  var totalResults: UInt32 {
    get {return _totalResults ?? 0}
    set {_totalResults = newValue}
  }
  /// Returns true if `totalResults` has been explicitly set.
  var hasTotalResults: Bool {return self._totalResults != nil}
  /// Clears the value of `totalResults`. Subsequent reads from it will return its default value.
  mutating func clearTotalResults() {self._totalResults = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PublishedFileId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var publishedFileID: UInt64 {
      get {return _publishedFileID ?? 0}
      set {_publishedFileID = newValue}
    }
    /// Returns true if `publishedFileID` has been explicitly set.
    var hasPublishedFileID: Bool {return self._publishedFileID != nil}
    /// Clears the value of `publishedFileID`. Subsequent reads from it will return its default value.
    mutating func clearPublishedFileID() {self._publishedFileID = nil}

    var rtime32Subscribed: UInt32 {
      get {return _rtime32Subscribed ?? 0}
      set {_rtime32Subscribed = newValue}
    }
    /// Returns true if `rtime32Subscribed` has been explicitly set.
    var hasRtime32Subscribed: Bool {return self._rtime32Subscribed != nil}
    /// Clears the value of `rtime32Subscribed`. Subsequent reads from it will return its default value.
    mutating func clearRtime32Subscribed() {self._rtime32Subscribed = nil}

    var appid: UInt32 {
      get {return _appid ?? 0}
      set {_appid = newValue}
    }
    /// Returns true if `appid` has been explicitly set.
    var hasAppid: Bool {return self._appid != nil}
    /// Clears the value of `appid`. Subsequent reads from it will return its default value.
    mutating func clearAppid() {self._appid = nil}

    var fileHcontent: UInt64 {
      get {return _fileHcontent ?? 0}
      set {_fileHcontent = newValue}
    }
    /// Returns true if `fileHcontent` has been explicitly set.
    var hasFileHcontent: Bool {return self._fileHcontent != nil}
    /// Clears the value of `fileHcontent`. Subsequent reads from it will return its default value.
    mutating func clearFileHcontent() {self._fileHcontent = nil}

    var fileSize: UInt32 {
      get {return _fileSize ?? 0}
      set {_fileSize = newValue}
    }
    /// Returns true if `fileSize` has been explicitly set.
    var hasFileSize: Bool {return self._fileSize != nil}
    /// Clears the value of `fileSize`. Subsequent reads from it will return its default value.
    mutating func clearFileSize() {self._fileSize = nil}

    var rtime32LastUpdated: UInt32 {
      get {return _rtime32LastUpdated ?? 0}
      set {_rtime32LastUpdated = newValue}
    }
    /// Returns true if `rtime32LastUpdated` has been explicitly set.
    var hasRtime32LastUpdated: Bool {return self._rtime32LastUpdated != nil}
    /// Clears the value of `rtime32LastUpdated`. Subsequent reads from it will return its default value.
    mutating func clearRtime32LastUpdated() {self._rtime32LastUpdated = nil}

    var isDepotContent: Bool {
      get {return _isDepotContent ?? false}
      set {_isDepotContent = newValue}
    }
    /// Returns true if `isDepotContent` has been explicitly set.
    var hasIsDepotContent: Bool {return self._isDepotContent != nil}
    /// Clears the value of `isDepotContent`. Subsequent reads from it will return its default value.
    mutating func clearIsDepotContent() {self._isDepotContent = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _publishedFileID: UInt64? = nil
    fileprivate var _rtime32Subscribed: UInt32? = nil
    fileprivate var _appid: UInt32? = nil
    fileprivate var _fileHcontent: UInt64? = nil
    fileprivate var _fileSize: UInt32? = nil
    fileprivate var _rtime32LastUpdated: UInt32? = nil
    fileprivate var _isDepotContent: Bool? = nil
  }

  init() {}

  fileprivate var _eresult: Int32? = nil
  fileprivate var _totalResults: UInt32? = nil
}

struct CMsgClientUCMPublishedFileUpdated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publishedFileID: UInt64 {
    get {return _publishedFileID ?? 0}
    set {_publishedFileID = newValue}
  }
  /// Returns true if `publishedFileID` has been explicitly set.
  var hasPublishedFileID: Bool {return self._publishedFileID != nil}
  /// Clears the value of `publishedFileID`. Subsequent reads from it will return its default value.
  mutating func clearPublishedFileID() {self._publishedFileID = nil}

  var appID: UInt32 {
    get {return _appID ?? 0}
    set {_appID = newValue}
  }
  /// Returns true if `appID` has been explicitly set.
  var hasAppID: Bool {return self._appID != nil}
  /// Clears the value of `appID`. Subsequent reads from it will return its default value.
  mutating func clearAppID() {self._appID = nil}

  var timeUpdated: UInt32 {
    get {return _timeUpdated ?? 0}
    set {_timeUpdated = newValue}
  }
  /// Returns true if `timeUpdated` has been explicitly set.
  var hasTimeUpdated: Bool {return self._timeUpdated != nil}
  /// Clears the value of `timeUpdated`. Subsequent reads from it will return its default value.
  mutating func clearTimeUpdated() {self._timeUpdated = nil}

  var hcontent: UInt64 {
    get {return _hcontent ?? 0}
    set {_hcontent = newValue}
  }
  /// Returns true if `hcontent` has been explicitly set.
  var hasHcontent: Bool {return self._hcontent != nil}
  /// Clears the value of `hcontent`. Subsequent reads from it will return its default value.
  mutating func clearHcontent() {self._hcontent = nil}

  var fileSize: UInt32 {
    get {return _fileSize ?? 0}
    set {_fileSize = newValue}
  }
  /// Returns true if `fileSize` has been explicitly set.
  var hasFileSize: Bool {return self._fileSize != nil}
  /// Clears the value of `fileSize`. Subsequent reads from it will return its default value.
  mutating func clearFileSize() {self._fileSize = nil}

  var isDepotContent: Bool {
    get {return _isDepotContent ?? false}
    set {_isDepotContent = newValue}
  }
  /// Returns true if `isDepotContent` has been explicitly set.
  var hasIsDepotContent: Bool {return self._isDepotContent != nil}
  /// Clears the value of `isDepotContent`. Subsequent reads from it will return its default value.
  mutating func clearIsDepotContent() {self._isDepotContent = nil}

  var revision: UInt32 {
    get {return _revision ?? 0}
    set {_revision = newValue}
  }
  /// Returns true if `revision` has been explicitly set.
  var hasRevision: Bool {return self._revision != nil}
  /// Clears the value of `revision`. Subsequent reads from it will return its default value.
  mutating func clearRevision() {self._revision = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publishedFileID: UInt64? = nil
  fileprivate var _appID: UInt32? = nil
  fileprivate var _timeUpdated: UInt32? = nil
  fileprivate var _hcontent: UInt64? = nil
  fileprivate var _fileSize: UInt32? = nil
  fileprivate var _isDepotContent: Bool? = nil
  fileprivate var _revision: UInt32? = nil
}

struct CMsgClientWorkshopItemChangesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: UInt32 {
    get {return _appID ?? 0}
    set {_appID = newValue}
  }
  /// Returns true if `appID` has been explicitly set.
  var hasAppID: Bool {return self._appID != nil}
  /// Clears the value of `appID`. Subsequent reads from it will return its default value.
  mutating func clearAppID() {self._appID = nil}

  var lastTimeUpdated: UInt32 {
    get {return _lastTimeUpdated ?? 0}
    set {_lastTimeUpdated = newValue}
  }
  /// Returns true if `lastTimeUpdated` has been explicitly set.
  var hasLastTimeUpdated: Bool {return self._lastTimeUpdated != nil}
  /// Clears the value of `lastTimeUpdated`. Subsequent reads from it will return its default value.
  mutating func clearLastTimeUpdated() {self._lastTimeUpdated = nil}

  var numItemsNeeded: UInt32 {
    get {return _numItemsNeeded ?? 0}
    set {_numItemsNeeded = newValue}
  }
  /// Returns true if `numItemsNeeded` has been explicitly set.
  var hasNumItemsNeeded: Bool {return self._numItemsNeeded != nil}
  /// Clears the value of `numItemsNeeded`. Subsequent reads from it will return its default value.
  mutating func clearNumItemsNeeded() {self._numItemsNeeded = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _appID: UInt32? = nil
  fileprivate var _lastTimeUpdated: UInt32? = nil
  fileprivate var _numItemsNeeded: UInt32? = nil
}

struct CMsgClientWorkshopItemChangesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var updateTime: UInt32 {
    get {return _updateTime ?? 0}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  mutating func clearUpdateTime() {self._updateTime = nil}

  var workshopItems: [CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct WorkshopItemInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var publishedFileID: UInt64 {
      get {return _publishedFileID ?? 0}
      set {_publishedFileID = newValue}
    }
    /// Returns true if `publishedFileID` has been explicitly set.
    var hasPublishedFileID: Bool {return self._publishedFileID != nil}
    /// Clears the value of `publishedFileID`. Subsequent reads from it will return its default value.
    mutating func clearPublishedFileID() {self._publishedFileID = nil}

    var timeUpdated: UInt32 {
      get {return _timeUpdated ?? 0}
      set {_timeUpdated = newValue}
    }
    /// Returns true if `timeUpdated` has been explicitly set.
    var hasTimeUpdated: Bool {return self._timeUpdated != nil}
    /// Clears the value of `timeUpdated`. Subsequent reads from it will return its default value.
    mutating func clearTimeUpdated() {self._timeUpdated = nil}

    var manifestID: UInt64 {
      get {return _manifestID ?? 0}
      set {_manifestID = newValue}
    }
    /// Returns true if `manifestID` has been explicitly set.
    var hasManifestID: Bool {return self._manifestID != nil}
    /// Clears the value of `manifestID`. Subsequent reads from it will return its default value.
    mutating func clearManifestID() {self._manifestID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _publishedFileID: UInt64? = nil
    fileprivate var _timeUpdated: UInt32? = nil
    fileprivate var _manifestID: UInt64? = nil
  }

  init() {}

  fileprivate var _eresult: Int32? = nil
  fileprivate var _updateTime: UInt32? = nil
}

struct CMsgClientUCMSetUserPublishedFileAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publishedFileID: UInt64 {
    get {return _publishedFileID ?? 0}
    set {_publishedFileID = newValue}
  }
  /// Returns true if `publishedFileID` has been explicitly set.
  var hasPublishedFileID: Bool {return self._publishedFileID != nil}
  /// Clears the value of `publishedFileID`. Subsequent reads from it will return its default value.
  mutating func clearPublishedFileID() {self._publishedFileID = nil}

  var appID: UInt32 {
    get {return _appID ?? 0}
    set {_appID = newValue}
  }
  /// Returns true if `appID` has been explicitly set.
  var hasAppID: Bool {return self._appID != nil}
  /// Clears the value of `appID`. Subsequent reads from it will return its default value.
  mutating func clearAppID() {self._appID = nil}

  var action: Int32 {
    get {return _action ?? 0}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  mutating func clearAction() {self._action = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publishedFileID: UInt64? = nil
  fileprivate var _appID: UInt32? = nil
  fileprivate var _action: Int32? = nil
}

struct CMsgClientUCMSetUserPublishedFileActionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: Int32? = nil
}

struct CMsgClientUCMEnumeratePublishedFilesByUserAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: UInt32 {
    get {return _appID ?? 0}
    set {_appID = newValue}
  }
  /// Returns true if `appID` has been explicitly set.
  var hasAppID: Bool {return self._appID != nil}
  /// Clears the value of `appID`. Subsequent reads from it will return its default value.
  mutating func clearAppID() {self._appID = nil}

  var startIndex: UInt32 {
    get {return _startIndex ?? 0}
    set {_startIndex = newValue}
  }
  /// Returns true if `startIndex` has been explicitly set.
  var hasStartIndex: Bool {return self._startIndex != nil}
  /// Clears the value of `startIndex`. Subsequent reads from it will return its default value.
  mutating func clearStartIndex() {self._startIndex = nil}

  var action: Int32 {
    get {return _action ?? 0}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  mutating func clearAction() {self._action = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _appID: UInt32? = nil
  fileprivate var _startIndex: UInt32? = nil
  fileprivate var _action: Int32? = nil
}

struct CMsgClientUCMEnumeratePublishedFilesByUserActionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var publishedFiles: [CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId] = []

  var totalResults: UInt32 {
    get {return _totalResults ?? 0}
    set {_totalResults = newValue}
  }
  /// Returns true if `totalResults` has been explicitly set.
  var hasTotalResults: Bool {return self._totalResults != nil}
  /// Clears the value of `totalResults`. Subsequent reads from it will return its default value.
  mutating func clearTotalResults() {self._totalResults = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PublishedFileId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var publishedFileID: UInt64 {
      get {return _publishedFileID ?? 0}
      set {_publishedFileID = newValue}
    }
    /// Returns true if `publishedFileID` has been explicitly set.
    var hasPublishedFileID: Bool {return self._publishedFileID != nil}
    /// Clears the value of `publishedFileID`. Subsequent reads from it will return its default value.
    mutating func clearPublishedFileID() {self._publishedFileID = nil}

    var rtimeTimeStamp: UInt32 {
      get {return _rtimeTimeStamp ?? 0}
      set {_rtimeTimeStamp = newValue}
    }
    /// Returns true if `rtimeTimeStamp` has been explicitly set.
    var hasRtimeTimeStamp: Bool {return self._rtimeTimeStamp != nil}
    /// Clears the value of `rtimeTimeStamp`. Subsequent reads from it will return its default value.
    mutating func clearRtimeTimeStamp() {self._rtimeTimeStamp = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _publishedFileID: UInt64? = nil
    fileprivate var _rtimeTimeStamp: UInt32? = nil
  }

  init() {}

  fileprivate var _eresult: Int32? = nil
  fileprivate var _totalResults: UInt32? = nil
}

struct CMsgClientScreenshotsChanged {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CMsgClientUpdateUserGameInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var steamidIdgs: UInt64 {
    get {return _steamidIdgs ?? 0}
    set {_steamidIdgs = newValue}
  }
  /// Returns true if `steamidIdgs` has been explicitly set.
  var hasSteamidIdgs: Bool {return self._steamidIdgs != nil}
  /// Clears the value of `steamidIdgs`. Subsequent reads from it will return its default value.
  mutating func clearSteamidIdgs() {self._steamidIdgs = nil}

  var gameid: UInt64 {
    get {return _gameid ?? 0}
    set {_gameid = newValue}
  }
  /// Returns true if `gameid` has been explicitly set.
  var hasGameid: Bool {return self._gameid != nil}
  /// Clears the value of `gameid`. Subsequent reads from it will return its default value.
  mutating func clearGameid() {self._gameid = nil}

  var gameIp: UInt32 {
    get {return _gameIp ?? 0}
    set {_gameIp = newValue}
  }
  /// Returns true if `gameIp` has been explicitly set.
  var hasGameIp: Bool {return self._gameIp != nil}
  /// Clears the value of `gameIp`. Subsequent reads from it will return its default value.
  mutating func clearGameIp() {self._gameIp = nil}

  var gamePort: UInt32 {
    get {return _gamePort ?? 0}
    set {_gamePort = newValue}
  }
  /// Returns true if `gamePort` has been explicitly set.
  var hasGamePort: Bool {return self._gamePort != nil}
  /// Clears the value of `gamePort`. Subsequent reads from it will return its default value.
  mutating func clearGamePort() {self._gamePort = nil}

  var token: Data {
    get {return _token ?? Data()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  mutating func clearToken() {self._token = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _steamidIdgs: UInt64? = nil
  fileprivate var _gameid: UInt64? = nil
  fileprivate var _gameIp: UInt32? = nil
  fileprivate var _gamePort: UInt32? = nil
  fileprivate var _token: Data? = nil
}

struct CMsgClientRichPresenceUpload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var richPresenceKv: Data {
    get {return _richPresenceKv ?? Data()}
    set {_richPresenceKv = newValue}
  }
  /// Returns true if `richPresenceKv` has been explicitly set.
  var hasRichPresenceKv: Bool {return self._richPresenceKv != nil}
  /// Clears the value of `richPresenceKv`. Subsequent reads from it will return its default value.
  mutating func clearRichPresenceKv() {self._richPresenceKv = nil}

  var steamidBroadcast: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _richPresenceKv: Data? = nil
}

struct CMsgClientRichPresenceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var steamidRequest: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CMsgClientRichPresenceInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var richPresence: [CMsgClientRichPresenceInfo.RichPresence] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct RichPresence {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var steamidUser: UInt64 {
      get {return _steamidUser ?? 0}
      set {_steamidUser = newValue}
    }
    /// Returns true if `steamidUser` has been explicitly set.
    var hasSteamidUser: Bool {return self._steamidUser != nil}
    /// Clears the value of `steamidUser`. Subsequent reads from it will return its default value.
    mutating func clearSteamidUser() {self._steamidUser = nil}

    var richPresenceKv: Data {
      get {return _richPresenceKv ?? Data()}
      set {_richPresenceKv = newValue}
    }
    /// Returns true if `richPresenceKv` has been explicitly set.
    var hasRichPresenceKv: Bool {return self._richPresenceKv != nil}
    /// Clears the value of `richPresenceKv`. Subsequent reads from it will return its default value.
    mutating func clearRichPresenceKv() {self._richPresenceKv = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _steamidUser: UInt64? = nil
    fileprivate var _richPresenceKv: Data? = nil
  }

  init() {}
}

struct CMsgClientCheckFileSignature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: UInt32 {
    get {return _appID ?? 0}
    set {_appID = newValue}
  }
  /// Returns true if `appID` has been explicitly set.
  var hasAppID: Bool {return self._appID != nil}
  /// Clears the value of `appID`. Subsequent reads from it will return its default value.
  mutating func clearAppID() {self._appID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _appID: UInt32? = nil
}

struct CMsgClientCheckFileSignatureResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: UInt32 {
    get {return _appID ?? 0}
    set {_appID = newValue}
  }
  /// Returns true if `appID` has been explicitly set.
  var hasAppID: Bool {return self._appID != nil}
  /// Clears the value of `appID`. Subsequent reads from it will return its default value.
  mutating func clearAppID() {self._appID = nil}

  var pid: UInt32 {
    get {return _pid ?? 0}
    set {_pid = newValue}
  }
  /// Returns true if `pid` has been explicitly set.
  var hasPid: Bool {return self._pid != nil}
  /// Clears the value of `pid`. Subsequent reads from it will return its default value.
  mutating func clearPid() {self._pid = nil}

  var eresult: UInt32 {
    get {return _eresult ?? 0}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var filename: String {
    get {return _filename ?? String()}
    set {_filename = newValue}
  }
  /// Returns true if `filename` has been explicitly set.
  var hasFilename: Bool {return self._filename != nil}
  /// Clears the value of `filename`. Subsequent reads from it will return its default value.
  mutating func clearFilename() {self._filename = nil}

  var esignatureresult: UInt32 {
    get {return _esignatureresult ?? 0}
    set {_esignatureresult = newValue}
  }
  /// Returns true if `esignatureresult` has been explicitly set.
  var hasEsignatureresult: Bool {return self._esignatureresult != nil}
  /// Clears the value of `esignatureresult`. Subsequent reads from it will return its default value.
  mutating func clearEsignatureresult() {self._esignatureresult = nil}

  var shaFile: Data {
    get {return _shaFile ?? Data()}
    set {_shaFile = newValue}
  }
  /// Returns true if `shaFile` has been explicitly set.
  var hasShaFile: Bool {return self._shaFile != nil}
  /// Clears the value of `shaFile`. Subsequent reads from it will return its default value.
  mutating func clearShaFile() {self._shaFile = nil}

  var signatureheader: Data {
    get {return _signatureheader ?? Data()}
    set {_signatureheader = newValue}
  }
  /// Returns true if `signatureheader` has been explicitly set.
  var hasSignatureheader: Bool {return self._signatureheader != nil}
  /// Clears the value of `signatureheader`. Subsequent reads from it will return its default value.
  mutating func clearSignatureheader() {self._signatureheader = nil}

  var filesize: UInt32 {
    get {return _filesize ?? 0}
    set {_filesize = newValue}
  }
  /// Returns true if `filesize` has been explicitly set.
  var hasFilesize: Bool {return self._filesize != nil}
  /// Clears the value of `filesize`. Subsequent reads from it will return its default value.
  mutating func clearFilesize() {self._filesize = nil}

  var getlasterror: UInt32 {
    get {return _getlasterror ?? 0}
    set {_getlasterror = newValue}
  }
  /// Returns true if `getlasterror` has been explicitly set.
  var hasGetlasterror: Bool {return self._getlasterror != nil}
  /// Clears the value of `getlasterror`. Subsequent reads from it will return its default value.
  mutating func clearGetlasterror() {self._getlasterror = nil}

  var evalvesignaturecheckdetail: UInt32 {
    get {return _evalvesignaturecheckdetail ?? 0}
    set {_evalvesignaturecheckdetail = newValue}
  }
  /// Returns true if `evalvesignaturecheckdetail` has been explicitly set.
  var hasEvalvesignaturecheckdetail: Bool {return self._evalvesignaturecheckdetail != nil}
  /// Clears the value of `evalvesignaturecheckdetail`. Subsequent reads from it will return its default value.
  mutating func clearEvalvesignaturecheckdetail() {self._evalvesignaturecheckdetail = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _appID: UInt32? = nil
  fileprivate var _pid: UInt32? = nil
  fileprivate var _eresult: UInt32? = nil
  fileprivate var _filename: String? = nil
  fileprivate var _esignatureresult: UInt32? = nil
  fileprivate var _shaFile: Data? = nil
  fileprivate var _signatureheader: Data? = nil
  fileprivate var _filesize: UInt32? = nil
  fileprivate var _getlasterror: UInt32? = nil
  fileprivate var _evalvesignaturecheckdetail: UInt32? = nil
}

struct CMsgClientReadMachineAuth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var filename: String {
    get {return _filename ?? String()}
    set {_filename = newValue}
  }
  /// Returns true if `filename` has been explicitly set.
  var hasFilename: Bool {return self._filename != nil}
  /// Clears the value of `filename`. Subsequent reads from it will return its default value.
  mutating func clearFilename() {self._filename = nil}

  var offset: UInt32 {
    get {return _offset ?? 0}
    set {_offset = newValue}
  }
  /// Returns true if `offset` has been explicitly set.
  var hasOffset: Bool {return self._offset != nil}
  /// Clears the value of `offset`. Subsequent reads from it will return its default value.
  mutating func clearOffset() {self._offset = nil}

  var cubtoread: UInt32 {
    get {return _cubtoread ?? 0}
    set {_cubtoread = newValue}
  }
  /// Returns true if `cubtoread` has been explicitly set.
  var hasCubtoread: Bool {return self._cubtoread != nil}
  /// Clears the value of `cubtoread`. Subsequent reads from it will return its default value.
  mutating func clearCubtoread() {self._cubtoread = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _filename: String? = nil
  fileprivate var _offset: UInt32? = nil
  fileprivate var _cubtoread: UInt32? = nil
}

struct CMsgClientReadMachineAuthResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var filename: String {
    get {return _filename ?? String()}
    set {_filename = newValue}
  }
  /// Returns true if `filename` has been explicitly set.
  var hasFilename: Bool {return self._filename != nil}
  /// Clears the value of `filename`. Subsequent reads from it will return its default value.
  mutating func clearFilename() {self._filename = nil}

  var eresult: UInt32 {
    get {return _eresult ?? 0}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var filesize: UInt32 {
    get {return _filesize ?? 0}
    set {_filesize = newValue}
  }
  /// Returns true if `filesize` has been explicitly set.
  var hasFilesize: Bool {return self._filesize != nil}
  /// Clears the value of `filesize`. Subsequent reads from it will return its default value.
  mutating func clearFilesize() {self._filesize = nil}

  var shaFile: Data {
    get {return _shaFile ?? Data()}
    set {_shaFile = newValue}
  }
  /// Returns true if `shaFile` has been explicitly set.
  var hasShaFile: Bool {return self._shaFile != nil}
  /// Clears the value of `shaFile`. Subsequent reads from it will return its default value.
  mutating func clearShaFile() {self._shaFile = nil}

  var getlasterror: UInt32 {
    get {return _getlasterror ?? 0}
    set {_getlasterror = newValue}
  }
  /// Returns true if `getlasterror` has been explicitly set.
  var hasGetlasterror: Bool {return self._getlasterror != nil}
  /// Clears the value of `getlasterror`. Subsequent reads from it will return its default value.
  mutating func clearGetlasterror() {self._getlasterror = nil}

  var offset: UInt32 {
    get {return _offset ?? 0}
    set {_offset = newValue}
  }
  /// Returns true if `offset` has been explicitly set.
  var hasOffset: Bool {return self._offset != nil}
  /// Clears the value of `offset`. Subsequent reads from it will return its default value.
  mutating func clearOffset() {self._offset = nil}

  var cubread: UInt32 {
    get {return _cubread ?? 0}
    set {_cubread = newValue}
  }
  /// Returns true if `cubread` has been explicitly set.
  var hasCubread: Bool {return self._cubread != nil}
  /// Clears the value of `cubread`. Subsequent reads from it will return its default value.
  mutating func clearCubread() {self._cubread = nil}

  var bytesRead: Data {
    get {return _bytesRead ?? Data()}
    set {_bytesRead = newValue}
  }
  /// Returns true if `bytesRead` has been explicitly set.
  var hasBytesRead: Bool {return self._bytesRead != nil}
  /// Clears the value of `bytesRead`. Subsequent reads from it will return its default value.
  mutating func clearBytesRead() {self._bytesRead = nil}

  var filenameSentry: String {
    get {return _filenameSentry ?? String()}
    set {_filenameSentry = newValue}
  }
  /// Returns true if `filenameSentry` has been explicitly set.
  var hasFilenameSentry: Bool {return self._filenameSentry != nil}
  /// Clears the value of `filenameSentry`. Subsequent reads from it will return its default value.
  mutating func clearFilenameSentry() {self._filenameSentry = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _filename: String? = nil
  fileprivate var _eresult: UInt32? = nil
  fileprivate var _filesize: UInt32? = nil
  fileprivate var _shaFile: Data? = nil
  fileprivate var _getlasterror: UInt32? = nil
  fileprivate var _offset: UInt32? = nil
  fileprivate var _cubread: UInt32? = nil
  fileprivate var _bytesRead: Data? = nil
  fileprivate var _filenameSentry: String? = nil
}

struct CMsgClientUpdateMachineAuth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var filename: String {
    get {return _filename ?? String()}
    set {_filename = newValue}
  }
  /// Returns true if `filename` has been explicitly set.
  var hasFilename: Bool {return self._filename != nil}
  /// Clears the value of `filename`. Subsequent reads from it will return its default value.
  mutating func clearFilename() {self._filename = nil}

  var offset: UInt32 {
    get {return _offset ?? 0}
    set {_offset = newValue}
  }
  /// Returns true if `offset` has been explicitly set.
  var hasOffset: Bool {return self._offset != nil}
  /// Clears the value of `offset`. Subsequent reads from it will return its default value.
  mutating func clearOffset() {self._offset = nil}

  var cubtowrite: UInt32 {
    get {return _cubtowrite ?? 0}
    set {_cubtowrite = newValue}
  }
  /// Returns true if `cubtowrite` has been explicitly set.
  var hasCubtowrite: Bool {return self._cubtowrite != nil}
  /// Clears the value of `cubtowrite`. Subsequent reads from it will return its default value.
  mutating func clearCubtowrite() {self._cubtowrite = nil}

  var bytes: Data {
    get {return _bytes ?? Data()}
    set {_bytes = newValue}
  }
  /// Returns true if `bytes` has been explicitly set.
  var hasBytes: Bool {return self._bytes != nil}
  /// Clears the value of `bytes`. Subsequent reads from it will return its default value.
  mutating func clearBytes() {self._bytes = nil}

  var otpType: UInt32 {
    get {return _otpType ?? 0}
    set {_otpType = newValue}
  }
  /// Returns true if `otpType` has been explicitly set.
  var hasOtpType: Bool {return self._otpType != nil}
  /// Clears the value of `otpType`. Subsequent reads from it will return its default value.
  mutating func clearOtpType() {self._otpType = nil}

  var otpIdentifier: String {
    get {return _otpIdentifier ?? String()}
    set {_otpIdentifier = newValue}
  }
  /// Returns true if `otpIdentifier` has been explicitly set.
  var hasOtpIdentifier: Bool {return self._otpIdentifier != nil}
  /// Clears the value of `otpIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearOtpIdentifier() {self._otpIdentifier = nil}

  var otpSharedsecret: Data {
    get {return _otpSharedsecret ?? Data()}
    set {_otpSharedsecret = newValue}
  }
  /// Returns true if `otpSharedsecret` has been explicitly set.
  var hasOtpSharedsecret: Bool {return self._otpSharedsecret != nil}
  /// Clears the value of `otpSharedsecret`. Subsequent reads from it will return its default value.
  mutating func clearOtpSharedsecret() {self._otpSharedsecret = nil}

  var otpTimedrift: UInt32 {
    get {return _otpTimedrift ?? 0}
    set {_otpTimedrift = newValue}
  }
  /// Returns true if `otpTimedrift` has been explicitly set.
  var hasOtpTimedrift: Bool {return self._otpTimedrift != nil}
  /// Clears the value of `otpTimedrift`. Subsequent reads from it will return its default value.
  mutating func clearOtpTimedrift() {self._otpTimedrift = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _filename: String? = nil
  fileprivate var _offset: UInt32? = nil
  fileprivate var _cubtowrite: UInt32? = nil
  fileprivate var _bytes: Data? = nil
  fileprivate var _otpType: UInt32? = nil
  fileprivate var _otpIdentifier: String? = nil
  fileprivate var _otpSharedsecret: Data? = nil
  fileprivate var _otpTimedrift: UInt32? = nil
}

struct CMsgClientUpdateMachineAuthResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var filename: String {
    get {return _filename ?? String()}
    set {_filename = newValue}
  }
  /// Returns true if `filename` has been explicitly set.
  var hasFilename: Bool {return self._filename != nil}
  /// Clears the value of `filename`. Subsequent reads from it will return its default value.
  mutating func clearFilename() {self._filename = nil}

  var eresult: UInt32 {
    get {return _eresult ?? 0}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var filesize: UInt32 {
    get {return _filesize ?? 0}
    set {_filesize = newValue}
  }
  /// Returns true if `filesize` has been explicitly set.
  var hasFilesize: Bool {return self._filesize != nil}
  /// Clears the value of `filesize`. Subsequent reads from it will return its default value.
  mutating func clearFilesize() {self._filesize = nil}

  var shaFile: Data {
    get {return _shaFile ?? Data()}
    set {_shaFile = newValue}
  }
  /// Returns true if `shaFile` has been explicitly set.
  var hasShaFile: Bool {return self._shaFile != nil}
  /// Clears the value of `shaFile`. Subsequent reads from it will return its default value.
  mutating func clearShaFile() {self._shaFile = nil}

  var getlasterror: UInt32 {
    get {return _getlasterror ?? 0}
    set {_getlasterror = newValue}
  }
  /// Returns true if `getlasterror` has been explicitly set.
  var hasGetlasterror: Bool {return self._getlasterror != nil}
  /// Clears the value of `getlasterror`. Subsequent reads from it will return its default value.
  mutating func clearGetlasterror() {self._getlasterror = nil}

  var offset: UInt32 {
    get {return _offset ?? 0}
    set {_offset = newValue}
  }
  /// Returns true if `offset` has been explicitly set.
  var hasOffset: Bool {return self._offset != nil}
  /// Clears the value of `offset`. Subsequent reads from it will return its default value.
  mutating func clearOffset() {self._offset = nil}

  var cubwrote: UInt32 {
    get {return _cubwrote ?? 0}
    set {_cubwrote = newValue}
  }
  /// Returns true if `cubwrote` has been explicitly set.
  var hasCubwrote: Bool {return self._cubwrote != nil}
  /// Clears the value of `cubwrote`. Subsequent reads from it will return its default value.
  mutating func clearCubwrote() {self._cubwrote = nil}

  var otpType: Int32 {
    get {return _otpType ?? 0}
    set {_otpType = newValue}
  }
  /// Returns true if `otpType` has been explicitly set.
  var hasOtpType: Bool {return self._otpType != nil}
  /// Clears the value of `otpType`. Subsequent reads from it will return its default value.
  mutating func clearOtpType() {self._otpType = nil}

  var otpValue: UInt32 {
    get {return _otpValue ?? 0}
    set {_otpValue = newValue}
  }
  /// Returns true if `otpValue` has been explicitly set.
  var hasOtpValue: Bool {return self._otpValue != nil}
  /// Clears the value of `otpValue`. Subsequent reads from it will return its default value.
  mutating func clearOtpValue() {self._otpValue = nil}

  var otpIdentifier: String {
    get {return _otpIdentifier ?? String()}
    set {_otpIdentifier = newValue}
  }
  /// Returns true if `otpIdentifier` has been explicitly set.
  var hasOtpIdentifier: Bool {return self._otpIdentifier != nil}
  /// Clears the value of `otpIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearOtpIdentifier() {self._otpIdentifier = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _filename: String? = nil
  fileprivate var _eresult: UInt32? = nil
  fileprivate var _filesize: UInt32? = nil
  fileprivate var _shaFile: Data? = nil
  fileprivate var _getlasterror: UInt32? = nil
  fileprivate var _offset: UInt32? = nil
  fileprivate var _cubwrote: UInt32? = nil
  fileprivate var _otpType: Int32? = nil
  fileprivate var _otpValue: UInt32? = nil
  fileprivate var _otpIdentifier: String? = nil
}

struct CMsgClientRequestMachineAuth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var filename: String {
    get {return _filename ?? String()}
    set {_filename = newValue}
  }
  /// Returns true if `filename` has been explicitly set.
  var hasFilename: Bool {return self._filename != nil}
  /// Clears the value of `filename`. Subsequent reads from it will return its default value.
  mutating func clearFilename() {self._filename = nil}

  var eresultSentryfile: UInt32 {
    get {return _eresultSentryfile ?? 0}
    set {_eresultSentryfile = newValue}
  }
  /// Returns true if `eresultSentryfile` has been explicitly set.
  var hasEresultSentryfile: Bool {return self._eresultSentryfile != nil}
  /// Clears the value of `eresultSentryfile`. Subsequent reads from it will return its default value.
  mutating func clearEresultSentryfile() {self._eresultSentryfile = nil}

  var filesize: UInt32 {
    get {return _filesize ?? 0}
    set {_filesize = newValue}
  }
  /// Returns true if `filesize` has been explicitly set.
  var hasFilesize: Bool {return self._filesize != nil}
  /// Clears the value of `filesize`. Subsequent reads from it will return its default value.
  mutating func clearFilesize() {self._filesize = nil}

  var shaSentryfile: Data {
    get {return _shaSentryfile ?? Data()}
    set {_shaSentryfile = newValue}
  }
  /// Returns true if `shaSentryfile` has been explicitly set.
  var hasShaSentryfile: Bool {return self._shaSentryfile != nil}
  /// Clears the value of `shaSentryfile`. Subsequent reads from it will return its default value.
  mutating func clearShaSentryfile() {self._shaSentryfile = nil}

  var lockAccountAction: Int32 {
    get {return _lockAccountAction ?? 0}
    set {_lockAccountAction = newValue}
  }
  /// Returns true if `lockAccountAction` has been explicitly set.
  var hasLockAccountAction: Bool {return self._lockAccountAction != nil}
  /// Clears the value of `lockAccountAction`. Subsequent reads from it will return its default value.
  mutating func clearLockAccountAction() {self._lockAccountAction = nil}

  var otpType: UInt32 {
    get {return _otpType ?? 0}
    set {_otpType = newValue}
  }
  /// Returns true if `otpType` has been explicitly set.
  var hasOtpType: Bool {return self._otpType != nil}
  /// Clears the value of `otpType`. Subsequent reads from it will return its default value.
  mutating func clearOtpType() {self._otpType = nil}

  var otpIdentifier: String {
    get {return _otpIdentifier ?? String()}
    set {_otpIdentifier = newValue}
  }
  /// Returns true if `otpIdentifier` has been explicitly set.
  var hasOtpIdentifier: Bool {return self._otpIdentifier != nil}
  /// Clears the value of `otpIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearOtpIdentifier() {self._otpIdentifier = nil}

  var otpSharedsecret: Data {
    get {return _otpSharedsecret ?? Data()}
    set {_otpSharedsecret = newValue}
  }
  /// Returns true if `otpSharedsecret` has been explicitly set.
  var hasOtpSharedsecret: Bool {return self._otpSharedsecret != nil}
  /// Clears the value of `otpSharedsecret`. Subsequent reads from it will return its default value.
  mutating func clearOtpSharedsecret() {self._otpSharedsecret = nil}

  var otpValue: UInt32 {
    get {return _otpValue ?? 0}
    set {_otpValue = newValue}
  }
  /// Returns true if `otpValue` has been explicitly set.
  var hasOtpValue: Bool {return self._otpValue != nil}
  /// Clears the value of `otpValue`. Subsequent reads from it will return its default value.
  mutating func clearOtpValue() {self._otpValue = nil}

  var machineName: String {
    get {return _machineName ?? String()}
    set {_machineName = newValue}
  }
  /// Returns true if `machineName` has been explicitly set.
  var hasMachineName: Bool {return self._machineName != nil}
  /// Clears the value of `machineName`. Subsequent reads from it will return its default value.
  mutating func clearMachineName() {self._machineName = nil}

  var machineNameUserchosen: String {
    get {return _machineNameUserchosen ?? String()}
    set {_machineNameUserchosen = newValue}
  }
  /// Returns true if `machineNameUserchosen` has been explicitly set.
  var hasMachineNameUserchosen: Bool {return self._machineNameUserchosen != nil}
  /// Clears the value of `machineNameUserchosen`. Subsequent reads from it will return its default value.
  mutating func clearMachineNameUserchosen() {self._machineNameUserchosen = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _filename: String? = nil
  fileprivate var _eresultSentryfile: UInt32? = nil
  fileprivate var _filesize: UInt32? = nil
  fileprivate var _shaSentryfile: Data? = nil
  fileprivate var _lockAccountAction: Int32? = nil
  fileprivate var _otpType: UInt32? = nil
  fileprivate var _otpIdentifier: String? = nil
  fileprivate var _otpSharedsecret: Data? = nil
  fileprivate var _otpValue: UInt32? = nil
  fileprivate var _machineName: String? = nil
  fileprivate var _machineNameUserchosen: String? = nil
}

struct CMsgClientRequestMachineAuthResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: UInt32 {
    get {return _eresult ?? 0}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: UInt32? = nil
}

struct CMsgClientRegisterKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _key: String? = nil
}

struct CMsgClientPurchaseResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var purchaseResultDetails: Int32 {
    get {return _purchaseResultDetails ?? 0}
    set {_purchaseResultDetails = newValue}
  }
  /// Returns true if `purchaseResultDetails` has been explicitly set.
  var hasPurchaseResultDetails: Bool {return self._purchaseResultDetails != nil}
  /// Clears the value of `purchaseResultDetails`. Subsequent reads from it will return its default value.
  mutating func clearPurchaseResultDetails() {self._purchaseResultDetails = nil}

  var purchaseReceiptInfo: Data {
    get {return _purchaseReceiptInfo ?? Data()}
    set {_purchaseReceiptInfo = newValue}
  }
  /// Returns true if `purchaseReceiptInfo` has been explicitly set.
  var hasPurchaseReceiptInfo: Bool {return self._purchaseReceiptInfo != nil}
  /// Clears the value of `purchaseReceiptInfo`. Subsequent reads from it will return its default value.
  mutating func clearPurchaseReceiptInfo() {self._purchaseReceiptInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: Int32? = nil
  fileprivate var _purchaseResultDetails: Int32? = nil
  fileprivate var _purchaseReceiptInfo: Data? = nil
}

struct CMsgClientActivateOEMLicense {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var biosManufacturer: String {
    get {return _biosManufacturer ?? String()}
    set {_biosManufacturer = newValue}
  }
  /// Returns true if `biosManufacturer` has been explicitly set.
  var hasBiosManufacturer: Bool {return self._biosManufacturer != nil}
  /// Clears the value of `biosManufacturer`. Subsequent reads from it will return its default value.
  mutating func clearBiosManufacturer() {self._biosManufacturer = nil}

  var biosSerialnumber: String {
    get {return _biosSerialnumber ?? String()}
    set {_biosSerialnumber = newValue}
  }
  /// Returns true if `biosSerialnumber` has been explicitly set.
  var hasBiosSerialnumber: Bool {return self._biosSerialnumber != nil}
  /// Clears the value of `biosSerialnumber`. Subsequent reads from it will return its default value.
  mutating func clearBiosSerialnumber() {self._biosSerialnumber = nil}

  var licenseFile: Data {
    get {return _licenseFile ?? Data()}
    set {_licenseFile = newValue}
  }
  /// Returns true if `licenseFile` has been explicitly set.
  var hasLicenseFile: Bool {return self._licenseFile != nil}
  /// Clears the value of `licenseFile`. Subsequent reads from it will return its default value.
  mutating func clearLicenseFile() {self._licenseFile = nil}

  var mainboardManufacturer: String {
    get {return _mainboardManufacturer ?? String()}
    set {_mainboardManufacturer = newValue}
  }
  /// Returns true if `mainboardManufacturer` has been explicitly set.
  var hasMainboardManufacturer: Bool {return self._mainboardManufacturer != nil}
  /// Clears the value of `mainboardManufacturer`. Subsequent reads from it will return its default value.
  mutating func clearMainboardManufacturer() {self._mainboardManufacturer = nil}

  var mainboardProduct: String {
    get {return _mainboardProduct ?? String()}
    set {_mainboardProduct = newValue}
  }
  /// Returns true if `mainboardProduct` has been explicitly set.
  var hasMainboardProduct: Bool {return self._mainboardProduct != nil}
  /// Clears the value of `mainboardProduct`. Subsequent reads from it will return its default value.
  mutating func clearMainboardProduct() {self._mainboardProduct = nil}

  var mainboardSerialnumber: String {
    get {return _mainboardSerialnumber ?? String()}
    set {_mainboardSerialnumber = newValue}
  }
  /// Returns true if `mainboardSerialnumber` has been explicitly set.
  var hasMainboardSerialnumber: Bool {return self._mainboardSerialnumber != nil}
  /// Clears the value of `mainboardSerialnumber`. Subsequent reads from it will return its default value.
  mutating func clearMainboardSerialnumber() {self._mainboardSerialnumber = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _biosManufacturer: String? = nil
  fileprivate var _biosSerialnumber: String? = nil
  fileprivate var _licenseFile: Data? = nil
  fileprivate var _mainboardManufacturer: String? = nil
  fileprivate var _mainboardProduct: String? = nil
  fileprivate var _mainboardSerialnumber: String? = nil
}

struct CMsgClientRegisterOEMMachine {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var oemRegisterFile: Data {
    get {return _oemRegisterFile ?? Data()}
    set {_oemRegisterFile = newValue}
  }
  /// Returns true if `oemRegisterFile` has been explicitly set.
  var hasOemRegisterFile: Bool {return self._oemRegisterFile != nil}
  /// Clears the value of `oemRegisterFile`. Subsequent reads from it will return its default value.
  mutating func clearOemRegisterFile() {self._oemRegisterFile = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _oemRegisterFile: Data? = nil
}

struct CMsgClientRegisterOEMMachineResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: UInt32 {
    get {return _eresult ?? 0}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: UInt32? = nil
}

struct CMsgClientPurchaseWithMachineID {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var packageID: UInt32 {
    get {return _packageID ?? 0}
    set {_packageID = newValue}
  }
  /// Returns true if `packageID` has been explicitly set.
  var hasPackageID: Bool {return self._packageID != nil}
  /// Clears the value of `packageID`. Subsequent reads from it will return its default value.
  mutating func clearPackageID() {self._packageID = nil}

  var machineInfo: Data {
    get {return _machineInfo ?? Data()}
    set {_machineInfo = newValue}
  }
  /// Returns true if `machineInfo` has been explicitly set.
  var hasMachineInfo: Bool {return self._machineInfo != nil}
  /// Clears the value of `machineInfo`. Subsequent reads from it will return its default value.
  mutating func clearMachineInfo() {self._machineInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _packageID: UInt32? = nil
  fileprivate var _machineInfo: Data? = nil
}

struct CMsgTrading_InitiateTradeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tradeRequestID: UInt32 {
    get {return _tradeRequestID ?? 0}
    set {_tradeRequestID = newValue}
  }
  /// Returns true if `tradeRequestID` has been explicitly set.
  var hasTradeRequestID: Bool {return self._tradeRequestID != nil}
  /// Clears the value of `tradeRequestID`. Subsequent reads from it will return its default value.
  mutating func clearTradeRequestID() {self._tradeRequestID = nil}

  var otherSteamid: UInt64 {
    get {return _otherSteamid ?? 0}
    set {_otherSteamid = newValue}
  }
  /// Returns true if `otherSteamid` has been explicitly set.
  var hasOtherSteamid: Bool {return self._otherSteamid != nil}
  /// Clears the value of `otherSteamid`. Subsequent reads from it will return its default value.
  mutating func clearOtherSteamid() {self._otherSteamid = nil}

  var otherName: String {
    get {return _otherName ?? String()}
    set {_otherName = newValue}
  }
  /// Returns true if `otherName` has been explicitly set.
  var hasOtherName: Bool {return self._otherName != nil}
  /// Clears the value of `otherName`. Subsequent reads from it will return its default value.
  mutating func clearOtherName() {self._otherName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tradeRequestID: UInt32? = nil
  fileprivate var _otherSteamid: UInt64? = nil
  fileprivate var _otherName: String? = nil
}

struct CMsgTrading_InitiateTradeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: UInt32 {
    get {return _response ?? 0}
    set {_response = newValue}
  }
  /// Returns true if `response` has been explicitly set.
  var hasResponse: Bool {return self._response != nil}
  /// Clears the value of `response`. Subsequent reads from it will return its default value.
  mutating func clearResponse() {self._response = nil}

  var tradeRequestID: UInt32 {
    get {return _tradeRequestID ?? 0}
    set {_tradeRequestID = newValue}
  }
  /// Returns true if `tradeRequestID` has been explicitly set.
  var hasTradeRequestID: Bool {return self._tradeRequestID != nil}
  /// Clears the value of `tradeRequestID`. Subsequent reads from it will return its default value.
  mutating func clearTradeRequestID() {self._tradeRequestID = nil}

  var otherSteamid: UInt64 {
    get {return _otherSteamid ?? 0}
    set {_otherSteamid = newValue}
  }
  /// Returns true if `otherSteamid` has been explicitly set.
  var hasOtherSteamid: Bool {return self._otherSteamid != nil}
  /// Clears the value of `otherSteamid`. Subsequent reads from it will return its default value.
  mutating func clearOtherSteamid() {self._otherSteamid = nil}

  var steamguardRequiredDays: UInt32 {
    get {return _steamguardRequiredDays ?? 0}
    set {_steamguardRequiredDays = newValue}
  }
  /// Returns true if `steamguardRequiredDays` has been explicitly set.
  var hasSteamguardRequiredDays: Bool {return self._steamguardRequiredDays != nil}
  /// Clears the value of `steamguardRequiredDays`. Subsequent reads from it will return its default value.
  mutating func clearSteamguardRequiredDays() {self._steamguardRequiredDays = nil}

  var newDeviceCooldownDays: UInt32 {
    get {return _newDeviceCooldownDays ?? 0}
    set {_newDeviceCooldownDays = newValue}
  }
  /// Returns true if `newDeviceCooldownDays` has been explicitly set.
  var hasNewDeviceCooldownDays: Bool {return self._newDeviceCooldownDays != nil}
  /// Clears the value of `newDeviceCooldownDays`. Subsequent reads from it will return its default value.
  mutating func clearNewDeviceCooldownDays() {self._newDeviceCooldownDays = nil}

  var defaultPasswordResetProbationDays: UInt32 {
    get {return _defaultPasswordResetProbationDays ?? 0}
    set {_defaultPasswordResetProbationDays = newValue}
  }
  /// Returns true if `defaultPasswordResetProbationDays` has been explicitly set.
  var hasDefaultPasswordResetProbationDays: Bool {return self._defaultPasswordResetProbationDays != nil}
  /// Clears the value of `defaultPasswordResetProbationDays`. Subsequent reads from it will return its default value.
  mutating func clearDefaultPasswordResetProbationDays() {self._defaultPasswordResetProbationDays = nil}

  var passwordResetProbationDays: UInt32 {
    get {return _passwordResetProbationDays ?? 0}
    set {_passwordResetProbationDays = newValue}
  }
  /// Returns true if `passwordResetProbationDays` has been explicitly set.
  var hasPasswordResetProbationDays: Bool {return self._passwordResetProbationDays != nil}
  /// Clears the value of `passwordResetProbationDays`. Subsequent reads from it will return its default value.
  mutating func clearPasswordResetProbationDays() {self._passwordResetProbationDays = nil}

  var defaultEmailChangeProbationDays: UInt32 {
    get {return _defaultEmailChangeProbationDays ?? 0}
    set {_defaultEmailChangeProbationDays = newValue}
  }
  /// Returns true if `defaultEmailChangeProbationDays` has been explicitly set.
  var hasDefaultEmailChangeProbationDays: Bool {return self._defaultEmailChangeProbationDays != nil}
  /// Clears the value of `defaultEmailChangeProbationDays`. Subsequent reads from it will return its default value.
  mutating func clearDefaultEmailChangeProbationDays() {self._defaultEmailChangeProbationDays = nil}

  var emailChangeProbationDays: UInt32 {
    get {return _emailChangeProbationDays ?? 0}
    set {_emailChangeProbationDays = newValue}
  }
  /// Returns true if `emailChangeProbationDays` has been explicitly set.
  var hasEmailChangeProbationDays: Bool {return self._emailChangeProbationDays != nil}
  /// Clears the value of `emailChangeProbationDays`. Subsequent reads from it will return its default value.
  mutating func clearEmailChangeProbationDays() {self._emailChangeProbationDays = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _response: UInt32? = nil
  fileprivate var _tradeRequestID: UInt32? = nil
  fileprivate var _otherSteamid: UInt64? = nil
  fileprivate var _steamguardRequiredDays: UInt32? = nil
  fileprivate var _newDeviceCooldownDays: UInt32? = nil
  fileprivate var _defaultPasswordResetProbationDays: UInt32? = nil
  fileprivate var _passwordResetProbationDays: UInt32? = nil
  fileprivate var _defaultEmailChangeProbationDays: UInt32? = nil
  fileprivate var _emailChangeProbationDays: UInt32? = nil
}

struct CMsgTrading_CancelTradeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var otherSteamid: UInt64 {
    get {return _otherSteamid ?? 0}
    set {_otherSteamid = newValue}
  }
  /// Returns true if `otherSteamid` has been explicitly set.
  var hasOtherSteamid: Bool {return self._otherSteamid != nil}
  /// Clears the value of `otherSteamid`. Subsequent reads from it will return its default value.
  mutating func clearOtherSteamid() {self._otherSteamid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _otherSteamid: UInt64? = nil
}

struct CMsgTrading_StartSession {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var otherSteamid: UInt64 {
    get {return _otherSteamid ?? 0}
    set {_otherSteamid = newValue}
  }
  /// Returns true if `otherSteamid` has been explicitly set.
  var hasOtherSteamid: Bool {return self._otherSteamid != nil}
  /// Clears the value of `otherSteamid`. Subsequent reads from it will return its default value.
  mutating func clearOtherSteamid() {self._otherSteamid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _otherSteamid: UInt64? = nil
}

struct CMsgClientGetCDNAuthToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var depotID: UInt32 {
    get {return _depotID ?? 0}
    set {_depotID = newValue}
  }
  /// Returns true if `depotID` has been explicitly set.
  var hasDepotID: Bool {return self._depotID != nil}
  /// Clears the value of `depotID`. Subsequent reads from it will return its default value.
  mutating func clearDepotID() {self._depotID = nil}

  var hostName: String {
    get {return _hostName ?? String()}
    set {_hostName = newValue}
  }
  /// Returns true if `hostName` has been explicitly set.
  var hasHostName: Bool {return self._hostName != nil}
  /// Clears the value of `hostName`. Subsequent reads from it will return its default value.
  mutating func clearHostName() {self._hostName = nil}

  var appID: UInt32 {
    get {return _appID ?? 0}
    set {_appID = newValue}
  }
  /// Returns true if `appID` has been explicitly set.
  var hasAppID: Bool {return self._appID != nil}
  /// Clears the value of `appID`. Subsequent reads from it will return its default value.
  mutating func clearAppID() {self._appID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _depotID: UInt32? = nil
  fileprivate var _hostName: String? = nil
  fileprivate var _appID: UInt32? = nil
}

struct CMsgClientGetDepotDecryptionKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var depotID: UInt32 {
    get {return _depotID ?? 0}
    set {_depotID = newValue}
  }
  /// Returns true if `depotID` has been explicitly set.
  var hasDepotID: Bool {return self._depotID != nil}
  /// Clears the value of `depotID`. Subsequent reads from it will return its default value.
  mutating func clearDepotID() {self._depotID = nil}

  var appID: UInt32 {
    get {return _appID ?? 0}
    set {_appID = newValue}
  }
  /// Returns true if `appID` has been explicitly set.
  var hasAppID: Bool {return self._appID != nil}
  /// Clears the value of `appID`. Subsequent reads from it will return its default value.
  mutating func clearAppID() {self._appID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _depotID: UInt32? = nil
  fileprivate var _appID: UInt32? = nil
}

struct CMsgClientGetDepotDecryptionKeyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var depotID: UInt32 {
    get {return _depotID ?? 0}
    set {_depotID = newValue}
  }
  /// Returns true if `depotID` has been explicitly set.
  var hasDepotID: Bool {return self._depotID != nil}
  /// Clears the value of `depotID`. Subsequent reads from it will return its default value.
  mutating func clearDepotID() {self._depotID = nil}

  var depotEncryptionKey: Data {
    get {return _depotEncryptionKey ?? Data()}
    set {_depotEncryptionKey = newValue}
  }
  /// Returns true if `depotEncryptionKey` has been explicitly set.
  var hasDepotEncryptionKey: Bool {return self._depotEncryptionKey != nil}
  /// Clears the value of `depotEncryptionKey`. Subsequent reads from it will return its default value.
  mutating func clearDepotEncryptionKey() {self._depotEncryptionKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: Int32? = nil
  fileprivate var _depotID: UInt32? = nil
  fileprivate var _depotEncryptionKey: Data? = nil
}

struct CMsgClientCheckAppBetaPassword {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: UInt32 {
    get {return _appID ?? 0}
    set {_appID = newValue}
  }
  /// Returns true if `appID` has been explicitly set.
  var hasAppID: Bool {return self._appID != nil}
  /// Clears the value of `appID`. Subsequent reads from it will return its default value.
  mutating func clearAppID() {self._appID = nil}

  var betapassword: String {
    get {return _betapassword ?? String()}
    set {_betapassword = newValue}
  }
  /// Returns true if `betapassword` has been explicitly set.
  var hasBetapassword: Bool {return self._betapassword != nil}
  /// Clears the value of `betapassword`. Subsequent reads from it will return its default value.
  mutating func clearBetapassword() {self._betapassword = nil}

  var language: Int32 {
    get {return _language ?? 0}
    set {_language = newValue}
  }
  /// Returns true if `language` has been explicitly set.
  var hasLanguage: Bool {return self._language != nil}
  /// Clears the value of `language`. Subsequent reads from it will return its default value.
  mutating func clearLanguage() {self._language = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _appID: UInt32? = nil
  fileprivate var _betapassword: String? = nil
  fileprivate var _language: Int32? = nil
}

struct CMsgClientCheckAppBetaPasswordResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var betapasswords: [CMsgClientCheckAppBetaPasswordResponse.BetaPassword] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct BetaPassword {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var betaname: String {
      get {return _betaname ?? String()}
      set {_betaname = newValue}
    }
    /// Returns true if `betaname` has been explicitly set.
    var hasBetaname: Bool {return self._betaname != nil}
    /// Clears the value of `betaname`. Subsequent reads from it will return its default value.
    mutating func clearBetaname() {self._betaname = nil}

    var betapassword: String {
      get {return _betapassword ?? String()}
      set {_betapassword = newValue}
    }
    /// Returns true if `betapassword` has been explicitly set.
    var hasBetapassword: Bool {return self._betapassword != nil}
    /// Clears the value of `betapassword`. Subsequent reads from it will return its default value.
    mutating func clearBetapassword() {self._betapassword = nil}

    var betadescription: String {
      get {return _betadescription ?? String()}
      set {_betadescription = newValue}
    }
    /// Returns true if `betadescription` has been explicitly set.
    var hasBetadescription: Bool {return self._betadescription != nil}
    /// Clears the value of `betadescription`. Subsequent reads from it will return its default value.
    mutating func clearBetadescription() {self._betadescription = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _betaname: String? = nil
    fileprivate var _betapassword: String? = nil
    fileprivate var _betadescription: String? = nil
  }

  init() {}

  fileprivate var _eresult: Int32? = nil
}

struct CMsgClientUpdateAppJobReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: UInt32 {
    get {return _storage._appID ?? 0}
    set {_uniqueStorage()._appID = newValue}
  }
  /// Returns true if `appID` has been explicitly set.
  var hasAppID: Bool {return _storage._appID != nil}
  /// Clears the value of `appID`. Subsequent reads from it will return its default value.
  mutating func clearAppID() {_uniqueStorage()._appID = nil}

  var depotIds: [UInt32] {
    get {return _storage._depotIds}
    set {_uniqueStorage()._depotIds = newValue}
  }

  var appState: UInt32 {
    get {return _storage._appState ?? 0}
    set {_uniqueStorage()._appState = newValue}
  }
  /// Returns true if `appState` has been explicitly set.
  var hasAppState: Bool {return _storage._appState != nil}
  /// Clears the value of `appState`. Subsequent reads from it will return its default value.
  mutating func clearAppState() {_uniqueStorage()._appState = nil}

  var jobAppError: UInt32 {
    get {return _storage._jobAppError ?? 0}
    set {_uniqueStorage()._jobAppError = newValue}
  }
  /// Returns true if `jobAppError` has been explicitly set.
  var hasJobAppError: Bool {return _storage._jobAppError != nil}
  /// Clears the value of `jobAppError`. Subsequent reads from it will return its default value.
  mutating func clearJobAppError() {_uniqueStorage()._jobAppError = nil}

  var errorDetails: String {
    get {return _storage._errorDetails ?? String()}
    set {_uniqueStorage()._errorDetails = newValue}
  }
  /// Returns true if `errorDetails` has been explicitly set.
  var hasErrorDetails: Bool {return _storage._errorDetails != nil}
  /// Clears the value of `errorDetails`. Subsequent reads from it will return its default value.
  mutating func clearErrorDetails() {_uniqueStorage()._errorDetails = nil}

  var jobDuration: UInt32 {
    get {return _storage._jobDuration ?? 0}
    set {_uniqueStorage()._jobDuration = newValue}
  }
  /// Returns true if `jobDuration` has been explicitly set.
  var hasJobDuration: Bool {return _storage._jobDuration != nil}
  /// Clears the value of `jobDuration`. Subsequent reads from it will return its default value.
  mutating func clearJobDuration() {_uniqueStorage()._jobDuration = nil}

  var filesValidationFailed: UInt32 {
    get {return _storage._filesValidationFailed ?? 0}
    set {_uniqueStorage()._filesValidationFailed = newValue}
  }
  /// Returns true if `filesValidationFailed` has been explicitly set.
  var hasFilesValidationFailed: Bool {return _storage._filesValidationFailed != nil}
  /// Clears the value of `filesValidationFailed`. Subsequent reads from it will return its default value.
  mutating func clearFilesValidationFailed() {_uniqueStorage()._filesValidationFailed = nil}

  var jobBytesDownloaded: UInt64 {
    get {return _storage._jobBytesDownloaded ?? 0}
    set {_uniqueStorage()._jobBytesDownloaded = newValue}
  }
  /// Returns true if `jobBytesDownloaded` has been explicitly set.
  var hasJobBytesDownloaded: Bool {return _storage._jobBytesDownloaded != nil}
  /// Clears the value of `jobBytesDownloaded`. Subsequent reads from it will return its default value.
  mutating func clearJobBytesDownloaded() {_uniqueStorage()._jobBytesDownloaded = nil}

  var jobBytesStaged: UInt64 {
    get {return _storage._jobBytesStaged ?? 0}
    set {_uniqueStorage()._jobBytesStaged = newValue}
  }
  /// Returns true if `jobBytesStaged` has been explicitly set.
  var hasJobBytesStaged: Bool {return _storage._jobBytesStaged != nil}
  /// Clears the value of `jobBytesStaged`. Subsequent reads from it will return its default value.
  mutating func clearJobBytesStaged() {_uniqueStorage()._jobBytesStaged = nil}

  var bytesComitted: UInt64 {
    get {return _storage._bytesComitted ?? 0}
    set {_uniqueStorage()._bytesComitted = newValue}
  }
  /// Returns true if `bytesComitted` has been explicitly set.
  var hasBytesComitted: Bool {return _storage._bytesComitted != nil}
  /// Clears the value of `bytesComitted`. Subsequent reads from it will return its default value.
  mutating func clearBytesComitted() {_uniqueStorage()._bytesComitted = nil}

  var startAppState: UInt32 {
    get {return _storage._startAppState ?? 0}
    set {_uniqueStorage()._startAppState = newValue}
  }
  /// Returns true if `startAppState` has been explicitly set.
  var hasStartAppState: Bool {return _storage._startAppState != nil}
  /// Clears the value of `startAppState`. Subsequent reads from it will return its default value.
  mutating func clearStartAppState() {_uniqueStorage()._startAppState = nil}

  var statsMachineID: UInt64 {
    get {return _storage._statsMachineID ?? 0}
    set {_uniqueStorage()._statsMachineID = newValue}
  }
  /// Returns true if `statsMachineID` has been explicitly set.
  var hasStatsMachineID: Bool {return _storage._statsMachineID != nil}
  /// Clears the value of `statsMachineID`. Subsequent reads from it will return its default value.
  mutating func clearStatsMachineID() {_uniqueStorage()._statsMachineID = nil}

  var branchName: String {
    get {return _storage._branchName ?? String()}
    set {_uniqueStorage()._branchName = newValue}
  }
  /// Returns true if `branchName` has been explicitly set.
  var hasBranchName: Bool {return _storage._branchName != nil}
  /// Clears the value of `branchName`. Subsequent reads from it will return its default value.
  mutating func clearBranchName() {_uniqueStorage()._branchName = nil}

  var totalBytesDownloaded: UInt64 {
    get {return _storage._totalBytesDownloaded ?? 0}
    set {_uniqueStorage()._totalBytesDownloaded = newValue}
  }
  /// Returns true if `totalBytesDownloaded` has been explicitly set.
  var hasTotalBytesDownloaded: Bool {return _storage._totalBytesDownloaded != nil}
  /// Clears the value of `totalBytesDownloaded`. Subsequent reads from it will return its default value.
  mutating func clearTotalBytesDownloaded() {_uniqueStorage()._totalBytesDownloaded = nil}

  var totalBytesStaged: UInt64 {
    get {return _storage._totalBytesStaged ?? 0}
    set {_uniqueStorage()._totalBytesStaged = newValue}
  }
  /// Returns true if `totalBytesStaged` has been explicitly set.
  var hasTotalBytesStaged: Bool {return _storage._totalBytesStaged != nil}
  /// Clears the value of `totalBytesStaged`. Subsequent reads from it will return its default value.
  mutating func clearTotalBytesStaged() {_uniqueStorage()._totalBytesStaged = nil}

  var totalBytesRestored: UInt64 {
    get {return _storage._totalBytesRestored ?? 0}
    set {_uniqueStorage()._totalBytesRestored = newValue}
  }
  /// Returns true if `totalBytesRestored` has been explicitly set.
  var hasTotalBytesRestored: Bool {return _storage._totalBytesRestored != nil}
  /// Clears the value of `totalBytesRestored`. Subsequent reads from it will return its default value.
  mutating func clearTotalBytesRestored() {_uniqueStorage()._totalBytesRestored = nil}

  var isBorrowed: Bool {
    get {return _storage._isBorrowed ?? false}
    set {_uniqueStorage()._isBorrowed = newValue}
  }
  /// Returns true if `isBorrowed` has been explicitly set.
  var hasIsBorrowed: Bool {return _storage._isBorrowed != nil}
  /// Clears the value of `isBorrowed`. Subsequent reads from it will return its default value.
  mutating func clearIsBorrowed() {_uniqueStorage()._isBorrowed = nil}

  var isFreeWeekend: Bool {
    get {return _storage._isFreeWeekend ?? false}
    set {_uniqueStorage()._isFreeWeekend = newValue}
  }
  /// Returns true if `isFreeWeekend` has been explicitly set.
  var hasIsFreeWeekend: Bool {return _storage._isFreeWeekend != nil}
  /// Clears the value of `isFreeWeekend`. Subsequent reads from it will return its default value.
  mutating func clearIsFreeWeekend() {_uniqueStorage()._isFreeWeekend = nil}

  var totalBytesLegacy: UInt64 {
    get {return _storage._totalBytesLegacy ?? 0}
    set {_uniqueStorage()._totalBytesLegacy = newValue}
  }
  /// Returns true if `totalBytesLegacy` has been explicitly set.
  var hasTotalBytesLegacy: Bool {return _storage._totalBytesLegacy != nil}
  /// Clears the value of `totalBytesLegacy`. Subsequent reads from it will return its default value.
  mutating func clearTotalBytesLegacy() {_uniqueStorage()._totalBytesLegacy = nil}

  var totalBytesPatched: UInt64 {
    get {return _storage._totalBytesPatched ?? 0}
    set {_uniqueStorage()._totalBytesPatched = newValue}
  }
  /// Returns true if `totalBytesPatched` has been explicitly set.
  var hasTotalBytesPatched: Bool {return _storage._totalBytesPatched != nil}
  /// Clears the value of `totalBytesPatched`. Subsequent reads from it will return its default value.
  mutating func clearTotalBytesPatched() {_uniqueStorage()._totalBytesPatched = nil}

  var totalBytesSaved: UInt64 {
    get {return _storage._totalBytesSaved ?? 0}
    set {_uniqueStorage()._totalBytesSaved = newValue}
  }
  /// Returns true if `totalBytesSaved` has been explicitly set.
  var hasTotalBytesSaved: Bool {return _storage._totalBytesSaved != nil}
  /// Clears the value of `totalBytesSaved`. Subsequent reads from it will return its default value.
  mutating func clearTotalBytesSaved() {_uniqueStorage()._totalBytesSaved = nil}

  var cellID: UInt32 {
    get {return _storage._cellID ?? 0}
    set {_uniqueStorage()._cellID = newValue}
  }
  /// Returns true if `cellID` has been explicitly set.
  var hasCellID: Bool {return _storage._cellID != nil}
  /// Clears the value of `cellID`. Subsequent reads from it will return its default value.
  mutating func clearCellID() {_uniqueStorage()._cellID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CMsgClientDPContentStatsReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var statsMachineID: UInt64 {
    get {return _statsMachineID ?? 0}
    set {_statsMachineID = newValue}
  }
  /// Returns true if `statsMachineID` has been explicitly set.
  var hasStatsMachineID: Bool {return self._statsMachineID != nil}
  /// Clears the value of `statsMachineID`. Subsequent reads from it will return its default value.
  mutating func clearStatsMachineID() {self._statsMachineID = nil}

  var countryCode: String {
    get {return _countryCode ?? String()}
    set {_countryCode = newValue}
  }
  /// Returns true if `countryCode` has been explicitly set.
  var hasCountryCode: Bool {return self._countryCode != nil}
  /// Clears the value of `countryCode`. Subsequent reads from it will return its default value.
  mutating func clearCountryCode() {self._countryCode = nil}

  var osType: Int32 {
    get {return _osType ?? 0}
    set {_osType = newValue}
  }
  /// Returns true if `osType` has been explicitly set.
  var hasOsType: Bool {return self._osType != nil}
  /// Clears the value of `osType`. Subsequent reads from it will return its default value.
  mutating func clearOsType() {self._osType = nil}

  var language: Int32 {
    get {return _language ?? 0}
    set {_language = newValue}
  }
  /// Returns true if `language` has been explicitly set.
  var hasLanguage: Bool {return self._language != nil}
  /// Clears the value of `language`. Subsequent reads from it will return its default value.
  mutating func clearLanguage() {self._language = nil}

  var numInstallFolders: UInt32 {
    get {return _numInstallFolders ?? 0}
    set {_numInstallFolders = newValue}
  }
  /// Returns true if `numInstallFolders` has been explicitly set.
  var hasNumInstallFolders: Bool {return self._numInstallFolders != nil}
  /// Clears the value of `numInstallFolders`. Subsequent reads from it will return its default value.
  mutating func clearNumInstallFolders() {self._numInstallFolders = nil}

  var numInstalledGames: UInt32 {
    get {return _numInstalledGames ?? 0}
    set {_numInstalledGames = newValue}
  }
  /// Returns true if `numInstalledGames` has been explicitly set.
  var hasNumInstalledGames: Bool {return self._numInstalledGames != nil}
  /// Clears the value of `numInstalledGames`. Subsequent reads from it will return its default value.
  mutating func clearNumInstalledGames() {self._numInstalledGames = nil}

  var sizeInstalledGames: UInt64 {
    get {return _sizeInstalledGames ?? 0}
    set {_sizeInstalledGames = newValue}
  }
  /// Returns true if `sizeInstalledGames` has been explicitly set.
  var hasSizeInstalledGames: Bool {return self._sizeInstalledGames != nil}
  /// Clears the value of `sizeInstalledGames`. Subsequent reads from it will return its default value.
  mutating func clearSizeInstalledGames() {self._sizeInstalledGames = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _statsMachineID: UInt64? = nil
  fileprivate var _countryCode: String? = nil
  fileprivate var _osType: Int32? = nil
  fileprivate var _language: Int32? = nil
  fileprivate var _numInstallFolders: UInt32? = nil
  fileprivate var _numInstalledGames: UInt32? = nil
  fileprivate var _sizeInstalledGames: UInt64? = nil
}

struct CMsgClientGetCDNAuthTokenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: UInt32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var token: String {
    get {return _token ?? String()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  mutating func clearToken() {self._token = nil}

  var expirationTime: UInt32 {
    get {return _expirationTime ?? 0}
    set {_expirationTime = newValue}
  }
  /// Returns true if `expirationTime` has been explicitly set.
  var hasExpirationTime: Bool {return self._expirationTime != nil}
  /// Clears the value of `expirationTime`. Subsequent reads from it will return its default value.
  mutating func clearExpirationTime() {self._expirationTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: UInt32? = nil
  fileprivate var _token: String? = nil
  fileprivate var _expirationTime: UInt32? = nil
}

struct CMsgDownloadRateStatistics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cellID: UInt32 {
    get {return _cellID ?? 0}
    set {_cellID = newValue}
  }
  /// Returns true if `cellID` has been explicitly set.
  var hasCellID: Bool {return self._cellID != nil}
  /// Clears the value of `cellID`. Subsequent reads from it will return its default value.
  mutating func clearCellID() {self._cellID = nil}

  var stats: [CMsgDownloadRateStatistics.StatsInfo] = []

  var throttlingKbps: UInt32 {
    get {return _throttlingKbps ?? 0}
    set {_throttlingKbps = newValue}
  }
  /// Returns true if `throttlingKbps` has been explicitly set.
  var hasThrottlingKbps: Bool {return self._throttlingKbps != nil}
  /// Clears the value of `throttlingKbps`. Subsequent reads from it will return its default value.
  mutating func clearThrottlingKbps() {self._throttlingKbps = nil}

  var steamRealm: UInt32 {
    get {return _steamRealm ?? 0}
    set {_steamRealm = newValue}
  }
  /// Returns true if `steamRealm` has been explicitly set.
  var hasSteamRealm: Bool {return self._steamRealm != nil}
  /// Clears the value of `steamRealm`. Subsequent reads from it will return its default value.
  mutating func clearSteamRealm() {self._steamRealm = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct StatsInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sourceType: UInt32 {
      get {return _sourceType ?? 0}
      set {_sourceType = newValue}
    }
    /// Returns true if `sourceType` has been explicitly set.
    var hasSourceType: Bool {return self._sourceType != nil}
    /// Clears the value of `sourceType`. Subsequent reads from it will return its default value.
    mutating func clearSourceType() {self._sourceType = nil}

    var sourceID: UInt32 {
      get {return _sourceID ?? 0}
      set {_sourceID = newValue}
    }
    /// Returns true if `sourceID` has been explicitly set.
    var hasSourceID: Bool {return self._sourceID != nil}
    /// Clears the value of `sourceID`. Subsequent reads from it will return its default value.
    mutating func clearSourceID() {self._sourceID = nil}

    var seconds: UInt32 {
      get {return _seconds ?? 0}
      set {_seconds = newValue}
    }
    /// Returns true if `seconds` has been explicitly set.
    var hasSeconds: Bool {return self._seconds != nil}
    /// Clears the value of `seconds`. Subsequent reads from it will return its default value.
    mutating func clearSeconds() {self._seconds = nil}

    var bytes: UInt64 {
      get {return _bytes ?? 0}
      set {_bytes = newValue}
    }
    /// Returns true if `bytes` has been explicitly set.
    var hasBytes: Bool {return self._bytes != nil}
    /// Clears the value of `bytes`. Subsequent reads from it will return its default value.
    mutating func clearBytes() {self._bytes = nil}

    var hostName: String {
      get {return _hostName ?? String()}
      set {_hostName = newValue}
    }
    /// Returns true if `hostName` has been explicitly set.
    var hasHostName: Bool {return self._hostName != nil}
    /// Clears the value of `hostName`. Subsequent reads from it will return its default value.
    mutating func clearHostName() {self._hostName = nil}

    var microseconds: UInt64 {
      get {return _microseconds ?? 0}
      set {_microseconds = newValue}
    }
    /// Returns true if `microseconds` has been explicitly set.
    var hasMicroseconds: Bool {return self._microseconds != nil}
    /// Clears the value of `microseconds`. Subsequent reads from it will return its default value.
    mutating func clearMicroseconds() {self._microseconds = nil}

    var usedIpv6: Bool {
      get {return _usedIpv6 ?? false}
      set {_usedIpv6 = newValue}
    }
    /// Returns true if `usedIpv6` has been explicitly set.
    var hasUsedIpv6: Bool {return self._usedIpv6 != nil}
    /// Clears the value of `usedIpv6`. Subsequent reads from it will return its default value.
    mutating func clearUsedIpv6() {self._usedIpv6 = nil}

    var proxied: Bool {
      get {return _proxied ?? false}
      set {_proxied = newValue}
    }
    /// Returns true if `proxied` has been explicitly set.
    var hasProxied: Bool {return self._proxied != nil}
    /// Clears the value of `proxied`. Subsequent reads from it will return its default value.
    mutating func clearProxied() {self._proxied = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _sourceType: UInt32? = nil
    fileprivate var _sourceID: UInt32? = nil
    fileprivate var _seconds: UInt32? = nil
    fileprivate var _bytes: UInt64? = nil
    fileprivate var _hostName: String? = nil
    fileprivate var _microseconds: UInt64? = nil
    fileprivate var _usedIpv6: Bool? = nil
    fileprivate var _proxied: Bool? = nil
  }

  init() {}

  fileprivate var _cellID: UInt32? = nil
  fileprivate var _throttlingKbps: UInt32? = nil
  fileprivate var _steamRealm: UInt32? = nil
}

struct CMsgClientRequestAccountData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountOrEmail: String {
    get {return _accountOrEmail ?? String()}
    set {_accountOrEmail = newValue}
  }
  /// Returns true if `accountOrEmail` has been explicitly set.
  var hasAccountOrEmail: Bool {return self._accountOrEmail != nil}
  /// Clears the value of `accountOrEmail`. Subsequent reads from it will return its default value.
  mutating func clearAccountOrEmail() {self._accountOrEmail = nil}

  var action: UInt32 {
    get {return _action ?? 0}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  mutating func clearAction() {self._action = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accountOrEmail: String? = nil
  fileprivate var _action: UInt32? = nil
}

struct CMsgClientRequestAccountDataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var action: UInt32 {
    get {return _action ?? 0}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  mutating func clearAction() {self._action = nil}

  var eresult: UInt32 {
    get {return _eresult ?? 0}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var accountName: String {
    get {return _accountName ?? String()}
    set {_accountName = newValue}
  }
  /// Returns true if `accountName` has been explicitly set.
  var hasAccountName: Bool {return self._accountName != nil}
  /// Clears the value of `accountName`. Subsequent reads from it will return its default value.
  mutating func clearAccountName() {self._accountName = nil}

  var ctMatches: UInt32 {
    get {return _ctMatches ?? 0}
    set {_ctMatches = newValue}
  }
  /// Returns true if `ctMatches` has been explicitly set.
  var hasCtMatches: Bool {return self._ctMatches != nil}
  /// Clears the value of `ctMatches`. Subsequent reads from it will return its default value.
  mutating func clearCtMatches() {self._ctMatches = nil}

  var accountNameSuggestion1: String {
    get {return _accountNameSuggestion1 ?? String()}
    set {_accountNameSuggestion1 = newValue}
  }
  /// Returns true if `accountNameSuggestion1` has been explicitly set.
  var hasAccountNameSuggestion1: Bool {return self._accountNameSuggestion1 != nil}
  /// Clears the value of `accountNameSuggestion1`. Subsequent reads from it will return its default value.
  mutating func clearAccountNameSuggestion1() {self._accountNameSuggestion1 = nil}

  var accountNameSuggestion2: String {
    get {return _accountNameSuggestion2 ?? String()}
    set {_accountNameSuggestion2 = newValue}
  }
  /// Returns true if `accountNameSuggestion2` has been explicitly set.
  var hasAccountNameSuggestion2: Bool {return self._accountNameSuggestion2 != nil}
  /// Clears the value of `accountNameSuggestion2`. Subsequent reads from it will return its default value.
  mutating func clearAccountNameSuggestion2() {self._accountNameSuggestion2 = nil}

  var accountNameSuggestion3: String {
    get {return _accountNameSuggestion3 ?? String()}
    set {_accountNameSuggestion3 = newValue}
  }
  /// Returns true if `accountNameSuggestion3` has been explicitly set.
  var hasAccountNameSuggestion3: Bool {return self._accountNameSuggestion3 != nil}
  /// Clears the value of `accountNameSuggestion3`. Subsequent reads from it will return its default value.
  mutating func clearAccountNameSuggestion3() {self._accountNameSuggestion3 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _action: UInt32? = nil
  fileprivate var _eresult: UInt32? = nil
  fileprivate var _accountName: String? = nil
  fileprivate var _ctMatches: UInt32? = nil
  fileprivate var _accountNameSuggestion1: String? = nil
  fileprivate var _accountNameSuggestion2: String? = nil
  fileprivate var _accountNameSuggestion3: String? = nil
}

struct CMsgClientUGSGetGlobalStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gameid: UInt64 {
    get {return _gameid ?? 0}
    set {_gameid = newValue}
  }
  /// Returns true if `gameid` has been explicitly set.
  var hasGameid: Bool {return self._gameid != nil}
  /// Clears the value of `gameid`. Subsequent reads from it will return its default value.
  mutating func clearGameid() {self._gameid = nil}

  var historyDaysRequested: UInt32 {
    get {return _historyDaysRequested ?? 0}
    set {_historyDaysRequested = newValue}
  }
  /// Returns true if `historyDaysRequested` has been explicitly set.
  var hasHistoryDaysRequested: Bool {return self._historyDaysRequested != nil}
  /// Clears the value of `historyDaysRequested`. Subsequent reads from it will return its default value.
  mutating func clearHistoryDaysRequested() {self._historyDaysRequested = nil}

  var timeLastRequested: UInt32 {
    get {return _timeLastRequested ?? 0}
    set {_timeLastRequested = newValue}
  }
  /// Returns true if `timeLastRequested` has been explicitly set.
  var hasTimeLastRequested: Bool {return self._timeLastRequested != nil}
  /// Clears the value of `timeLastRequested`. Subsequent reads from it will return its default value.
  mutating func clearTimeLastRequested() {self._timeLastRequested = nil}

  var firstDayCached: UInt32 {
    get {return _firstDayCached ?? 0}
    set {_firstDayCached = newValue}
  }
  /// Returns true if `firstDayCached` has been explicitly set.
  var hasFirstDayCached: Bool {return self._firstDayCached != nil}
  /// Clears the value of `firstDayCached`. Subsequent reads from it will return its default value.
  mutating func clearFirstDayCached() {self._firstDayCached = nil}

  var daysCached: UInt32 {
    get {return _daysCached ?? 0}
    set {_daysCached = newValue}
  }
  /// Returns true if `daysCached` has been explicitly set.
  var hasDaysCached: Bool {return self._daysCached != nil}
  /// Clears the value of `daysCached`. Subsequent reads from it will return its default value.
  mutating func clearDaysCached() {self._daysCached = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _gameid: UInt64? = nil
  fileprivate var _historyDaysRequested: UInt32? = nil
  fileprivate var _timeLastRequested: UInt32? = nil
  fileprivate var _firstDayCached: UInt32? = nil
  fileprivate var _daysCached: UInt32? = nil
}

struct CMsgClientUGSGetGlobalStatsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var timestamp: UInt32 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var dayCurrent: Int32 {
    get {return _dayCurrent ?? 0}
    set {_dayCurrent = newValue}
  }
  /// Returns true if `dayCurrent` has been explicitly set.
  var hasDayCurrent: Bool {return self._dayCurrent != nil}
  /// Clears the value of `dayCurrent`. Subsequent reads from it will return its default value.
  mutating func clearDayCurrent() {self._dayCurrent = nil}

  var days: [CMsgClientUGSGetGlobalStatsResponse.Day] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Day {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dayID: UInt32 {
      get {return _dayID ?? 0}
      set {_dayID = newValue}
    }
    /// Returns true if `dayID` has been explicitly set.
    var hasDayID: Bool {return self._dayID != nil}
    /// Clears the value of `dayID`. Subsequent reads from it will return its default value.
    mutating func clearDayID() {self._dayID = nil}

    var stats: [CMsgClientUGSGetGlobalStatsResponse.Day.Stat] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Stat {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var statID: Int32 {
        get {return _statID ?? 0}
        set {_statID = newValue}
      }
      /// Returns true if `statID` has been explicitly set.
      var hasStatID: Bool {return self._statID != nil}
      /// Clears the value of `statID`. Subsequent reads from it will return its default value.
      mutating func clearStatID() {self._statID = nil}

      var data: Int64 {
        get {return _data ?? 0}
        set {_data = newValue}
      }
      /// Returns true if `data` has been explicitly set.
      var hasData: Bool {return self._data != nil}
      /// Clears the value of `data`. Subsequent reads from it will return its default value.
      mutating func clearData() {self._data = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _statID: Int32? = nil
      fileprivate var _data: Int64? = nil
    }

    init() {}

    fileprivate var _dayID: UInt32? = nil
  }

  init() {}

  fileprivate var _eresult: Int32? = nil
  fileprivate var _timestamp: UInt32? = nil
  fileprivate var _dayCurrent: Int32? = nil
}

struct CMsgClientRedeemGuestPass {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var guestPassID: UInt64 {
    get {return _guestPassID ?? 0}
    set {_guestPassID = newValue}
  }
  /// Returns true if `guestPassID` has been explicitly set.
  var hasGuestPassID: Bool {return self._guestPassID != nil}
  /// Clears the value of `guestPassID`. Subsequent reads from it will return its default value.
  mutating func clearGuestPassID() {self._guestPassID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _guestPassID: UInt64? = nil
}

struct CMsgClientRedeemGuestPassResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: UInt32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var packageID: UInt32 {
    get {return _packageID ?? 0}
    set {_packageID = newValue}
  }
  /// Returns true if `packageID` has been explicitly set.
  var hasPackageID: Bool {return self._packageID != nil}
  /// Clears the value of `packageID`. Subsequent reads from it will return its default value.
  mutating func clearPackageID() {self._packageID = nil}

  var mustOwnAppid: UInt32 {
    get {return _mustOwnAppid ?? 0}
    set {_mustOwnAppid = newValue}
  }
  /// Returns true if `mustOwnAppid` has been explicitly set.
  var hasMustOwnAppid: Bool {return self._mustOwnAppid != nil}
  /// Clears the value of `mustOwnAppid`. Subsequent reads from it will return its default value.
  mutating func clearMustOwnAppid() {self._mustOwnAppid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: UInt32? = nil
  fileprivate var _packageID: UInt32? = nil
  fileprivate var _mustOwnAppid: UInt32? = nil
}

struct CMsgClientGetClanActivityCounts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var steamidClans: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CMsgClientGetClanActivityCountsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: UInt32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: UInt32? = nil
}

struct CMsgClientOGSReportString {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accumulated: Bool {
    get {return _accumulated ?? false}
    set {_accumulated = newValue}
  }
  /// Returns true if `accumulated` has been explicitly set.
  var hasAccumulated: Bool {return self._accumulated != nil}
  /// Clears the value of `accumulated`. Subsequent reads from it will return its default value.
  mutating func clearAccumulated() {self._accumulated = nil}

  var sessionid: UInt64 {
    get {return _sessionid ?? 0}
    set {_sessionid = newValue}
  }
  /// Returns true if `sessionid` has been explicitly set.
  var hasSessionid: Bool {return self._sessionid != nil}
  /// Clears the value of `sessionid`. Subsequent reads from it will return its default value.
  mutating func clearSessionid() {self._sessionid = nil}

  var severity: Int32 {
    get {return _severity ?? 0}
    set {_severity = newValue}
  }
  /// Returns true if `severity` has been explicitly set.
  var hasSeverity: Bool {return self._severity != nil}
  /// Clears the value of `severity`. Subsequent reads from it will return its default value.
  mutating func clearSeverity() {self._severity = nil}

  var formatter: String {
    get {return _formatter ?? String()}
    set {_formatter = newValue}
  }
  /// Returns true if `formatter` has been explicitly set.
  var hasFormatter: Bool {return self._formatter != nil}
  /// Clears the value of `formatter`. Subsequent reads from it will return its default value.
  mutating func clearFormatter() {self._formatter = nil}

  var varargs: Data {
    get {return _varargs ?? Data()}
    set {_varargs = newValue}
  }
  /// Returns true if `varargs` has been explicitly set.
  var hasVarargs: Bool {return self._varargs != nil}
  /// Clears the value of `varargs`. Subsequent reads from it will return its default value.
  mutating func clearVarargs() {self._varargs = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accumulated: Bool? = nil
  fileprivate var _sessionid: UInt64? = nil
  fileprivate var _severity: Int32? = nil
  fileprivate var _formatter: String? = nil
  fileprivate var _varargs: Data? = nil
}

struct CMsgClientOGSReportBug {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionid: UInt64 {
    get {return _sessionid ?? 0}
    set {_sessionid = newValue}
  }
  /// Returns true if `sessionid` has been explicitly set.
  var hasSessionid: Bool {return self._sessionid != nil}
  /// Clears the value of `sessionid`. Subsequent reads from it will return its default value.
  mutating func clearSessionid() {self._sessionid = nil}

  var bugtext: String {
    get {return _bugtext ?? String()}
    set {_bugtext = newValue}
  }
  /// Returns true if `bugtext` has been explicitly set.
  var hasBugtext: Bool {return self._bugtext != nil}
  /// Clears the value of `bugtext`. Subsequent reads from it will return its default value.
  mutating func clearBugtext() {self._bugtext = nil}

  var screenshot: Data {
    get {return _screenshot ?? Data()}
    set {_screenshot = newValue}
  }
  /// Returns true if `screenshot` has been explicitly set.
  var hasScreenshot: Bool {return self._screenshot != nil}
  /// Clears the value of `screenshot`. Subsequent reads from it will return its default value.
  mutating func clearScreenshot() {self._screenshot = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sessionid: UInt64? = nil
  fileprivate var _bugtext: String? = nil
  fileprivate var _screenshot: Data? = nil
}

struct CMsgClientSentLogs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CMsgGCClient {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appid: UInt32 {
    get {return _appid ?? 0}
    set {_appid = newValue}
  }
  /// Returns true if `appid` has been explicitly set.
  var hasAppid: Bool {return self._appid != nil}
  /// Clears the value of `appid`. Subsequent reads from it will return its default value.
  mutating func clearAppid() {self._appid = nil}

  var msgtype: UInt32 {
    get {return _msgtype ?? 0}
    set {_msgtype = newValue}
  }
  /// Returns true if `msgtype` has been explicitly set.
  var hasMsgtype: Bool {return self._msgtype != nil}
  /// Clears the value of `msgtype`. Subsequent reads from it will return its default value.
  mutating func clearMsgtype() {self._msgtype = nil}

  var payload: Data {
    get {return _payload ?? Data()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  var steamid: UInt64 {
    get {return _steamid ?? 0}
    set {_steamid = newValue}
  }
  /// Returns true if `steamid` has been explicitly set.
  var hasSteamid: Bool {return self._steamid != nil}
  /// Clears the value of `steamid`. Subsequent reads from it will return its default value.
  mutating func clearSteamid() {self._steamid = nil}

  var gcname: String {
    get {return _gcname ?? String()}
    set {_gcname = newValue}
  }
  /// Returns true if `gcname` has been explicitly set.
  var hasGcname: Bool {return self._gcname != nil}
  /// Clears the value of `gcname`. Subsequent reads from it will return its default value.
  mutating func clearGcname() {self._gcname = nil}

  var ip: UInt32 {
    get {return _ip ?? 0}
    set {_ip = newValue}
  }
  /// Returns true if `ip` has been explicitly set.
  var hasIp: Bool {return self._ip != nil}
  /// Clears the value of `ip`. Subsequent reads from it will return its default value.
  mutating func clearIp() {self._ip = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _appid: UInt32? = nil
  fileprivate var _msgtype: UInt32? = nil
  fileprivate var _payload: Data? = nil
  fileprivate var _steamid: UInt64? = nil
  fileprivate var _gcname: String? = nil
  fileprivate var _ip: UInt32? = nil
}

struct CMsgClientRequestFreeLicense {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appids: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CMsgClientRequestFreeLicenseResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: UInt32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var grantedPackageids: [UInt32] = []

  var grantedAppids: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: UInt32? = nil
}

struct CMsgDRMDownloadRequestWithCrashData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var downloadFlags: UInt32 {
    get {return _downloadFlags ?? 0}
    set {_downloadFlags = newValue}
  }
  /// Returns true if `downloadFlags` has been explicitly set.
  var hasDownloadFlags: Bool {return self._downloadFlags != nil}
  /// Clears the value of `downloadFlags`. Subsequent reads from it will return its default value.
  mutating func clearDownloadFlags() {self._downloadFlags = nil}

  var downloadTypesKnown: UInt32 {
    get {return _downloadTypesKnown ?? 0}
    set {_downloadTypesKnown = newValue}
  }
  /// Returns true if `downloadTypesKnown` has been explicitly set.
  var hasDownloadTypesKnown: Bool {return self._downloadTypesKnown != nil}
  /// Clears the value of `downloadTypesKnown`. Subsequent reads from it will return its default value.
  mutating func clearDownloadTypesKnown() {self._downloadTypesKnown = nil}

  var guidDrm: Data {
    get {return _guidDrm ?? Data()}
    set {_guidDrm = newValue}
  }
  /// Returns true if `guidDrm` has been explicitly set.
  var hasGuidDrm: Bool {return self._guidDrm != nil}
  /// Clears the value of `guidDrm`. Subsequent reads from it will return its default value.
  mutating func clearGuidDrm() {self._guidDrm = nil}

  var guidSplit: Data {
    get {return _guidSplit ?? Data()}
    set {_guidSplit = newValue}
  }
  /// Returns true if `guidSplit` has been explicitly set.
  var hasGuidSplit: Bool {return self._guidSplit != nil}
  /// Clears the value of `guidSplit`. Subsequent reads from it will return its default value.
  mutating func clearGuidSplit() {self._guidSplit = nil}

  var guidMerge: Data {
    get {return _guidMerge ?? Data()}
    set {_guidMerge = newValue}
  }
  /// Returns true if `guidMerge` has been explicitly set.
  var hasGuidMerge: Bool {return self._guidMerge != nil}
  /// Clears the value of `guidMerge`. Subsequent reads from it will return its default value.
  mutating func clearGuidMerge() {self._guidMerge = nil}

  var moduleName: String {
    get {return _moduleName ?? String()}
    set {_moduleName = newValue}
  }
  /// Returns true if `moduleName` has been explicitly set.
  var hasModuleName: Bool {return self._moduleName != nil}
  /// Clears the value of `moduleName`. Subsequent reads from it will return its default value.
  mutating func clearModuleName() {self._moduleName = nil}

  var modulePath: String {
    get {return _modulePath ?? String()}
    set {_modulePath = newValue}
  }
  /// Returns true if `modulePath` has been explicitly set.
  var hasModulePath: Bool {return self._modulePath != nil}
  /// Clears the value of `modulePath`. Subsequent reads from it will return its default value.
  mutating func clearModulePath() {self._modulePath = nil}

  var crashData: Data {
    get {return _crashData ?? Data()}
    set {_crashData = newValue}
  }
  /// Returns true if `crashData` has been explicitly set.
  var hasCrashData: Bool {return self._crashData != nil}
  /// Clears the value of `crashData`. Subsequent reads from it will return its default value.
  mutating func clearCrashData() {self._crashData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _downloadFlags: UInt32? = nil
  fileprivate var _downloadTypesKnown: UInt32? = nil
  fileprivate var _guidDrm: Data? = nil
  fileprivate var _guidSplit: Data? = nil
  fileprivate var _guidMerge: Data? = nil
  fileprivate var _moduleName: String? = nil
  fileprivate var _modulePath: String? = nil
  fileprivate var _crashData: Data? = nil
}

struct CMsgDRMDownloadResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: UInt32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var appID: UInt32 {
    get {return _appID ?? 0}
    set {_appID = newValue}
  }
  /// Returns true if `appID` has been explicitly set.
  var hasAppID: Bool {return self._appID != nil}
  /// Clears the value of `appID`. Subsequent reads from it will return its default value.
  mutating func clearAppID() {self._appID = nil}

  var blobDownloadType: UInt32 {
    get {return _blobDownloadType ?? 0}
    set {_blobDownloadType = newValue}
  }
  /// Returns true if `blobDownloadType` has been explicitly set.
  var hasBlobDownloadType: Bool {return self._blobDownloadType != nil}
  /// Clears the value of `blobDownloadType`. Subsequent reads from it will return its default value.
  mutating func clearBlobDownloadType() {self._blobDownloadType = nil}

  var mergeGuid: Data {
    get {return _mergeGuid ?? Data()}
    set {_mergeGuid = newValue}
  }
  /// Returns true if `mergeGuid` has been explicitly set.
  var hasMergeGuid: Bool {return self._mergeGuid != nil}
  /// Clears the value of `mergeGuid`. Subsequent reads from it will return its default value.
  mutating func clearMergeGuid() {self._mergeGuid = nil}

  var downloadFileDfsIp: UInt32 {
    get {return _downloadFileDfsIp ?? 0}
    set {_downloadFileDfsIp = newValue}
  }
  /// Returns true if `downloadFileDfsIp` has been explicitly set.
  var hasDownloadFileDfsIp: Bool {return self._downloadFileDfsIp != nil}
  /// Clears the value of `downloadFileDfsIp`. Subsequent reads from it will return its default value.
  mutating func clearDownloadFileDfsIp() {self._downloadFileDfsIp = nil}

  var downloadFileDfsPort: UInt32 {
    get {return _downloadFileDfsPort ?? 0}
    set {_downloadFileDfsPort = newValue}
  }
  /// Returns true if `downloadFileDfsPort` has been explicitly set.
  var hasDownloadFileDfsPort: Bool {return self._downloadFileDfsPort != nil}
  /// Clears the value of `downloadFileDfsPort`. Subsequent reads from it will return its default value.
  mutating func clearDownloadFileDfsPort() {self._downloadFileDfsPort = nil}

  var downloadFileURL: String {
    get {return _downloadFileURL ?? String()}
    set {_downloadFileURL = newValue}
  }
  /// Returns true if `downloadFileURL` has been explicitly set.
  var hasDownloadFileURL: Bool {return self._downloadFileURL != nil}
  /// Clears the value of `downloadFileURL`. Subsequent reads from it will return its default value.
  mutating func clearDownloadFileURL() {self._downloadFileURL = nil}

  var modulePath: String {
    get {return _modulePath ?? String()}
    set {_modulePath = newValue}
  }
  /// Returns true if `modulePath` has been explicitly set.
  var hasModulePath: Bool {return self._modulePath != nil}
  /// Clears the value of `modulePath`. Subsequent reads from it will return its default value.
  mutating func clearModulePath() {self._modulePath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: UInt32? = nil
  fileprivate var _appID: UInt32? = nil
  fileprivate var _blobDownloadType: UInt32? = nil
  fileprivate var _mergeGuid: Data? = nil
  fileprivate var _downloadFileDfsIp: UInt32? = nil
  fileprivate var _downloadFileDfsPort: UInt32? = nil
  fileprivate var _downloadFileURL: String? = nil
  fileprivate var _modulePath: String? = nil
}

struct CMsgDRMFinalResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eResult: UInt32 {
    get {return _eResult ?? 2}
    set {_eResult = newValue}
  }
  /// Returns true if `eResult` has been explicitly set.
  var hasEResult: Bool {return self._eResult != nil}
  /// Clears the value of `eResult`. Subsequent reads from it will return its default value.
  mutating func clearEResult() {self._eResult = nil}

  var appID: UInt32 {
    get {return _appID ?? 0}
    set {_appID = newValue}
  }
  /// Returns true if `appID` has been explicitly set.
  var hasAppID: Bool {return self._appID != nil}
  /// Clears the value of `appID`. Subsequent reads from it will return its default value.
  mutating func clearAppID() {self._appID = nil}

  var blobDownloadType: UInt32 {
    get {return _blobDownloadType ?? 0}
    set {_blobDownloadType = newValue}
  }
  /// Returns true if `blobDownloadType` has been explicitly set.
  var hasBlobDownloadType: Bool {return self._blobDownloadType != nil}
  /// Clears the value of `blobDownloadType`. Subsequent reads from it will return its default value.
  mutating func clearBlobDownloadType() {self._blobDownloadType = nil}

  var errorDetail: UInt32 {
    get {return _errorDetail ?? 0}
    set {_errorDetail = newValue}
  }
  /// Returns true if `errorDetail` has been explicitly set.
  var hasErrorDetail: Bool {return self._errorDetail != nil}
  /// Clears the value of `errorDetail`. Subsequent reads from it will return its default value.
  mutating func clearErrorDetail() {self._errorDetail = nil}

  var mergeGuid: Data {
    get {return _mergeGuid ?? Data()}
    set {_mergeGuid = newValue}
  }
  /// Returns true if `mergeGuid` has been explicitly set.
  var hasMergeGuid: Bool {return self._mergeGuid != nil}
  /// Clears the value of `mergeGuid`. Subsequent reads from it will return its default value.
  mutating func clearMergeGuid() {self._mergeGuid = nil}

  var downloadFileDfsIp: UInt32 {
    get {return _downloadFileDfsIp ?? 0}
    set {_downloadFileDfsIp = newValue}
  }
  /// Returns true if `downloadFileDfsIp` has been explicitly set.
  var hasDownloadFileDfsIp: Bool {return self._downloadFileDfsIp != nil}
  /// Clears the value of `downloadFileDfsIp`. Subsequent reads from it will return its default value.
  mutating func clearDownloadFileDfsIp() {self._downloadFileDfsIp = nil}

  var downloadFileDfsPort: UInt32 {
    get {return _downloadFileDfsPort ?? 0}
    set {_downloadFileDfsPort = newValue}
  }
  /// Returns true if `downloadFileDfsPort` has been explicitly set.
  var hasDownloadFileDfsPort: Bool {return self._downloadFileDfsPort != nil}
  /// Clears the value of `downloadFileDfsPort`. Subsequent reads from it will return its default value.
  mutating func clearDownloadFileDfsPort() {self._downloadFileDfsPort = nil}

  var downloadFileURL: String {
    get {return _downloadFileURL ?? String()}
    set {_downloadFileURL = newValue}
  }
  /// Returns true if `downloadFileURL` has been explicitly set.
  var hasDownloadFileURL: Bool {return self._downloadFileURL != nil}
  /// Clears the value of `downloadFileURL`. Subsequent reads from it will return its default value.
  mutating func clearDownloadFileURL() {self._downloadFileURL = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eResult: UInt32? = nil
  fileprivate var _appID: UInt32? = nil
  fileprivate var _blobDownloadType: UInt32? = nil
  fileprivate var _errorDetail: UInt32? = nil
  fileprivate var _mergeGuid: Data? = nil
  fileprivate var _downloadFileDfsIp: UInt32? = nil
  fileprivate var _downloadFileDfsPort: UInt32? = nil
  fileprivate var _downloadFileURL: String? = nil
}

struct CMsgClientDPCheckSpecialSurvey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var surveyID: UInt32 {
    get {return _surveyID ?? 0}
    set {_surveyID = newValue}
  }
  /// Returns true if `surveyID` has been explicitly set.
  var hasSurveyID: Bool {return self._surveyID != nil}
  /// Clears the value of `surveyID`. Subsequent reads from it will return its default value.
  mutating func clearSurveyID() {self._surveyID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _surveyID: UInt32? = nil
}

struct CMsgClientDPCheckSpecialSurveyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eResult: UInt32 {
    get {return _eResult ?? 2}
    set {_eResult = newValue}
  }
  /// Returns true if `eResult` has been explicitly set.
  var hasEResult: Bool {return self._eResult != nil}
  /// Clears the value of `eResult`. Subsequent reads from it will return its default value.
  mutating func clearEResult() {self._eResult = nil}

  var state: UInt32 {
    get {return _state ?? 0}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var customURL: String {
    get {return _customURL ?? String()}
    set {_customURL = newValue}
  }
  /// Returns true if `customURL` has been explicitly set.
  var hasCustomURL: Bool {return self._customURL != nil}
  /// Clears the value of `customURL`. Subsequent reads from it will return its default value.
  mutating func clearCustomURL() {self._customURL = nil}

  var includeSoftware: Bool {
    get {return _includeSoftware ?? false}
    set {_includeSoftware = newValue}
  }
  /// Returns true if `includeSoftware` has been explicitly set.
  var hasIncludeSoftware: Bool {return self._includeSoftware != nil}
  /// Clears the value of `includeSoftware`. Subsequent reads from it will return its default value.
  mutating func clearIncludeSoftware() {self._includeSoftware = nil}

  var token: Data {
    get {return _token ?? Data()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  mutating func clearToken() {self._token = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eResult: UInt32? = nil
  fileprivate var _state: UInt32? = nil
  fileprivate var _name: String? = nil
  fileprivate var _customURL: String? = nil
  fileprivate var _includeSoftware: Bool? = nil
  fileprivate var _token: Data? = nil
}

struct CMsgClientDPSendSpecialSurveyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var surveyID: UInt32 {
    get {return _surveyID ?? 0}
    set {_surveyID = newValue}
  }
  /// Returns true if `surveyID` has been explicitly set.
  var hasSurveyID: Bool {return self._surveyID != nil}
  /// Clears the value of `surveyID`. Subsequent reads from it will return its default value.
  mutating func clearSurveyID() {self._surveyID = nil}

  var data: Data {
    get {return _data ?? Data()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _surveyID: UInt32? = nil
  fileprivate var _data: Data? = nil
}

struct CMsgClientDPSendSpecialSurveyResponseReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eResult: UInt32 {
    get {return _eResult ?? 2}
    set {_eResult = newValue}
  }
  /// Returns true if `eResult` has been explicitly set.
  var hasEResult: Bool {return self._eResult != nil}
  /// Clears the value of `eResult`. Subsequent reads from it will return its default value.
  mutating func clearEResult() {self._eResult = nil}

  var token: Data {
    get {return _token ?? Data()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  mutating func clearToken() {self._token = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eResult: UInt32? = nil
  fileprivate var _token: Data? = nil
}

struct CMsgClientRequestForgottenPasswordEmail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountName: String {
    get {return _accountName ?? String()}
    set {_accountName = newValue}
  }
  /// Returns true if `accountName` has been explicitly set.
  var hasAccountName: Bool {return self._accountName != nil}
  /// Clears the value of `accountName`. Subsequent reads from it will return its default value.
  mutating func clearAccountName() {self._accountName = nil}

  var passwordTried: String {
    get {return _passwordTried ?? String()}
    set {_passwordTried = newValue}
  }
  /// Returns true if `passwordTried` has been explicitly set.
  var hasPasswordTried: Bool {return self._passwordTried != nil}
  /// Clears the value of `passwordTried`. Subsequent reads from it will return its default value.
  mutating func clearPasswordTried() {self._passwordTried = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accountName: String? = nil
  fileprivate var _passwordTried: String? = nil
}

struct CMsgClientRequestForgottenPasswordEmailResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eResult: UInt32 {
    get {return _eResult ?? 0}
    set {_eResult = newValue}
  }
  /// Returns true if `eResult` has been explicitly set.
  var hasEResult: Bool {return self._eResult != nil}
  /// Clears the value of `eResult`. Subsequent reads from it will return its default value.
  mutating func clearEResult() {self._eResult = nil}

  var useSecretQuestion: Bool {
    get {return _useSecretQuestion ?? false}
    set {_useSecretQuestion = newValue}
  }
  /// Returns true if `useSecretQuestion` has been explicitly set.
  var hasUseSecretQuestion: Bool {return self._useSecretQuestion != nil}
  /// Clears the value of `useSecretQuestion`. Subsequent reads from it will return its default value.
  mutating func clearUseSecretQuestion() {self._useSecretQuestion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eResult: UInt32? = nil
  fileprivate var _useSecretQuestion: Bool? = nil
}

struct CMsgClientItemAnnouncements {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var countNewItems: UInt32 {
    get {return _countNewItems ?? 0}
    set {_countNewItems = newValue}
  }
  /// Returns true if `countNewItems` has been explicitly set.
  var hasCountNewItems: Bool {return self._countNewItems != nil}
  /// Clears the value of `countNewItems`. Subsequent reads from it will return its default value.
  mutating func clearCountNewItems() {self._countNewItems = nil}

  var unseenItems: [CMsgClientItemAnnouncements.UnseenItem] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct UnseenItem {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var appid: UInt32 {
      get {return _appid ?? 0}
      set {_appid = newValue}
    }
    /// Returns true if `appid` has been explicitly set.
    var hasAppid: Bool {return self._appid != nil}
    /// Clears the value of `appid`. Subsequent reads from it will return its default value.
    mutating func clearAppid() {self._appid = nil}

    var contextID: UInt64 {
      get {return _contextID ?? 0}
      set {_contextID = newValue}
    }
    /// Returns true if `contextID` has been explicitly set.
    var hasContextID: Bool {return self._contextID != nil}
    /// Clears the value of `contextID`. Subsequent reads from it will return its default value.
    mutating func clearContextID() {self._contextID = nil}

    var assetID: UInt64 {
      get {return _assetID ?? 0}
      set {_assetID = newValue}
    }
    /// Returns true if `assetID` has been explicitly set.
    var hasAssetID: Bool {return self._assetID != nil}
    /// Clears the value of `assetID`. Subsequent reads from it will return its default value.
    mutating func clearAssetID() {self._assetID = nil}

    var amount: UInt64 {
      get {return _amount ?? 0}
      set {_amount = newValue}
    }
    /// Returns true if `amount` has been explicitly set.
    var hasAmount: Bool {return self._amount != nil}
    /// Clears the value of `amount`. Subsequent reads from it will return its default value.
    mutating func clearAmount() {self._amount = nil}

    var rtime32Gained: UInt32 {
      get {return _rtime32Gained ?? 0}
      set {_rtime32Gained = newValue}
    }
    /// Returns true if `rtime32Gained` has been explicitly set.
    var hasRtime32Gained: Bool {return self._rtime32Gained != nil}
    /// Clears the value of `rtime32Gained`. Subsequent reads from it will return its default value.
    mutating func clearRtime32Gained() {self._rtime32Gained = nil}

    var sourceAppid: UInt32 {
      get {return _sourceAppid ?? 0}
      set {_sourceAppid = newValue}
    }
    /// Returns true if `sourceAppid` has been explicitly set.
    var hasSourceAppid: Bool {return self._sourceAppid != nil}
    /// Clears the value of `sourceAppid`. Subsequent reads from it will return its default value.
    mutating func clearSourceAppid() {self._sourceAppid = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _appid: UInt32? = nil
    fileprivate var _contextID: UInt64? = nil
    fileprivate var _assetID: UInt64? = nil
    fileprivate var _amount: UInt64? = nil
    fileprivate var _rtime32Gained: UInt32? = nil
    fileprivate var _sourceAppid: UInt32? = nil
  }

  init() {}

  fileprivate var _countNewItems: UInt32? = nil
}

struct CMsgClientRequestItemAnnouncements {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CMsgClientUserNotifications {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var notifications: [CMsgClientUserNotifications.Notification] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Notification {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userNotificationType: UInt32 {
      get {return _userNotificationType ?? 0}
      set {_userNotificationType = newValue}
    }
    /// Returns true if `userNotificationType` has been explicitly set.
    var hasUserNotificationType: Bool {return self._userNotificationType != nil}
    /// Clears the value of `userNotificationType`. Subsequent reads from it will return its default value.
    mutating func clearUserNotificationType() {self._userNotificationType = nil}

    var count: UInt32 {
      get {return _count ?? 0}
      set {_count = newValue}
    }
    /// Returns true if `count` has been explicitly set.
    var hasCount: Bool {return self._count != nil}
    /// Clears the value of `count`. Subsequent reads from it will return its default value.
    mutating func clearCount() {self._count = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _userNotificationType: UInt32? = nil
    fileprivate var _count: UInt32? = nil
  }

  init() {}
}

struct CMsgClientCommentNotifications {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var countNewComments: UInt32 {
    get {return _countNewComments ?? 0}
    set {_countNewComments = newValue}
  }
  /// Returns true if `countNewComments` has been explicitly set.
  var hasCountNewComments: Bool {return self._countNewComments != nil}
  /// Clears the value of `countNewComments`. Subsequent reads from it will return its default value.
  mutating func clearCountNewComments() {self._countNewComments = nil}

  var countNewCommentsOwner: UInt32 {
    get {return _countNewCommentsOwner ?? 0}
    set {_countNewCommentsOwner = newValue}
  }
  /// Returns true if `countNewCommentsOwner` has been explicitly set.
  var hasCountNewCommentsOwner: Bool {return self._countNewCommentsOwner != nil}
  /// Clears the value of `countNewCommentsOwner`. Subsequent reads from it will return its default value.
  mutating func clearCountNewCommentsOwner() {self._countNewCommentsOwner = nil}

  var countNewCommentsSubscriptions: UInt32 {
    get {return _countNewCommentsSubscriptions ?? 0}
    set {_countNewCommentsSubscriptions = newValue}
  }
  /// Returns true if `countNewCommentsSubscriptions` has been explicitly set.
  var hasCountNewCommentsSubscriptions: Bool {return self._countNewCommentsSubscriptions != nil}
  /// Clears the value of `countNewCommentsSubscriptions`. Subsequent reads from it will return its default value.
  mutating func clearCountNewCommentsSubscriptions() {self._countNewCommentsSubscriptions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _countNewComments: UInt32? = nil
  fileprivate var _countNewCommentsOwner: UInt32? = nil
  fileprivate var _countNewCommentsSubscriptions: UInt32? = nil
}

struct CMsgClientRequestCommentNotifications {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CMsgClientOfflineMessageNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offlineMessages: UInt32 {
    get {return _offlineMessages ?? 0}
    set {_offlineMessages = newValue}
  }
  /// Returns true if `offlineMessages` has been explicitly set.
  var hasOfflineMessages: Bool {return self._offlineMessages != nil}
  /// Clears the value of `offlineMessages`. Subsequent reads from it will return its default value.
  mutating func clearOfflineMessages() {self._offlineMessages = nil}

  var friendsWithOfflineMessages: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _offlineMessages: UInt32? = nil
}

struct CMsgClientRequestOfflineMessageCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CMsgClientChatGetFriendMessageHistory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var steamid: UInt64 {
    get {return _steamid ?? 0}
    set {_steamid = newValue}
  }
  /// Returns true if `steamid` has been explicitly set.
  var hasSteamid: Bool {return self._steamid != nil}
  /// Clears the value of `steamid`. Subsequent reads from it will return its default value.
  mutating func clearSteamid() {self._steamid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _steamid: UInt64? = nil
}

struct CMsgClientChatGetFriendMessageHistoryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var steamid: UInt64 {
    get {return _steamid ?? 0}
    set {_steamid = newValue}
  }
  /// Returns true if `steamid` has been explicitly set.
  var hasSteamid: Bool {return self._steamid != nil}
  /// Clears the value of `steamid`. Subsequent reads from it will return its default value.
  mutating func clearSteamid() {self._steamid = nil}

  var success: UInt32 {
    get {return _success ?? 0}
    set {_success = newValue}
  }
  /// Returns true if `success` has been explicitly set.
  var hasSuccess: Bool {return self._success != nil}
  /// Clears the value of `success`. Subsequent reads from it will return its default value.
  mutating func clearSuccess() {self._success = nil}

  var messages: [CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct FriendMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var accountid: UInt32 {
      get {return _accountid ?? 0}
      set {_accountid = newValue}
    }
    /// Returns true if `accountid` has been explicitly set.
    var hasAccountid: Bool {return self._accountid != nil}
    /// Clears the value of `accountid`. Subsequent reads from it will return its default value.
    mutating func clearAccountid() {self._accountid = nil}

    var timestamp: UInt32 {
      get {return _timestamp ?? 0}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() {self._timestamp = nil}

    var message: String {
      get {return _message ?? String()}
      set {_message = newValue}
    }
    /// Returns true if `message` has been explicitly set.
    var hasMessage: Bool {return self._message != nil}
    /// Clears the value of `message`. Subsequent reads from it will return its default value.
    mutating func clearMessage() {self._message = nil}

    var unread: Bool {
      get {return _unread ?? false}
      set {_unread = newValue}
    }
    /// Returns true if `unread` has been explicitly set.
    var hasUnread: Bool {return self._unread != nil}
    /// Clears the value of `unread`. Subsequent reads from it will return its default value.
    mutating func clearUnread() {self._unread = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _accountid: UInt32? = nil
    fileprivate var _timestamp: UInt32? = nil
    fileprivate var _message: String? = nil
    fileprivate var _unread: Bool? = nil
  }

  init() {}

  fileprivate var _steamid: UInt64? = nil
  fileprivate var _success: UInt32? = nil
}

struct CMsgClientChatGetFriendMessageHistoryForOfflineMessages {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CMsgClientFSGetFriendsSteamLevels {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var accountids: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CMsgClientFSGetFriendsSteamLevelsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var friends: [CMsgClientFSGetFriendsSteamLevelsResponse.Friend] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Friend {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var accountid: UInt32 {
      get {return _accountid ?? 0}
      set {_accountid = newValue}
    }
    /// Returns true if `accountid` has been explicitly set.
    var hasAccountid: Bool {return self._accountid != nil}
    /// Clears the value of `accountid`. Subsequent reads from it will return its default value.
    mutating func clearAccountid() {self._accountid = nil}

    var level: UInt32 {
      get {return _level ?? 0}
      set {_level = newValue}
    }
    /// Returns true if `level` has been explicitly set.
    var hasLevel: Bool {return self._level != nil}
    /// Clears the value of `level`. Subsequent reads from it will return its default value.
    mutating func clearLevel() {self._level = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _accountid: UInt32? = nil
    fileprivate var _level: UInt32? = nil
  }

  init() {}
}

struct CMsgClientEmailAddrInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var emailAddress: String {
    get {return _emailAddress ?? String()}
    set {_emailAddress = newValue}
  }
  /// Returns true if `emailAddress` has been explicitly set.
  var hasEmailAddress: Bool {return self._emailAddress != nil}
  /// Clears the value of `emailAddress`. Subsequent reads from it will return its default value.
  mutating func clearEmailAddress() {self._emailAddress = nil}

  var emailIsValidated: Bool {
    get {return _emailIsValidated ?? false}
    set {_emailIsValidated = newValue}
  }
  /// Returns true if `emailIsValidated` has been explicitly set.
  var hasEmailIsValidated: Bool {return self._emailIsValidated != nil}
  /// Clears the value of `emailIsValidated`. Subsequent reads from it will return its default value.
  mutating func clearEmailIsValidated() {self._emailIsValidated = nil}

  var emailValidationChanged: Bool {
    get {return _emailValidationChanged ?? false}
    set {_emailValidationChanged = newValue}
  }
  /// Returns true if `emailValidationChanged` has been explicitly set.
  var hasEmailValidationChanged: Bool {return self._emailValidationChanged != nil}
  /// Clears the value of `emailValidationChanged`. Subsequent reads from it will return its default value.
  mutating func clearEmailValidationChanged() {self._emailValidationChanged = nil}

  var credentialChangeRequiresCode: Bool {
    get {return _credentialChangeRequiresCode ?? false}
    set {_credentialChangeRequiresCode = newValue}
  }
  /// Returns true if `credentialChangeRequiresCode` has been explicitly set.
  var hasCredentialChangeRequiresCode: Bool {return self._credentialChangeRequiresCode != nil}
  /// Clears the value of `credentialChangeRequiresCode`. Subsequent reads from it will return its default value.
  mutating func clearCredentialChangeRequiresCode() {self._credentialChangeRequiresCode = nil}

  var passwordOrSecretqaChangeRequiresCode: Bool {
    get {return _passwordOrSecretqaChangeRequiresCode ?? false}
    set {_passwordOrSecretqaChangeRequiresCode = newValue}
  }
  /// Returns true if `passwordOrSecretqaChangeRequiresCode` has been explicitly set.
  var hasPasswordOrSecretqaChangeRequiresCode: Bool {return self._passwordOrSecretqaChangeRequiresCode != nil}
  /// Clears the value of `passwordOrSecretqaChangeRequiresCode`. Subsequent reads from it will return its default value.
  mutating func clearPasswordOrSecretqaChangeRequiresCode() {self._passwordOrSecretqaChangeRequiresCode = nil}

  var remindUserAboutEmail: Bool {
    get {return _remindUserAboutEmail ?? false}
    set {_remindUserAboutEmail = newValue}
  }
  /// Returns true if `remindUserAboutEmail` has been explicitly set.
  var hasRemindUserAboutEmail: Bool {return self._remindUserAboutEmail != nil}
  /// Clears the value of `remindUserAboutEmail`. Subsequent reads from it will return its default value.
  mutating func clearRemindUserAboutEmail() {self._remindUserAboutEmail = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _emailAddress: String? = nil
  fileprivate var _emailIsValidated: Bool? = nil
  fileprivate var _emailValidationChanged: Bool? = nil
  fileprivate var _credentialChangeRequiresCode: Bool? = nil
  fileprivate var _passwordOrSecretqaChangeRequiresCode: Bool? = nil
  fileprivate var _remindUserAboutEmail: Bool? = nil
}

struct CMsgCREItemVoteSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publishedFileIds: [CMsgCREItemVoteSummary.PublishedFileId] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PublishedFileId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var publishedFileID: UInt64 {
      get {return _publishedFileID ?? 0}
      set {_publishedFileID = newValue}
    }
    /// Returns true if `publishedFileID` has been explicitly set.
    var hasPublishedFileID: Bool {return self._publishedFileID != nil}
    /// Clears the value of `publishedFileID`. Subsequent reads from it will return its default value.
    mutating func clearPublishedFileID() {self._publishedFileID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _publishedFileID: UInt64? = nil
  }

  init() {}
}

struct CMsgCREItemVoteSummaryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var itemVoteSummaries: [CMsgCREItemVoteSummaryResponse.ItemVoteSummary] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ItemVoteSummary {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var publishedFileID: UInt64 {
      get {return _publishedFileID ?? 0}
      set {_publishedFileID = newValue}
    }
    /// Returns true if `publishedFileID` has been explicitly set.
    var hasPublishedFileID: Bool {return self._publishedFileID != nil}
    /// Clears the value of `publishedFileID`. Subsequent reads from it will return its default value.
    mutating func clearPublishedFileID() {self._publishedFileID = nil}

    var votesFor: Int32 {
      get {return _votesFor ?? 0}
      set {_votesFor = newValue}
    }
    /// Returns true if `votesFor` has been explicitly set.
    var hasVotesFor: Bool {return self._votesFor != nil}
    /// Clears the value of `votesFor`. Subsequent reads from it will return its default value.
    mutating func clearVotesFor() {self._votesFor = nil}

    var votesAgainst: Int32 {
      get {return _votesAgainst ?? 0}
      set {_votesAgainst = newValue}
    }
    /// Returns true if `votesAgainst` has been explicitly set.
    var hasVotesAgainst: Bool {return self._votesAgainst != nil}
    /// Clears the value of `votesAgainst`. Subsequent reads from it will return its default value.
    mutating func clearVotesAgainst() {self._votesAgainst = nil}

    var reports: Int32 {
      get {return _reports ?? 0}
      set {_reports = newValue}
    }
    /// Returns true if `reports` has been explicitly set.
    var hasReports: Bool {return self._reports != nil}
    /// Clears the value of `reports`. Subsequent reads from it will return its default value.
    mutating func clearReports() {self._reports = nil}

    var score: Float {
      get {return _score ?? 0}
      set {_score = newValue}
    }
    /// Returns true if `score` has been explicitly set.
    var hasScore: Bool {return self._score != nil}
    /// Clears the value of `score`. Subsequent reads from it will return its default value.
    mutating func clearScore() {self._score = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _publishedFileID: UInt64? = nil
    fileprivate var _votesFor: Int32? = nil
    fileprivate var _votesAgainst: Int32? = nil
    fileprivate var _reports: Int32? = nil
    fileprivate var _score: Float? = nil
  }

  init() {}

  fileprivate var _eresult: Int32? = nil
}

struct CMsgCREUpdateUserPublishedItemVote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publishedFileID: UInt64 {
    get {return _publishedFileID ?? 0}
    set {_publishedFileID = newValue}
  }
  /// Returns true if `publishedFileID` has been explicitly set.
  var hasPublishedFileID: Bool {return self._publishedFileID != nil}
  /// Clears the value of `publishedFileID`. Subsequent reads from it will return its default value.
  mutating func clearPublishedFileID() {self._publishedFileID = nil}

  var voteUp: Bool {
    get {return _voteUp ?? false}
    set {_voteUp = newValue}
  }
  /// Returns true if `voteUp` has been explicitly set.
  var hasVoteUp: Bool {return self._voteUp != nil}
  /// Clears the value of `voteUp`. Subsequent reads from it will return its default value.
  mutating func clearVoteUp() {self._voteUp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publishedFileID: UInt64? = nil
  fileprivate var _voteUp: Bool? = nil
}

struct CMsgCREUpdateUserPublishedItemVoteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: Int32? = nil
}

struct CMsgCREGetUserPublishedItemVoteDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var publishedFileIds: [CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct PublishedFileId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var publishedFileID: UInt64 {
      get {return _publishedFileID ?? 0}
      set {_publishedFileID = newValue}
    }
    /// Returns true if `publishedFileID` has been explicitly set.
    var hasPublishedFileID: Bool {return self._publishedFileID != nil}
    /// Clears the value of `publishedFileID`. Subsequent reads from it will return its default value.
    mutating func clearPublishedFileID() {self._publishedFileID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _publishedFileID: UInt64? = nil
  }

  init() {}
}

struct CMsgCREGetUserPublishedItemVoteDetailsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var userItemVoteDetails: [CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct UserItemVoteDetail {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var publishedFileID: UInt64 {
      get {return _publishedFileID ?? 0}
      set {_publishedFileID = newValue}
    }
    /// Returns true if `publishedFileID` has been explicitly set.
    var hasPublishedFileID: Bool {return self._publishedFileID != nil}
    /// Clears the value of `publishedFileID`. Subsequent reads from it will return its default value.
    mutating func clearPublishedFileID() {self._publishedFileID = nil}

    var vote: Int32 {
      get {return _vote ?? 0}
      set {_vote = newValue}
    }
    /// Returns true if `vote` has been explicitly set.
    var hasVote: Bool {return self._vote != nil}
    /// Clears the value of `vote`. Subsequent reads from it will return its default value.
    mutating func clearVote() {self._vote = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _publishedFileID: UInt64? = nil
    fileprivate var _vote: Int32? = nil
  }

  init() {}

  fileprivate var _eresult: Int32? = nil
}

struct CMsgFSGetFollowerCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var steamID: UInt64 {
    get {return _steamID ?? 0}
    set {_steamID = newValue}
  }
  /// Returns true if `steamID` has been explicitly set.
  var hasSteamID: Bool {return self._steamID != nil}
  /// Clears the value of `steamID`. Subsequent reads from it will return its default value.
  mutating func clearSteamID() {self._steamID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _steamID: UInt64? = nil
}

struct CMsgFSGetFollowerCountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var count: Int32 {
    get {return _count ?? 0}
    set {_count = newValue}
  }
  /// Returns true if `count` has been explicitly set.
  var hasCount: Bool {return self._count != nil}
  /// Clears the value of `count`. Subsequent reads from it will return its default value.
  mutating func clearCount() {self._count = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: Int32? = nil
  fileprivate var _count: Int32? = nil
}

struct CMsgFSGetIsFollowing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var steamID: UInt64 {
    get {return _steamID ?? 0}
    set {_steamID = newValue}
  }
  /// Returns true if `steamID` has been explicitly set.
  var hasSteamID: Bool {return self._steamID != nil}
  /// Clears the value of `steamID`. Subsequent reads from it will return its default value.
  mutating func clearSteamID() {self._steamID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _steamID: UInt64? = nil
}

struct CMsgFSGetIsFollowingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var isFollowing: Bool {
    get {return _isFollowing ?? false}
    set {_isFollowing = newValue}
  }
  /// Returns true if `isFollowing` has been explicitly set.
  var hasIsFollowing: Bool {return self._isFollowing != nil}
  /// Clears the value of `isFollowing`. Subsequent reads from it will return its default value.
  mutating func clearIsFollowing() {self._isFollowing = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: Int32? = nil
  fileprivate var _isFollowing: Bool? = nil
}

struct CMsgFSEnumerateFollowingList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var startIndex: UInt32 {
    get {return _startIndex ?? 0}
    set {_startIndex = newValue}
  }
  /// Returns true if `startIndex` has been explicitly set.
  var hasStartIndex: Bool {return self._startIndex != nil}
  /// Clears the value of `startIndex`. Subsequent reads from it will return its default value.
  mutating func clearStartIndex() {self._startIndex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startIndex: UInt32? = nil
}

struct CMsgFSEnumerateFollowingListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var totalResults: Int32 {
    get {return _totalResults ?? 0}
    set {_totalResults = newValue}
  }
  /// Returns true if `totalResults` has been explicitly set.
  var hasTotalResults: Bool {return self._totalResults != nil}
  /// Clears the value of `totalResults`. Subsequent reads from it will return its default value.
  mutating func clearTotalResults() {self._totalResults = nil}

  var steamIds: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: Int32? = nil
  fileprivate var _totalResults: Int32? = nil
}

struct CMsgDPGetNumberOfCurrentPlayers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appid: UInt32 {
    get {return _appid ?? 0}
    set {_appid = newValue}
  }
  /// Returns true if `appid` has been explicitly set.
  var hasAppid: Bool {return self._appid != nil}
  /// Clears the value of `appid`. Subsequent reads from it will return its default value.
  mutating func clearAppid() {self._appid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _appid: UInt32? = nil
}

struct CMsgDPGetNumberOfCurrentPlayersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var playerCount: Int32 {
    get {return _playerCount ?? 0}
    set {_playerCount = newValue}
  }
  /// Returns true if `playerCount` has been explicitly set.
  var hasPlayerCount: Bool {return self._playerCount != nil}
  /// Clears the value of `playerCount`. Subsequent reads from it will return its default value.
  mutating func clearPlayerCount() {self._playerCount = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: Int32? = nil
  fileprivate var _playerCount: Int32? = nil
}

struct CMsgClientFriendUserStatusPublished {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var friendSteamid: UInt64 {
    get {return _friendSteamid ?? 0}
    set {_friendSteamid = newValue}
  }
  /// Returns true if `friendSteamid` has been explicitly set.
  var hasFriendSteamid: Bool {return self._friendSteamid != nil}
  /// Clears the value of `friendSteamid`. Subsequent reads from it will return its default value.
  mutating func clearFriendSteamid() {self._friendSteamid = nil}

  var appid: UInt32 {
    get {return _appid ?? 0}
    set {_appid = newValue}
  }
  /// Returns true if `appid` has been explicitly set.
  var hasAppid: Bool {return self._appid != nil}
  /// Clears the value of `appid`. Subsequent reads from it will return its default value.
  mutating func clearAppid() {self._appid = nil}

  var statusText: String {
    get {return _statusText ?? String()}
    set {_statusText = newValue}
  }
  /// Returns true if `statusText` has been explicitly set.
  var hasStatusText: Bool {return self._statusText != nil}
  /// Clears the value of `statusText`. Subsequent reads from it will return its default value.
  mutating func clearStatusText() {self._statusText = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _friendSteamid: UInt64? = nil
  fileprivate var _appid: UInt32? = nil
  fileprivate var _statusText: String? = nil
}

struct CMsgClientServiceMethodLegacy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var methodName: String {
    get {return _methodName ?? String()}
    set {_methodName = newValue}
  }
  /// Returns true if `methodName` has been explicitly set.
  var hasMethodName: Bool {return self._methodName != nil}
  /// Clears the value of `methodName`. Subsequent reads from it will return its default value.
  mutating func clearMethodName() {self._methodName = nil}

  var serializedMethod: Data {
    get {return _serializedMethod ?? Data()}
    set {_serializedMethod = newValue}
  }
  /// Returns true if `serializedMethod` has been explicitly set.
  var hasSerializedMethod: Bool {return self._serializedMethod != nil}
  /// Clears the value of `serializedMethod`. Subsequent reads from it will return its default value.
  mutating func clearSerializedMethod() {self._serializedMethod = nil}

  var isNotification: Bool {
    get {return _isNotification ?? false}
    set {_isNotification = newValue}
  }
  /// Returns true if `isNotification` has been explicitly set.
  var hasIsNotification: Bool {return self._isNotification != nil}
  /// Clears the value of `isNotification`. Subsequent reads from it will return its default value.
  mutating func clearIsNotification() {self._isNotification = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _methodName: String? = nil
  fileprivate var _serializedMethod: Data? = nil
  fileprivate var _isNotification: Bool? = nil
}

struct CMsgClientServiceMethodLegacyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var methodName: String {
    get {return _methodName ?? String()}
    set {_methodName = newValue}
  }
  /// Returns true if `methodName` has been explicitly set.
  var hasMethodName: Bool {return self._methodName != nil}
  /// Clears the value of `methodName`. Subsequent reads from it will return its default value.
  mutating func clearMethodName() {self._methodName = nil}

  var serializedMethodResponse: Data {
    get {return _serializedMethodResponse ?? Data()}
    set {_serializedMethodResponse = newValue}
  }
  /// Returns true if `serializedMethodResponse` has been explicitly set.
  var hasSerializedMethodResponse: Bool {return self._serializedMethodResponse != nil}
  /// Clears the value of `serializedMethodResponse`. Subsequent reads from it will return its default value.
  mutating func clearSerializedMethodResponse() {self._serializedMethodResponse = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _methodName: String? = nil
  fileprivate var _serializedMethodResponse: Data? = nil
}

struct CMsgClientUIMode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uimode: UInt32 {
    get {return _uimode ?? 0}
    set {_uimode = newValue}
  }
  /// Returns true if `uimode` has been explicitly set.
  var hasUimode: Bool {return self._uimode != nil}
  /// Clears the value of `uimode`. Subsequent reads from it will return its default value.
  mutating func clearUimode() {self._uimode = nil}

  var chatMode: UInt32 {
    get {return _chatMode ?? 0}
    set {_chatMode = newValue}
  }
  /// Returns true if `chatMode` has been explicitly set.
  var hasChatMode: Bool {return self._chatMode != nil}
  /// Clears the value of `chatMode`. Subsequent reads from it will return its default value.
  mutating func clearChatMode() {self._chatMode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _uimode: UInt32? = nil
  fileprivate var _chatMode: UInt32? = nil
}

struct CMsgClientVanityURLChangedNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vanityURL: String {
    get {return _vanityURL ?? String()}
    set {_vanityURL = newValue}
  }
  /// Returns true if `vanityURL` has been explicitly set.
  var hasVanityURL: Bool {return self._vanityURL != nil}
  /// Clears the value of `vanityURL`. Subsequent reads from it will return its default value.
  mutating func clearVanityURL() {self._vanityURL = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _vanityURL: String? = nil
}

struct CMsgClientAuthorizeLocalDeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceDescription: String {
    get {return _deviceDescription ?? String()}
    set {_deviceDescription = newValue}
  }
  /// Returns true if `deviceDescription` has been explicitly set.
  var hasDeviceDescription: Bool {return self._deviceDescription != nil}
  /// Clears the value of `deviceDescription`. Subsequent reads from it will return its default value.
  mutating func clearDeviceDescription() {self._deviceDescription = nil}

  var ownerAccountID: UInt32 {
    get {return _ownerAccountID ?? 0}
    set {_ownerAccountID = newValue}
  }
  /// Returns true if `ownerAccountID` has been explicitly set.
  var hasOwnerAccountID: Bool {return self._ownerAccountID != nil}
  /// Clears the value of `ownerAccountID`. Subsequent reads from it will return its default value.
  mutating func clearOwnerAccountID() {self._ownerAccountID = nil}

  var localDeviceToken: UInt64 {
    get {return _localDeviceToken ?? 0}
    set {_localDeviceToken = newValue}
  }
  /// Returns true if `localDeviceToken` has been explicitly set.
  var hasLocalDeviceToken: Bool {return self._localDeviceToken != nil}
  /// Clears the value of `localDeviceToken`. Subsequent reads from it will return its default value.
  mutating func clearLocalDeviceToken() {self._localDeviceToken = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _deviceDescription: String? = nil
  fileprivate var _ownerAccountID: UInt32? = nil
  fileprivate var _localDeviceToken: UInt64? = nil
}

struct CMsgClientAuthorizeLocalDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var ownerAccountID: UInt32 {
    get {return _ownerAccountID ?? 0}
    set {_ownerAccountID = newValue}
  }
  /// Returns true if `ownerAccountID` has been explicitly set.
  var hasOwnerAccountID: Bool {return self._ownerAccountID != nil}
  /// Clears the value of `ownerAccountID`. Subsequent reads from it will return its default value.
  mutating func clearOwnerAccountID() {self._ownerAccountID = nil}

  var authedDeviceToken: UInt64 {
    get {return _authedDeviceToken ?? 0}
    set {_authedDeviceToken = newValue}
  }
  /// Returns true if `authedDeviceToken` has been explicitly set.
  var hasAuthedDeviceToken: Bool {return self._authedDeviceToken != nil}
  /// Clears the value of `authedDeviceToken`. Subsequent reads from it will return its default value.
  mutating func clearAuthedDeviceToken() {self._authedDeviceToken = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: Int32? = nil
  fileprivate var _ownerAccountID: UInt32? = nil
  fileprivate var _authedDeviceToken: UInt64? = nil
}

struct CMsgClientAuthorizeLocalDeviceNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var ownerAccountID: UInt32 {
    get {return _ownerAccountID ?? 0}
    set {_ownerAccountID = newValue}
  }
  /// Returns true if `ownerAccountID` has been explicitly set.
  var hasOwnerAccountID: Bool {return self._ownerAccountID != nil}
  /// Clears the value of `ownerAccountID`. Subsequent reads from it will return its default value.
  mutating func clearOwnerAccountID() {self._ownerAccountID = nil}

  var localDeviceToken: UInt64 {
    get {return _localDeviceToken ?? 0}
    set {_localDeviceToken = newValue}
  }
  /// Returns true if `localDeviceToken` has been explicitly set.
  var hasLocalDeviceToken: Bool {return self._localDeviceToken != nil}
  /// Clears the value of `localDeviceToken`. Subsequent reads from it will return its default value.
  mutating func clearLocalDeviceToken() {self._localDeviceToken = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: Int32? = nil
  fileprivate var _ownerAccountID: UInt32? = nil
  fileprivate var _localDeviceToken: UInt64? = nil
}

struct CMsgClientDeauthorizeDeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deauthorizationAccountID: UInt32 {
    get {return _deauthorizationAccountID ?? 0}
    set {_deauthorizationAccountID = newValue}
  }
  /// Returns true if `deauthorizationAccountID` has been explicitly set.
  var hasDeauthorizationAccountID: Bool {return self._deauthorizationAccountID != nil}
  /// Clears the value of `deauthorizationAccountID`. Subsequent reads from it will return its default value.
  mutating func clearDeauthorizationAccountID() {self._deauthorizationAccountID = nil}

  var deauthorizationDeviceToken: UInt64 {
    get {return _deauthorizationDeviceToken ?? 0}
    set {_deauthorizationDeviceToken = newValue}
  }
  /// Returns true if `deauthorizationDeviceToken` has been explicitly set.
  var hasDeauthorizationDeviceToken: Bool {return self._deauthorizationDeviceToken != nil}
  /// Clears the value of `deauthorizationDeviceToken`. Subsequent reads from it will return its default value.
  mutating func clearDeauthorizationDeviceToken() {self._deauthorizationDeviceToken = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _deauthorizationAccountID: UInt32? = nil
  fileprivate var _deauthorizationDeviceToken: UInt64? = nil
}

struct CMsgClientDeauthorizeDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var deauthorizationAccountID: UInt32 {
    get {return _deauthorizationAccountID ?? 0}
    set {_deauthorizationAccountID = newValue}
  }
  /// Returns true if `deauthorizationAccountID` has been explicitly set.
  var hasDeauthorizationAccountID: Bool {return self._deauthorizationAccountID != nil}
  /// Clears the value of `deauthorizationAccountID`. Subsequent reads from it will return its default value.
  mutating func clearDeauthorizationAccountID() {self._deauthorizationAccountID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: Int32? = nil
  fileprivate var _deauthorizationAccountID: UInt32? = nil
}

struct CMsgClientUseLocalDeviceAuthorizations {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var authorizationAccountID: [UInt32] = []

  var deviceTokens: [CMsgClientUseLocalDeviceAuthorizations.DeviceToken] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct DeviceToken {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ownerAccountID: UInt32 {
      get {return _ownerAccountID ?? 0}
      set {_ownerAccountID = newValue}
    }
    /// Returns true if `ownerAccountID` has been explicitly set.
    var hasOwnerAccountID: Bool {return self._ownerAccountID != nil}
    /// Clears the value of `ownerAccountID`. Subsequent reads from it will return its default value.
    mutating func clearOwnerAccountID() {self._ownerAccountID = nil}

    var tokenID: UInt64 {
      get {return _tokenID ?? 0}
      set {_tokenID = newValue}
    }
    /// Returns true if `tokenID` has been explicitly set.
    var hasTokenID: Bool {return self._tokenID != nil}
    /// Clears the value of `tokenID`. Subsequent reads from it will return its default value.
    mutating func clearTokenID() {self._tokenID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _ownerAccountID: UInt32? = nil
    fileprivate var _tokenID: UInt64? = nil
  }

  init() {}
}

struct CMsgClientGetAuthorizedDevices {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CMsgClientGetAuthorizedDevicesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var authorizedDevice: [CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct AuthorizedDevice {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var authDeviceToken: UInt64 {
      get {return _authDeviceToken ?? 0}
      set {_authDeviceToken = newValue}
    }
    /// Returns true if `authDeviceToken` has been explicitly set.
    var hasAuthDeviceToken: Bool {return self._authDeviceToken != nil}
    /// Clears the value of `authDeviceToken`. Subsequent reads from it will return its default value.
    mutating func clearAuthDeviceToken() {self._authDeviceToken = nil}

    var deviceName: String {
      get {return _deviceName ?? String()}
      set {_deviceName = newValue}
    }
    /// Returns true if `deviceName` has been explicitly set.
    var hasDeviceName: Bool {return self._deviceName != nil}
    /// Clears the value of `deviceName`. Subsequent reads from it will return its default value.
    mutating func clearDeviceName() {self._deviceName = nil}

    var lastAccessTime: UInt32 {
      get {return _lastAccessTime ?? 0}
      set {_lastAccessTime = newValue}
    }
    /// Returns true if `lastAccessTime` has been explicitly set.
    var hasLastAccessTime: Bool {return self._lastAccessTime != nil}
    /// Clears the value of `lastAccessTime`. Subsequent reads from it will return its default value.
    mutating func clearLastAccessTime() {self._lastAccessTime = nil}

    var borrowerID: UInt32 {
      get {return _borrowerID ?? 0}
      set {_borrowerID = newValue}
    }
    /// Returns true if `borrowerID` has been explicitly set.
    var hasBorrowerID: Bool {return self._borrowerID != nil}
    /// Clears the value of `borrowerID`. Subsequent reads from it will return its default value.
    mutating func clearBorrowerID() {self._borrowerID = nil}

    var isPending: Bool {
      get {return _isPending ?? false}
      set {_isPending = newValue}
    }
    /// Returns true if `isPending` has been explicitly set.
    var hasIsPending: Bool {return self._isPending != nil}
    /// Clears the value of `isPending`. Subsequent reads from it will return its default value.
    mutating func clearIsPending() {self._isPending = nil}

    var appPlayed: UInt32 {
      get {return _appPlayed ?? 0}
      set {_appPlayed = newValue}
    }
    /// Returns true if `appPlayed` has been explicitly set.
    var hasAppPlayed: Bool {return self._appPlayed != nil}
    /// Clears the value of `appPlayed`. Subsequent reads from it will return its default value.
    mutating func clearAppPlayed() {self._appPlayed = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _authDeviceToken: UInt64? = nil
    fileprivate var _deviceName: String? = nil
    fileprivate var _lastAccessTime: UInt32? = nil
    fileprivate var _borrowerID: UInt32? = nil
    fileprivate var _isPending: Bool? = nil
    fileprivate var _appPlayed: UInt32? = nil
  }

  init() {}

  fileprivate var _eresult: Int32? = nil
}

struct CMsgClientSharedLibraryLockStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lockedLibrary: [CMsgClientSharedLibraryLockStatus.LockedLibrary] = []

  var ownLibraryLockedBy: UInt32 {
    get {return _ownLibraryLockedBy ?? 0}
    set {_ownLibraryLockedBy = newValue}
  }
  /// Returns true if `ownLibraryLockedBy` has been explicitly set.
  var hasOwnLibraryLockedBy: Bool {return self._ownLibraryLockedBy != nil}
  /// Clears the value of `ownLibraryLockedBy`. Subsequent reads from it will return its default value.
  mutating func clearOwnLibraryLockedBy() {self._ownLibraryLockedBy = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct LockedLibrary {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var ownerID: UInt32 {
      get {return _ownerID ?? 0}
      set {_ownerID = newValue}
    }
    /// Returns true if `ownerID` has been explicitly set.
    var hasOwnerID: Bool {return self._ownerID != nil}
    /// Clears the value of `ownerID`. Subsequent reads from it will return its default value.
    mutating func clearOwnerID() {self._ownerID = nil}

    var lockedBy: UInt32 {
      get {return _lockedBy ?? 0}
      set {_lockedBy = newValue}
    }
    /// Returns true if `lockedBy` has been explicitly set.
    var hasLockedBy: Bool {return self._lockedBy != nil}
    /// Clears the value of `lockedBy`. Subsequent reads from it will return its default value.
    mutating func clearLockedBy() {self._lockedBy = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _ownerID: UInt32? = nil
    fileprivate var _lockedBy: UInt32? = nil
  }

  init() {}

  fileprivate var _ownLibraryLockedBy: UInt32? = nil
}

struct CMsgClientSharedLibraryStopPlaying {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var secondsLeft: Int32 {
    get {return _secondsLeft ?? 0}
    set {_secondsLeft = newValue}
  }
  /// Returns true if `secondsLeft` has been explicitly set.
  var hasSecondsLeft: Bool {return self._secondsLeft != nil}
  /// Clears the value of `secondsLeft`. Subsequent reads from it will return its default value.
  mutating func clearSecondsLeft() {self._secondsLeft = nil}

  var stopApps: [CMsgClientSharedLibraryStopPlaying.StopApp] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct StopApp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var appID: UInt32 {
      get {return _appID ?? 0}
      set {_appID = newValue}
    }
    /// Returns true if `appID` has been explicitly set.
    var hasAppID: Bool {return self._appID != nil}
    /// Clears the value of `appID`. Subsequent reads from it will return its default value.
    mutating func clearAppID() {self._appID = nil}

    var ownerID: UInt32 {
      get {return _ownerID ?? 0}
      set {_ownerID = newValue}
    }
    /// Returns true if `ownerID` has been explicitly set.
    var hasOwnerID: Bool {return self._ownerID != nil}
    /// Clears the value of `ownerID`. Subsequent reads from it will return its default value.
    mutating func clearOwnerID() {self._ownerID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _appID: UInt32? = nil
    fileprivate var _ownerID: UInt32? = nil
  }

  init() {}

  fileprivate var _secondsLeft: Int32? = nil
}

struct CMsgClientServiceCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sysidRouting: Data {
    get {return _sysidRouting ?? Data()}
    set {_sysidRouting = newValue}
  }
  /// Returns true if `sysidRouting` has been explicitly set.
  var hasSysidRouting: Bool {return self._sysidRouting != nil}
  /// Clears the value of `sysidRouting`. Subsequent reads from it will return its default value.
  mutating func clearSysidRouting() {self._sysidRouting = nil}

  var callHandle: UInt32 {
    get {return _callHandle ?? 0}
    set {_callHandle = newValue}
  }
  /// Returns true if `callHandle` has been explicitly set.
  var hasCallHandle: Bool {return self._callHandle != nil}
  /// Clears the value of `callHandle`. Subsequent reads from it will return its default value.
  mutating func clearCallHandle() {self._callHandle = nil}

  var moduleCrc: UInt32 {
    get {return _moduleCrc ?? 0}
    set {_moduleCrc = newValue}
  }
  /// Returns true if `moduleCrc` has been explicitly set.
  var hasModuleCrc: Bool {return self._moduleCrc != nil}
  /// Clears the value of `moduleCrc`. Subsequent reads from it will return its default value.
  mutating func clearModuleCrc() {self._moduleCrc = nil}

  var moduleHash: Data {
    get {return _moduleHash ?? Data()}
    set {_moduleHash = newValue}
  }
  /// Returns true if `moduleHash` has been explicitly set.
  var hasModuleHash: Bool {return self._moduleHash != nil}
  /// Clears the value of `moduleHash`. Subsequent reads from it will return its default value.
  mutating func clearModuleHash() {self._moduleHash = nil}

  var functionID: UInt32 {
    get {return _functionID ?? 0}
    set {_functionID = newValue}
  }
  /// Returns true if `functionID` has been explicitly set.
  var hasFunctionID: Bool {return self._functionID != nil}
  /// Clears the value of `functionID`. Subsequent reads from it will return its default value.
  mutating func clearFunctionID() {self._functionID = nil}

  var cubOutputMax: UInt32 {
    get {return _cubOutputMax ?? 0}
    set {_cubOutputMax = newValue}
  }
  /// Returns true if `cubOutputMax` has been explicitly set.
  var hasCubOutputMax: Bool {return self._cubOutputMax != nil}
  /// Clears the value of `cubOutputMax`. Subsequent reads from it will return its default value.
  mutating func clearCubOutputMax() {self._cubOutputMax = nil}

  var flags: UInt32 {
    get {return _flags ?? 0}
    set {_flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  var hasFlags: Bool {return self._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  mutating func clearFlags() {self._flags = nil}

  var callparameter: Data {
    get {return _callparameter ?? Data()}
    set {_callparameter = newValue}
  }
  /// Returns true if `callparameter` has been explicitly set.
  var hasCallparameter: Bool {return self._callparameter != nil}
  /// Clears the value of `callparameter`. Subsequent reads from it will return its default value.
  mutating func clearCallparameter() {self._callparameter = nil}

  var pingOnly: Bool {
    get {return _pingOnly ?? false}
    set {_pingOnly = newValue}
  }
  /// Returns true if `pingOnly` has been explicitly set.
  var hasPingOnly: Bool {return self._pingOnly != nil}
  /// Clears the value of `pingOnly`. Subsequent reads from it will return its default value.
  mutating func clearPingOnly() {self._pingOnly = nil}

  var maxOutstandingCalls: UInt32 {
    get {return _maxOutstandingCalls ?? 0}
    set {_maxOutstandingCalls = newValue}
  }
  /// Returns true if `maxOutstandingCalls` has been explicitly set.
  var hasMaxOutstandingCalls: Bool {return self._maxOutstandingCalls != nil}
  /// Clears the value of `maxOutstandingCalls`. Subsequent reads from it will return its default value.
  mutating func clearMaxOutstandingCalls() {self._maxOutstandingCalls = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sysidRouting: Data? = nil
  fileprivate var _callHandle: UInt32? = nil
  fileprivate var _moduleCrc: UInt32? = nil
  fileprivate var _moduleHash: Data? = nil
  fileprivate var _functionID: UInt32? = nil
  fileprivate var _cubOutputMax: UInt32? = nil
  fileprivate var _flags: UInt32? = nil
  fileprivate var _callparameter: Data? = nil
  fileprivate var _pingOnly: Bool? = nil
  fileprivate var _maxOutstandingCalls: UInt32? = nil
}

struct CMsgClientServiceModule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var moduleCrc: UInt32 {
    get {return _moduleCrc ?? 0}
    set {_moduleCrc = newValue}
  }
  /// Returns true if `moduleCrc` has been explicitly set.
  var hasModuleCrc: Bool {return self._moduleCrc != nil}
  /// Clears the value of `moduleCrc`. Subsequent reads from it will return its default value.
  mutating func clearModuleCrc() {self._moduleCrc = nil}

  var moduleHash: Data {
    get {return _moduleHash ?? Data()}
    set {_moduleHash = newValue}
  }
  /// Returns true if `moduleHash` has been explicitly set.
  var hasModuleHash: Bool {return self._moduleHash != nil}
  /// Clears the value of `moduleHash`. Subsequent reads from it will return its default value.
  mutating func clearModuleHash() {self._moduleHash = nil}

  var moduleContent: Data {
    get {return _moduleContent ?? Data()}
    set {_moduleContent = newValue}
  }
  /// Returns true if `moduleContent` has been explicitly set.
  var hasModuleContent: Bool {return self._moduleContent != nil}
  /// Clears the value of `moduleContent`. Subsequent reads from it will return its default value.
  mutating func clearModuleContent() {self._moduleContent = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _moduleCrc: UInt32? = nil
  fileprivate var _moduleHash: Data? = nil
  fileprivate var _moduleContent: Data? = nil
}

struct CMsgClientServiceCallResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sysidRouting: Data {
    get {return _storage._sysidRouting ?? Data()}
    set {_uniqueStorage()._sysidRouting = newValue}
  }
  /// Returns true if `sysidRouting` has been explicitly set.
  var hasSysidRouting: Bool {return _storage._sysidRouting != nil}
  /// Clears the value of `sysidRouting`. Subsequent reads from it will return its default value.
  mutating func clearSysidRouting() {_uniqueStorage()._sysidRouting = nil}

  var callHandle: UInt32 {
    get {return _storage._callHandle ?? 0}
    set {_uniqueStorage()._callHandle = newValue}
  }
  /// Returns true if `callHandle` has been explicitly set.
  var hasCallHandle: Bool {return _storage._callHandle != nil}
  /// Clears the value of `callHandle`. Subsequent reads from it will return its default value.
  mutating func clearCallHandle() {_uniqueStorage()._callHandle = nil}

  var moduleCrc: UInt32 {
    get {return _storage._moduleCrc ?? 0}
    set {_uniqueStorage()._moduleCrc = newValue}
  }
  /// Returns true if `moduleCrc` has been explicitly set.
  var hasModuleCrc: Bool {return _storage._moduleCrc != nil}
  /// Clears the value of `moduleCrc`. Subsequent reads from it will return its default value.
  mutating func clearModuleCrc() {_uniqueStorage()._moduleCrc = nil}

  var moduleHash: Data {
    get {return _storage._moduleHash ?? Data()}
    set {_uniqueStorage()._moduleHash = newValue}
  }
  /// Returns true if `moduleHash` has been explicitly set.
  var hasModuleHash: Bool {return _storage._moduleHash != nil}
  /// Clears the value of `moduleHash`. Subsequent reads from it will return its default value.
  mutating func clearModuleHash() {_uniqueStorage()._moduleHash = nil}

  var ecallresult: UInt32 {
    get {return _storage._ecallresult ?? 0}
    set {_uniqueStorage()._ecallresult = newValue}
  }
  /// Returns true if `ecallresult` has been explicitly set.
  var hasEcallresult: Bool {return _storage._ecallresult != nil}
  /// Clears the value of `ecallresult`. Subsequent reads from it will return its default value.
  mutating func clearEcallresult() {_uniqueStorage()._ecallresult = nil}

  var resultContent: Data {
    get {return _storage._resultContent ?? Data()}
    set {_uniqueStorage()._resultContent = newValue}
  }
  /// Returns true if `resultContent` has been explicitly set.
  var hasResultContent: Bool {return _storage._resultContent != nil}
  /// Clears the value of `resultContent`. Subsequent reads from it will return its default value.
  mutating func clearResultContent() {_uniqueStorage()._resultContent = nil}

  var osVersionInfo: Data {
    get {return _storage._osVersionInfo ?? Data()}
    set {_uniqueStorage()._osVersionInfo = newValue}
  }
  /// Returns true if `osVersionInfo` has been explicitly set.
  var hasOsVersionInfo: Bool {return _storage._osVersionInfo != nil}
  /// Clears the value of `osVersionInfo`. Subsequent reads from it will return its default value.
  mutating func clearOsVersionInfo() {_uniqueStorage()._osVersionInfo = nil}

  var systemInfo: Data {
    get {return _storage._systemInfo ?? Data()}
    set {_uniqueStorage()._systemInfo = newValue}
  }
  /// Returns true if `systemInfo` has been explicitly set.
  var hasSystemInfo: Bool {return _storage._systemInfo != nil}
  /// Clears the value of `systemInfo`. Subsequent reads from it will return its default value.
  mutating func clearSystemInfo() {_uniqueStorage()._systemInfo = nil}

  var loadAddress: UInt64 {
    get {return _storage._loadAddress ?? 0}
    set {_uniqueStorage()._loadAddress = newValue}
  }
  /// Returns true if `loadAddress` has been explicitly set.
  var hasLoadAddress: Bool {return _storage._loadAddress != nil}
  /// Clears the value of `loadAddress`. Subsequent reads from it will return its default value.
  mutating func clearLoadAddress() {_uniqueStorage()._loadAddress = nil}

  var exceptionRecord: Data {
    get {return _storage._exceptionRecord ?? Data()}
    set {_uniqueStorage()._exceptionRecord = newValue}
  }
  /// Returns true if `exceptionRecord` has been explicitly set.
  var hasExceptionRecord: Bool {return _storage._exceptionRecord != nil}
  /// Clears the value of `exceptionRecord`. Subsequent reads from it will return its default value.
  mutating func clearExceptionRecord() {_uniqueStorage()._exceptionRecord = nil}

  var portableOsVersionInfo: Data {
    get {return _storage._portableOsVersionInfo ?? Data()}
    set {_uniqueStorage()._portableOsVersionInfo = newValue}
  }
  /// Returns true if `portableOsVersionInfo` has been explicitly set.
  var hasPortableOsVersionInfo: Bool {return _storage._portableOsVersionInfo != nil}
  /// Clears the value of `portableOsVersionInfo`. Subsequent reads from it will return its default value.
  mutating func clearPortableOsVersionInfo() {_uniqueStorage()._portableOsVersionInfo = nil}

  var portableSystemInfo: Data {
    get {return _storage._portableSystemInfo ?? Data()}
    set {_uniqueStorage()._portableSystemInfo = newValue}
  }
  /// Returns true if `portableSystemInfo` has been explicitly set.
  var hasPortableSystemInfo: Bool {return _storage._portableSystemInfo != nil}
  /// Clears the value of `portableSystemInfo`. Subsequent reads from it will return its default value.
  mutating func clearPortableSystemInfo() {_uniqueStorage()._portableSystemInfo = nil}

  var wasConverted: Bool {
    get {return _storage._wasConverted ?? false}
    set {_uniqueStorage()._wasConverted = newValue}
  }
  /// Returns true if `wasConverted` has been explicitly set.
  var hasWasConverted: Bool {return _storage._wasConverted != nil}
  /// Clears the value of `wasConverted`. Subsequent reads from it will return its default value.
  mutating func clearWasConverted() {_uniqueStorage()._wasConverted = nil}

  var internalResult: UInt32 {
    get {return _storage._internalResult ?? 0}
    set {_uniqueStorage()._internalResult = newValue}
  }
  /// Returns true if `internalResult` has been explicitly set.
  var hasInternalResult: Bool {return _storage._internalResult != nil}
  /// Clears the value of `internalResult`. Subsequent reads from it will return its default value.
  mutating func clearInternalResult() {_uniqueStorage()._internalResult = nil}

  var currentCount: UInt32 {
    get {return _storage._currentCount ?? 0}
    set {_uniqueStorage()._currentCount = newValue}
  }
  /// Returns true if `currentCount` has been explicitly set.
  var hasCurrentCount: Bool {return _storage._currentCount != nil}
  /// Clears the value of `currentCount`. Subsequent reads from it will return its default value.
  mutating func clearCurrentCount() {_uniqueStorage()._currentCount = nil}

  var lastCallHandle: UInt32 {
    get {return _storage._lastCallHandle ?? 0}
    set {_uniqueStorage()._lastCallHandle = newValue}
  }
  /// Returns true if `lastCallHandle` has been explicitly set.
  var hasLastCallHandle: Bool {return _storage._lastCallHandle != nil}
  /// Clears the value of `lastCallHandle`. Subsequent reads from it will return its default value.
  mutating func clearLastCallHandle() {_uniqueStorage()._lastCallHandle = nil}

  var lastCallModuleCrc: UInt32 {
    get {return _storage._lastCallModuleCrc ?? 0}
    set {_uniqueStorage()._lastCallModuleCrc = newValue}
  }
  /// Returns true if `lastCallModuleCrc` has been explicitly set.
  var hasLastCallModuleCrc: Bool {return _storage._lastCallModuleCrc != nil}
  /// Clears the value of `lastCallModuleCrc`. Subsequent reads from it will return its default value.
  mutating func clearLastCallModuleCrc() {_uniqueStorage()._lastCallModuleCrc = nil}

  var lastCallSysidRouting: Data {
    get {return _storage._lastCallSysidRouting ?? Data()}
    set {_uniqueStorage()._lastCallSysidRouting = newValue}
  }
  /// Returns true if `lastCallSysidRouting` has been explicitly set.
  var hasLastCallSysidRouting: Bool {return _storage._lastCallSysidRouting != nil}
  /// Clears the value of `lastCallSysidRouting`. Subsequent reads from it will return its default value.
  mutating func clearLastCallSysidRouting() {_uniqueStorage()._lastCallSysidRouting = nil}

  var lastEcallresult: UInt32 {
    get {return _storage._lastEcallresult ?? 0}
    set {_uniqueStorage()._lastEcallresult = newValue}
  }
  /// Returns true if `lastEcallresult` has been explicitly set.
  var hasLastEcallresult: Bool {return _storage._lastEcallresult != nil}
  /// Clears the value of `lastEcallresult`. Subsequent reads from it will return its default value.
  mutating func clearLastEcallresult() {_uniqueStorage()._lastEcallresult = nil}

  var lastCallissueDelta: UInt32 {
    get {return _storage._lastCallissueDelta ?? 0}
    set {_uniqueStorage()._lastCallissueDelta = newValue}
  }
  /// Returns true if `lastCallissueDelta` has been explicitly set.
  var hasLastCallissueDelta: Bool {return _storage._lastCallissueDelta != nil}
  /// Clears the value of `lastCallissueDelta`. Subsequent reads from it will return its default value.
  mutating func clearLastCallissueDelta() {_uniqueStorage()._lastCallissueDelta = nil}

  var lastCallcompleteDelta: UInt32 {
    get {return _storage._lastCallcompleteDelta ?? 0}
    set {_uniqueStorage()._lastCallcompleteDelta = newValue}
  }
  /// Returns true if `lastCallcompleteDelta` has been explicitly set.
  var hasLastCallcompleteDelta: Bool {return _storage._lastCallcompleteDelta != nil}
  /// Clears the value of `lastCallcompleteDelta`. Subsequent reads from it will return its default value.
  mutating func clearLastCallcompleteDelta() {_uniqueStorage()._lastCallcompleteDelta = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CMsgAMUnlockStreaming {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CMsgAMUnlockStreamingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var encryptionKey: Data {
    get {return _encryptionKey ?? Data()}
    set {_encryptionKey = newValue}
  }
  /// Returns true if `encryptionKey` has been explicitly set.
  var hasEncryptionKey: Bool {return self._encryptionKey != nil}
  /// Clears the value of `encryptionKey`. Subsequent reads from it will return its default value.
  mutating func clearEncryptionKey() {self._encryptionKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: Int32? = nil
  fileprivate var _encryptionKey: Data? = nil
}

struct CMsgAMUnlockHEVC {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CMsgAMUnlockHEVCResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _eresult: Int32? = nil
}

struct CMsgClientPlayingSessionState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var playingBlocked: Bool {
    get {return _playingBlocked ?? false}
    set {_playingBlocked = newValue}
  }
  /// Returns true if `playingBlocked` has been explicitly set.
  var hasPlayingBlocked: Bool {return self._playingBlocked != nil}
  /// Clears the value of `playingBlocked`. Subsequent reads from it will return its default value.
  mutating func clearPlayingBlocked() {self._playingBlocked = nil}

  var playingApp: UInt32 {
    get {return _playingApp ?? 0}
    set {_playingApp = newValue}
  }
  /// Returns true if `playingApp` has been explicitly set.
  var hasPlayingApp: Bool {return self._playingApp != nil}
  /// Clears the value of `playingApp`. Subsequent reads from it will return its default value.
  mutating func clearPlayingApp() {self._playingApp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _playingBlocked: Bool? = nil
  fileprivate var _playingApp: UInt32? = nil
}

struct CMsgClientKickPlayingSession {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var onlyStopGame: Bool {
    get {return _onlyStopGame ?? false}
    set {_onlyStopGame = newValue}
  }
  /// Returns true if `onlyStopGame` has been explicitly set.
  var hasOnlyStopGame: Bool {return self._onlyStopGame != nil}
  /// Clears the value of `onlyStopGame`. Subsequent reads from it will return its default value.
  mutating func clearOnlyStopGame() {self._onlyStopGame = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _onlyStopGame: Bool? = nil
}

struct CMsgClientVoiceCallPreAuthorize {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var callerSteamid: UInt64 {
    get {return _callerSteamid ?? 0}
    set {_callerSteamid = newValue}
  }
  /// Returns true if `callerSteamid` has been explicitly set.
  var hasCallerSteamid: Bool {return self._callerSteamid != nil}
  /// Clears the value of `callerSteamid`. Subsequent reads from it will return its default value.
  mutating func clearCallerSteamid() {self._callerSteamid = nil}

  var receiverSteamid: UInt64 {
    get {return _receiverSteamid ?? 0}
    set {_receiverSteamid = newValue}
  }
  /// Returns true if `receiverSteamid` has been explicitly set.
  var hasReceiverSteamid: Bool {return self._receiverSteamid != nil}
  /// Clears the value of `receiverSteamid`. Subsequent reads from it will return its default value.
  mutating func clearReceiverSteamid() {self._receiverSteamid = nil}

  var callerID: Int32 {
    get {return _callerID ?? 0}
    set {_callerID = newValue}
  }
  /// Returns true if `callerID` has been explicitly set.
  var hasCallerID: Bool {return self._callerID != nil}
  /// Clears the value of `callerID`. Subsequent reads from it will return its default value.
  mutating func clearCallerID() {self._callerID = nil}

  var hangup: Bool {
    get {return _hangup ?? false}
    set {_hangup = newValue}
  }
  /// Returns true if `hangup` has been explicitly set.
  var hasHangup: Bool {return self._hangup != nil}
  /// Clears the value of `hangup`. Subsequent reads from it will return its default value.
  mutating func clearHangup() {self._hangup = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _callerSteamid: UInt64? = nil
  fileprivate var _receiverSteamid: UInt64? = nil
  fileprivate var _callerID: Int32? = nil
  fileprivate var _hangup: Bool? = nil
}

struct CMsgClientVoiceCallPreAuthorizeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var callerSteamid: UInt64 {
    get {return _callerSteamid ?? 0}
    set {_callerSteamid = newValue}
  }
  /// Returns true if `callerSteamid` has been explicitly set.
  var hasCallerSteamid: Bool {return self._callerSteamid != nil}
  /// Clears the value of `callerSteamid`. Subsequent reads from it will return its default value.
  mutating func clearCallerSteamid() {self._callerSteamid = nil}

  var receiverSteamid: UInt64 {
    get {return _receiverSteamid ?? 0}
    set {_receiverSteamid = newValue}
  }
  /// Returns true if `receiverSteamid` has been explicitly set.
  var hasReceiverSteamid: Bool {return self._receiverSteamid != nil}
  /// Clears the value of `receiverSteamid`. Subsequent reads from it will return its default value.
  mutating func clearReceiverSteamid() {self._receiverSteamid = nil}

  var eresult: Int32 {
    get {return _eresult ?? 2}
    set {_eresult = newValue}
  }
  /// Returns true if `eresult` has been explicitly set.
  var hasEresult: Bool {return self._eresult != nil}
  /// Clears the value of `eresult`. Subsequent reads from it will return its default value.
  mutating func clearEresult() {self._eresult = nil}

  var callerID: Int32 {
    get {return _callerID ?? 0}
    set {_callerID = newValue}
  }
  /// Returns true if `callerID` has been explicitly set.
  var hasCallerID: Bool {return self._callerID != nil}
  /// Clears the value of `callerID`. Subsequent reads from it will return its default value.
  mutating func clearCallerID() {self._callerID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _callerSteamid: UInt64? = nil
  fileprivate var _receiverSteamid: UInt64? = nil
  fileprivate var _eresult: Int32? = nil
  fileprivate var _callerID: Int32? = nil
}

struct CMsgBadgeCraftedNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appid: UInt32 {
    get {return _appid ?? 0}
    set {_appid = newValue}
  }
  /// Returns true if `appid` has been explicitly set.
  var hasAppid: Bool {return self._appid != nil}
  /// Clears the value of `appid`. Subsequent reads from it will return its default value.
  mutating func clearAppid() {self._appid = nil}

  var badgeLevel: UInt32 {
    get {return _badgeLevel ?? 0}
    set {_badgeLevel = newValue}
  }
  /// Returns true if `badgeLevel` has been explicitly set.
  var hasBadgeLevel: Bool {return self._badgeLevel != nil}
  /// Clears the value of `badgeLevel`. Subsequent reads from it will return its default value.
  mutating func clearBadgeLevel() {self._badgeLevel = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _appid: UInt32? = nil
  fileprivate var _badgeLevel: UInt32? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension CMsgClientUCMAddScreenshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUCMAddScreenshot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appid"),
    2: .same(proto: "filename"),
    3: .same(proto: "thumbname"),
    14: .standard(proto: "vr_filename"),
    4: .standard(proto: "rtime32_created"),
    5: .same(proto: "width"),
    6: .same(proto: "height"),
    7: .same(proto: "permissions"),
    8: .same(proto: "caption"),
    9: .standard(proto: "shortcut_name"),
    10: .same(proto: "tag"),
    11: .standard(proto: "tagged_steamid"),
    12: .standard(proto: "spoiler_tag"),
    13: .standard(proto: "tagged_publishedfileid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._appid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._filename) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._thumbname) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._rtime32Created) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._width) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._height) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._permissions) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._caption) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._shortcutName) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.tag) }()
      case 11: try { try decoder.decodeRepeatedFixed64Field(value: &self.taggedSteamid) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self._spoilerTag) }()
      case 13: try { try decoder.decodeRepeatedUInt64Field(value: &self.taggedPublishedfileid) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self._vrFilename) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._appid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._filename {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._thumbname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._rtime32Created {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    }
    if let v = self._width {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._height {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._permissions {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._caption {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    }
    if let v = self._shortcutName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    }
    if !self.tag.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tag, fieldNumber: 10)
    }
    if !self.taggedSteamid.isEmpty {
      try visitor.visitRepeatedFixed64Field(value: self.taggedSteamid, fieldNumber: 11)
    }
    if let v = self._spoilerTag {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
    }
    if !self.taggedPublishedfileid.isEmpty {
      try visitor.visitRepeatedUInt64Field(value: self.taggedPublishedfileid, fieldNumber: 13)
    }
    if let v = self._vrFilename {
      try visitor.visitSingularStringField(value: v, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMAddScreenshot, rhs: CMsgClientUCMAddScreenshot) -> Bool {
    if lhs._appid != rhs._appid {return false}
    if lhs._filename != rhs._filename {return false}
    if lhs._thumbname != rhs._thumbname {return false}
    if lhs._vrFilename != rhs._vrFilename {return false}
    if lhs._rtime32Created != rhs._rtime32Created {return false}
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs._permissions != rhs._permissions {return false}
    if lhs._caption != rhs._caption {return false}
    if lhs._shortcutName != rhs._shortcutName {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.taggedSteamid != rhs.taggedSteamid {return false}
    if lhs._spoilerTag != rhs._spoilerTag {return false}
    if lhs.taggedPublishedfileid != rhs.taggedPublishedfileid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUCMAddScreenshot.Tag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientUCMAddScreenshot.protoMessageName + ".Tag"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tag_name"),
    2: .standard(proto: "tag_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._tagName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._tagValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._tagName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._tagValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMAddScreenshot.Tag, rhs: CMsgClientUCMAddScreenshot.Tag) -> Bool {
    if lhs._tagName != rhs._tagName {return false}
    if lhs._tagValue != rhs._tagValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUCMAddScreenshotResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUCMAddScreenshotResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .same(proto: "screenshotid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self._screenshotid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._screenshotid {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMAddScreenshotResponse, rhs: CMsgClientUCMAddScreenshotResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs._screenshotid != rhs._screenshotid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUCMDeleteScreenshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUCMDeleteScreenshot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "screenshotid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._screenshotid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._screenshotid {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMDeleteScreenshot, rhs: CMsgClientUCMDeleteScreenshot) -> Bool {
    if lhs._screenshotid != rhs._screenshotid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUCMDeleteScreenshotResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUCMDeleteScreenshotResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMDeleteScreenshotResponse, rhs: CMsgClientUCMDeleteScreenshotResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUCMPublishFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUCMPublishFile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "file_name"),
    3: .standard(proto: "preview_file_name"),
    4: .standard(proto: "consumer_app_id"),
    5: .same(proto: "title"),
    6: .same(proto: "description"),
    8: .same(proto: "tags"),
    9: .standard(proto: "workshop_file"),
    10: .same(proto: "visibility"),
    11: .standard(proto: "file_type"),
    12: .same(proto: "url"),
    13: .standard(proto: "video_provider"),
    14: .standard(proto: "video_account_name"),
    15: .standard(proto: "video_identifier"),
    16: .standard(proto: "in_progress"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._appID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._fileName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._previewFileName) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._consumerAppID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self._workshopFile) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self._visibility) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self._fileType) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._url) }()
      case 13: try { try decoder.decodeSingularUInt32Field(value: &self._videoProvider) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self._videoAccountName) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self._videoIdentifier) }()
      case 16: try { try decoder.decodeSingularBoolField(value: &self._inProgress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._appID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._fileName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._previewFileName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._consumerAppID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 8)
    }
    if let v = self._workshopFile {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    }
    if let v = self._visibility {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
    }
    if let v = self._fileType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
    }
    if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    }
    if let v = self._videoProvider {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 13)
    }
    if let v = self._videoAccountName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 14)
    }
    if let v = self._videoIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 15)
    }
    if let v = self._inProgress {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMPublishFile, rhs: CMsgClientUCMPublishFile) -> Bool {
    if lhs._appID != rhs._appID {return false}
    if lhs._fileName != rhs._fileName {return false}
    if lhs._previewFileName != rhs._previewFileName {return false}
    if lhs._consumerAppID != rhs._consumerAppID {return false}
    if lhs._title != rhs._title {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs._workshopFile != rhs._workshopFile {return false}
    if lhs._visibility != rhs._visibility {return false}
    if lhs._fileType != rhs._fileType {return false}
    if lhs._url != rhs._url {return false}
    if lhs._videoProvider != rhs._videoProvider {return false}
    if lhs._videoAccountName != rhs._videoAccountName {return false}
    if lhs._videoIdentifier != rhs._videoIdentifier {return false}
    if lhs._inProgress != rhs._inProgress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUCMPublishFileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUCMPublishFileResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "published_file_id"),
    3: .standard(proto: "needs_workshop_legal_agreement_acceptance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self._publishedFileID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._needsWorkshopLegalAgreementAcceptance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._publishedFileID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 2)
    }
    if let v = self._needsWorkshopLegalAgreementAcceptance {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMPublishFileResponse, rhs: CMsgClientUCMPublishFileResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs._publishedFileID != rhs._publishedFileID {return false}
    if lhs._needsWorkshopLegalAgreementAcceptance != rhs._needsWorkshopLegalAgreementAcceptance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUCMUpdatePublishedFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUCMUpdatePublishedFile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "published_file_id"),
    3: .standard(proto: "file_name"),
    4: .standard(proto: "preview_file_name"),
    5: .same(proto: "title"),
    6: .same(proto: "description"),
    7: .same(proto: "tags"),
    8: .same(proto: "visibility"),
    9: .standard(proto: "update_file"),
    10: .standard(proto: "update_preview_file"),
    11: .standard(proto: "update_title"),
    12: .standard(proto: "update_description"),
    13: .standard(proto: "update_tags"),
    14: .standard(proto: "update_visibility"),
    15: .standard(proto: "change_description"),
    16: .standard(proto: "update_url"),
    17: .same(proto: "url"),
    18: .standard(proto: "update_content_manifest"),
    19: .standard(proto: "content_manifest"),
    20: .same(proto: "metadata"),
    21: .standard(proto: "update_metadata"),
    22: .same(proto: "language"),
    23: .standard(proto: "removed_kvtags"),
    24: .same(proto: "kvtags"),
    25: .same(proto: "previews"),
    26: .standard(proto: "previews_to_remove"),
    27: .standard(proto: "clear_in_progress"),
    28: .standard(proto: "remove_all_kvtags"),
  ]

  fileprivate class _StorageClass {
    var _appID: UInt32? = nil
    var _publishedFileID: UInt64? = nil
    var _fileName: String? = nil
    var _previewFileName: String? = nil
    var _title: String? = nil
    var _description_p: String? = nil
    var _tags: [String] = []
    var _visibility: Int32? = nil
    var _updateFile: Bool? = nil
    var _updatePreviewFile: Bool? = nil
    var _updateTitle: Bool? = nil
    var _updateDescription: Bool? = nil
    var _updateTags: Bool? = nil
    var _updateVisibility: Bool? = nil
    var _changeDescription: String? = nil
    var _updateURL: Bool? = nil
    var _url: String? = nil
    var _updateContentManifest: Bool? = nil
    var _contentManifest: UInt64? = nil
    var _metadata: String? = nil
    var _updateMetadata: Bool? = nil
    var _language: Int32? = nil
    var _removedKvtags: [String] = []
    var _kvtags: [CMsgClientUCMUpdatePublishedFile.KeyValueTag] = []
    var _previews: [CMsgClientUCMUpdatePublishedFile.AdditionalPreview] = []
    var _previewsToRemove: [Int32] = []
    var _clearInProgress_p: Bool? = nil
    var _removeAllKvtags: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _appID = source._appID
      _publishedFileID = source._publishedFileID
      _fileName = source._fileName
      _previewFileName = source._previewFileName
      _title = source._title
      _description_p = source._description_p
      _tags = source._tags
      _visibility = source._visibility
      _updateFile = source._updateFile
      _updatePreviewFile = source._updatePreviewFile
      _updateTitle = source._updateTitle
      _updateDescription = source._updateDescription
      _updateTags = source._updateTags
      _updateVisibility = source._updateVisibility
      _changeDescription = source._changeDescription
      _updateURL = source._updateURL
      _url = source._url
      _updateContentManifest = source._updateContentManifest
      _contentManifest = source._contentManifest
      _metadata = source._metadata
      _updateMetadata = source._updateMetadata
      _language = source._language
      _removedKvtags = source._removedKvtags
      _kvtags = source._kvtags
      _previews = source._previews
      _previewsToRemove = source._previewsToRemove
      _clearInProgress_p = source._clearInProgress_p
      _removeAllKvtags = source._removeAllKvtags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._appID) }()
        case 2: try { try decoder.decodeSingularFixed64Field(value: &_storage._publishedFileID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._fileName) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._previewFileName) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._tags) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._visibility) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._updateFile) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._updatePreviewFile) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._updateTitle) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._updateDescription) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._updateTags) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._updateVisibility) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._changeDescription) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._updateURL) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._updateContentManifest) }()
        case 19: try { try decoder.decodeSingularFixed64Field(value: &_storage._contentManifest) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._metadata) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._updateMetadata) }()
        case 22: try { try decoder.decodeSingularInt32Field(value: &_storage._language) }()
        case 23: try { try decoder.decodeRepeatedStringField(value: &_storage._removedKvtags) }()
        case 24: try { try decoder.decodeRepeatedMessageField(value: &_storage._kvtags) }()
        case 25: try { try decoder.decodeRepeatedMessageField(value: &_storage._previews) }()
        case 26: try { try decoder.decodeRepeatedInt32Field(value: &_storage._previewsToRemove) }()
        case 27: try { try decoder.decodeSingularBoolField(value: &_storage._clearInProgress_p) }()
        case 28: try { try decoder.decodeSingularBoolField(value: &_storage._removeAllKvtags) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._appID {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._publishedFileID {
        try visitor.visitSingularFixed64Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._fileName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._previewFileName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._title {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._description_p {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tags, fieldNumber: 7)
      }
      if let v = _storage._visibility {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
      }
      if let v = _storage._updateFile {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      }
      if let v = _storage._updatePreviewFile {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      }
      if let v = _storage._updateTitle {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      }
      if let v = _storage._updateDescription {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      }
      if let v = _storage._updateTags {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      }
      if let v = _storage._updateVisibility {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      }
      if let v = _storage._changeDescription {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      }
      if let v = _storage._updateURL {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      }
      if let v = _storage._url {
        try visitor.visitSingularStringField(value: v, fieldNumber: 17)
      }
      if let v = _storage._updateContentManifest {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 18)
      }
      if let v = _storage._contentManifest {
        try visitor.visitSingularFixed64Field(value: v, fieldNumber: 19)
      }
      if let v = _storage._metadata {
        try visitor.visitSingularStringField(value: v, fieldNumber: 20)
      }
      if let v = _storage._updateMetadata {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 21)
      }
      if let v = _storage._language {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 22)
      }
      if !_storage._removedKvtags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._removedKvtags, fieldNumber: 23)
      }
      if !_storage._kvtags.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._kvtags, fieldNumber: 24)
      }
      if !_storage._previews.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._previews, fieldNumber: 25)
      }
      if !_storage._previewsToRemove.isEmpty {
        try visitor.visitRepeatedInt32Field(value: _storage._previewsToRemove, fieldNumber: 26)
      }
      if let v = _storage._clearInProgress_p {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 27)
      }
      if let v = _storage._removeAllKvtags {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 28)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMUpdatePublishedFile, rhs: CMsgClientUCMUpdatePublishedFile) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._publishedFileID != rhs_storage._publishedFileID {return false}
        if _storage._fileName != rhs_storage._fileName {return false}
        if _storage._previewFileName != rhs_storage._previewFileName {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._visibility != rhs_storage._visibility {return false}
        if _storage._updateFile != rhs_storage._updateFile {return false}
        if _storage._updatePreviewFile != rhs_storage._updatePreviewFile {return false}
        if _storage._updateTitle != rhs_storage._updateTitle {return false}
        if _storage._updateDescription != rhs_storage._updateDescription {return false}
        if _storage._updateTags != rhs_storage._updateTags {return false}
        if _storage._updateVisibility != rhs_storage._updateVisibility {return false}
        if _storage._changeDescription != rhs_storage._changeDescription {return false}
        if _storage._updateURL != rhs_storage._updateURL {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._updateContentManifest != rhs_storage._updateContentManifest {return false}
        if _storage._contentManifest != rhs_storage._contentManifest {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._updateMetadata != rhs_storage._updateMetadata {return false}
        if _storage._language != rhs_storage._language {return false}
        if _storage._removedKvtags != rhs_storage._removedKvtags {return false}
        if _storage._kvtags != rhs_storage._kvtags {return false}
        if _storage._previews != rhs_storage._previews {return false}
        if _storage._previewsToRemove != rhs_storage._previewsToRemove {return false}
        if _storage._clearInProgress_p != rhs_storage._clearInProgress_p {return false}
        if _storage._removeAllKvtags != rhs_storage._removeAllKvtags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUCMUpdatePublishedFile.KeyValueTag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientUCMUpdatePublishedFile.protoMessageName + ".KeyValueTag"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMUpdatePublishedFile.KeyValueTag, rhs: CMsgClientUCMUpdatePublishedFile.KeyValueTag) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUCMUpdatePublishedFile.AdditionalPreview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientUCMUpdatePublishedFile.protoMessageName + ".AdditionalPreview"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "original_file_name"),
    2: .standard(proto: "internal_file_name"),
    3: .same(proto: "videoid"),
    4: .standard(proto: "preview_type"),
    5: .standard(proto: "update_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._originalFileName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._internalFileName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._videoid) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._previewType) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._updateIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._originalFileName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._internalFileName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._videoid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._previewType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._updateIndex {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMUpdatePublishedFile.AdditionalPreview, rhs: CMsgClientUCMUpdatePublishedFile.AdditionalPreview) -> Bool {
    if lhs._originalFileName != rhs._originalFileName {return false}
    if lhs._internalFileName != rhs._internalFileName {return false}
    if lhs._videoid != rhs._videoid {return false}
    if lhs._previewType != rhs._previewType {return false}
    if lhs._updateIndex != rhs._updateIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUCMUpdatePublishedFileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUCMUpdatePublishedFileResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "needs_workshop_legal_agreement_acceptance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._needsWorkshopLegalAgreementAcceptance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._needsWorkshopLegalAgreementAcceptance {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMUpdatePublishedFileResponse, rhs: CMsgClientUCMUpdatePublishedFileResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs._needsWorkshopLegalAgreementAcceptance != rhs._needsWorkshopLegalAgreementAcceptance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUCMDeletePublishedFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUCMDeletePublishedFile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "published_file_id"),
    2: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._publishedFileID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._publishedFileID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._appID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMDeletePublishedFile, rhs: CMsgClientUCMDeletePublishedFile) -> Bool {
    if lhs._publishedFileID != rhs._publishedFileID {return false}
    if lhs._appID != rhs._appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUCMDeletePublishedFileResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUCMDeletePublishedFileResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMDeletePublishedFileResponse, rhs: CMsgClientUCMDeletePublishedFileResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "start_index"),
    3: .standard(proto: "start_time"),
    4: .standard(proto: "desired_revision"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._appID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._startIndex) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._startTime) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._desiredRevision) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._appID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._startIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._startTime {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    }
    if let v = self._desiredRevision {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates, rhs: CMsgClientUCMEnumerateUserSubscribedFilesWithUpdates) -> Bool {
    if lhs._appID != rhs._appID {return false}
    if lhs._startIndex != rhs._startIndex {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._desiredRevision != rhs._desiredRevision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "subscribed_files"),
    3: .standard(proto: "total_results"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.subscribedFiles) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._totalResults) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if !self.subscribedFiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subscribedFiles, fieldNumber: 2)
    }
    if let v = self._totalResults {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse, rhs: CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs.subscribedFiles != rhs.subscribedFiles {return false}
    if lhs._totalResults != rhs._totalResults {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.protoMessageName + ".PublishedFileId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "published_file_id"),
    2: .standard(proto: "rtime32_subscribed"),
    3: .same(proto: "appid"),
    4: .standard(proto: "file_hcontent"),
    5: .standard(proto: "file_size"),
    6: .standard(proto: "rtime32_last_updated"),
    7: .standard(proto: "is_depot_content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._publishedFileID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._rtime32Subscribed) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._appid) }()
      case 4: try { try decoder.decodeSingularFixed64Field(value: &self._fileHcontent) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._fileSize) }()
      case 6: try { try decoder.decodeSingularFixed32Field(value: &self._rtime32LastUpdated) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._isDepotContent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._publishedFileID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._rtime32Subscribed {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    }
    if let v = self._appid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._fileHcontent {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 4)
    }
    if let v = self._fileSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._rtime32LastUpdated {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 6)
    }
    if let v = self._isDepotContent {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId, rhs: CMsgClientUCMEnumerateUserSubscribedFilesWithUpdatesResponse.PublishedFileId) -> Bool {
    if lhs._publishedFileID != rhs._publishedFileID {return false}
    if lhs._rtime32Subscribed != rhs._rtime32Subscribed {return false}
    if lhs._appid != rhs._appid {return false}
    if lhs._fileHcontent != rhs._fileHcontent {return false}
    if lhs._fileSize != rhs._fileSize {return false}
    if lhs._rtime32LastUpdated != rhs._rtime32LastUpdated {return false}
    if lhs._isDepotContent != rhs._isDepotContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUCMPublishedFileUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUCMPublishedFileUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "published_file_id"),
    2: .standard(proto: "app_id"),
    3: .standard(proto: "time_updated"),
    4: .same(proto: "hcontent"),
    5: .standard(proto: "file_size"),
    6: .standard(proto: "is_depot_content"),
    7: .same(proto: "revision"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._publishedFileID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._appID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._timeUpdated) }()
      case 4: try { try decoder.decodeSingularFixed64Field(value: &self._hcontent) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._fileSize) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._isDepotContent) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._revision) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._publishedFileID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._appID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._timeUpdated {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._hcontent {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 4)
    }
    if let v = self._fileSize {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    }
    if let v = self._isDepotContent {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }
    if let v = self._revision {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMPublishedFileUpdated, rhs: CMsgClientUCMPublishedFileUpdated) -> Bool {
    if lhs._publishedFileID != rhs._publishedFileID {return false}
    if lhs._appID != rhs._appID {return false}
    if lhs._timeUpdated != rhs._timeUpdated {return false}
    if lhs._hcontent != rhs._hcontent {return false}
    if lhs._fileSize != rhs._fileSize {return false}
    if lhs._isDepotContent != rhs._isDepotContent {return false}
    if lhs._revision != rhs._revision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientWorkshopItemChangesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientWorkshopItemChangesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "last_time_updated"),
    3: .standard(proto: "num_items_needed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._appID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._lastTimeUpdated) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._numItemsNeeded) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._appID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._lastTimeUpdated {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._numItemsNeeded {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientWorkshopItemChangesRequest, rhs: CMsgClientWorkshopItemChangesRequest) -> Bool {
    if lhs._appID != rhs._appID {return false}
    if lhs._lastTimeUpdated != rhs._lastTimeUpdated {return false}
    if lhs._numItemsNeeded != rhs._numItemsNeeded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientWorkshopItemChangesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientWorkshopItemChangesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "update_time"),
    5: .standard(proto: "workshop_items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._updateTime) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.workshopItems) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._updateTime {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if !self.workshopItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workshopItems, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientWorkshopItemChangesResponse, rhs: CMsgClientWorkshopItemChangesResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.workshopItems != rhs.workshopItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientWorkshopItemChangesResponse.protoMessageName + ".WorkshopItemInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "published_file_id"),
    2: .standard(proto: "time_updated"),
    3: .standard(proto: "manifest_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._publishedFileID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._timeUpdated) }()
      case 3: try { try decoder.decodeSingularFixed64Field(value: &self._manifestID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._publishedFileID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._timeUpdated {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._manifestID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo, rhs: CMsgClientWorkshopItemChangesResponse.WorkshopItemInfo) -> Bool {
    if lhs._publishedFileID != rhs._publishedFileID {return false}
    if lhs._timeUpdated != rhs._timeUpdated {return false}
    if lhs._manifestID != rhs._manifestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUCMSetUserPublishedFileAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUCMSetUserPublishedFileAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "published_file_id"),
    2: .standard(proto: "app_id"),
    3: .same(proto: "action"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._publishedFileID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._appID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._action) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._publishedFileID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._appID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._action {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMSetUserPublishedFileAction, rhs: CMsgClientUCMSetUserPublishedFileAction) -> Bool {
    if lhs._publishedFileID != rhs._publishedFileID {return false}
    if lhs._appID != rhs._appID {return false}
    if lhs._action != rhs._action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUCMSetUserPublishedFileActionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUCMSetUserPublishedFileActionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMSetUserPublishedFileActionResponse, rhs: CMsgClientUCMSetUserPublishedFileActionResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUCMEnumeratePublishedFilesByUserAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUCMEnumeratePublishedFilesByUserAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "start_index"),
    3: .same(proto: "action"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._appID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._startIndex) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._action) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._appID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._startIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._action {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMEnumeratePublishedFilesByUserAction, rhs: CMsgClientUCMEnumeratePublishedFilesByUserAction) -> Bool {
    if lhs._appID != rhs._appID {return false}
    if lhs._startIndex != rhs._startIndex {return false}
    if lhs._action != rhs._action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUCMEnumeratePublishedFilesByUserActionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUCMEnumeratePublishedFilesByUserActionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "published_files"),
    3: .standard(proto: "total_results"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.publishedFiles) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._totalResults) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if !self.publishedFiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publishedFiles, fieldNumber: 2)
    }
    if let v = self._totalResults {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMEnumeratePublishedFilesByUserActionResponse, rhs: CMsgClientUCMEnumeratePublishedFilesByUserActionResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs.publishedFiles != rhs.publishedFiles {return false}
    if lhs._totalResults != rhs._totalResults {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.protoMessageName + ".PublishedFileId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "published_file_id"),
    2: .standard(proto: "rtime_time_stamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._publishedFileID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._rtimeTimeStamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._publishedFileID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._rtimeTimeStamp {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId, rhs: CMsgClientUCMEnumeratePublishedFilesByUserActionResponse.PublishedFileId) -> Bool {
    if lhs._publishedFileID != rhs._publishedFileID {return false}
    if lhs._rtimeTimeStamp != rhs._rtimeTimeStamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientScreenshotsChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientScreenshotsChanged"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientScreenshotsChanged, rhs: CMsgClientScreenshotsChanged) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUpdateUserGameInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUpdateUserGameInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "steamid_idgs"),
    2: .same(proto: "gameid"),
    3: .standard(proto: "game_ip"),
    4: .standard(proto: "game_port"),
    5: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._steamidIdgs) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self._gameid) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._gameIp) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._gamePort) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._steamidIdgs {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._gameid {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 2)
    }
    if let v = self._gameIp {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._gamePort {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._token {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUpdateUserGameInfo, rhs: CMsgClientUpdateUserGameInfo) -> Bool {
    if lhs._steamidIdgs != rhs._steamidIdgs {return false}
    if lhs._gameid != rhs._gameid {return false}
    if lhs._gameIp != rhs._gameIp {return false}
    if lhs._gamePort != rhs._gamePort {return false}
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRichPresenceUpload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRichPresenceUpload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rich_presence_kv"),
    2: .standard(proto: "steamid_broadcast"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._richPresenceKv) }()
      case 2: try { try decoder.decodeRepeatedFixed64Field(value: &self.steamidBroadcast) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._richPresenceKv {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if !self.steamidBroadcast.isEmpty {
      try visitor.visitRepeatedFixed64Field(value: self.steamidBroadcast, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRichPresenceUpload, rhs: CMsgClientRichPresenceUpload) -> Bool {
    if lhs._richPresenceKv != rhs._richPresenceKv {return false}
    if lhs.steamidBroadcast != rhs.steamidBroadcast {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRichPresenceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRichPresenceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "steamid_request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFixed64Field(value: &self.steamidRequest) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.steamidRequest.isEmpty {
      try visitor.visitRepeatedFixed64Field(value: self.steamidRequest, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRichPresenceRequest, rhs: CMsgClientRichPresenceRequest) -> Bool {
    if lhs.steamidRequest != rhs.steamidRequest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRichPresenceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRichPresenceInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rich_presence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.richPresence) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.richPresence.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.richPresence, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRichPresenceInfo, rhs: CMsgClientRichPresenceInfo) -> Bool {
    if lhs.richPresence != rhs.richPresence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRichPresenceInfo.RichPresence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientRichPresenceInfo.protoMessageName + ".RichPresence"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "steamid_user"),
    2: .standard(proto: "rich_presence_kv"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._steamidUser) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._richPresenceKv) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._steamidUser {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._richPresenceKv {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRichPresenceInfo.RichPresence, rhs: CMsgClientRichPresenceInfo.RichPresence) -> Bool {
    if lhs._steamidUser != rhs._steamidUser {return false}
    if lhs._richPresenceKv != rhs._richPresenceKv {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientCheckFileSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientCheckFileSignature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._appID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientCheckFileSignature, rhs: CMsgClientCheckFileSignature) -> Bool {
    if lhs._appID != rhs._appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientCheckFileSignatureResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientCheckFileSignatureResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .same(proto: "pid"),
    3: .same(proto: "eresult"),
    4: .same(proto: "filename"),
    5: .same(proto: "esignatureresult"),
    6: .standard(proto: "sha_file"),
    7: .same(proto: "signatureheader"),
    8: .same(proto: "filesize"),
    9: .same(proto: "getlasterror"),
    10: .same(proto: "evalvesignaturecheckdetail"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._appID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._pid) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._eresult) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._filename) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._esignatureresult) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._shaFile) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self._signatureheader) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._filesize) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._getlasterror) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._evalvesignaturecheckdetail) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._appID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._pid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._eresult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._filename {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._esignatureresult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._shaFile {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    }
    if let v = self._signatureheader {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    }
    if let v = self._filesize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    }
    if let v = self._getlasterror {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    }
    if let v = self._evalvesignaturecheckdetail {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientCheckFileSignatureResponse, rhs: CMsgClientCheckFileSignatureResponse) -> Bool {
    if lhs._appID != rhs._appID {return false}
    if lhs._pid != rhs._pid {return false}
    if lhs._eresult != rhs._eresult {return false}
    if lhs._filename != rhs._filename {return false}
    if lhs._esignatureresult != rhs._esignatureresult {return false}
    if lhs._shaFile != rhs._shaFile {return false}
    if lhs._signatureheader != rhs._signatureheader {return false}
    if lhs._filesize != rhs._filesize {return false}
    if lhs._getlasterror != rhs._getlasterror {return false}
    if lhs._evalvesignaturecheckdetail != rhs._evalvesignaturecheckdetail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientReadMachineAuth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientReadMachineAuth"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filename"),
    2: .same(proto: "offset"),
    3: .same(proto: "cubtoread"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._filename) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._offset) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._cubtoread) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._filename {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._offset {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._cubtoread {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientReadMachineAuth, rhs: CMsgClientReadMachineAuth) -> Bool {
    if lhs._filename != rhs._filename {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs._cubtoread != rhs._cubtoread {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientReadMachineAuthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientReadMachineAuthResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filename"),
    2: .same(proto: "eresult"),
    3: .same(proto: "filesize"),
    4: .standard(proto: "sha_file"),
    5: .same(proto: "getlasterror"),
    6: .same(proto: "offset"),
    7: .same(proto: "cubread"),
    8: .standard(proto: "bytes_read"),
    9: .standard(proto: "filename_sentry"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._filename) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._eresult) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._filesize) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._shaFile) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._getlasterror) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._offset) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._cubread) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self._bytesRead) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._filenameSentry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._filename {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._eresult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._filesize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._shaFile {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }
    if let v = self._getlasterror {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._offset {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._cubread {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._bytesRead {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
    }
    if let v = self._filenameSentry {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientReadMachineAuthResponse, rhs: CMsgClientReadMachineAuthResponse) -> Bool {
    if lhs._filename != rhs._filename {return false}
    if lhs._eresult != rhs._eresult {return false}
    if lhs._filesize != rhs._filesize {return false}
    if lhs._shaFile != rhs._shaFile {return false}
    if lhs._getlasterror != rhs._getlasterror {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs._cubread != rhs._cubread {return false}
    if lhs._bytesRead != rhs._bytesRead {return false}
    if lhs._filenameSentry != rhs._filenameSentry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUpdateMachineAuth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUpdateMachineAuth"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filename"),
    2: .same(proto: "offset"),
    3: .same(proto: "cubtowrite"),
    4: .same(proto: "bytes"),
    5: .standard(proto: "otp_type"),
    6: .standard(proto: "otp_identifier"),
    7: .standard(proto: "otp_sharedsecret"),
    8: .standard(proto: "otp_timedrift"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._filename) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._offset) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._cubtowrite) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._bytes) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._otpType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._otpIdentifier) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self._otpSharedsecret) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._otpTimedrift) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._filename {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._offset {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._cubtowrite {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._bytes {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }
    if let v = self._otpType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._otpIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._otpSharedsecret {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    }
    if let v = self._otpTimedrift {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUpdateMachineAuth, rhs: CMsgClientUpdateMachineAuth) -> Bool {
    if lhs._filename != rhs._filename {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs._cubtowrite != rhs._cubtowrite {return false}
    if lhs._bytes != rhs._bytes {return false}
    if lhs._otpType != rhs._otpType {return false}
    if lhs._otpIdentifier != rhs._otpIdentifier {return false}
    if lhs._otpSharedsecret != rhs._otpSharedsecret {return false}
    if lhs._otpTimedrift != rhs._otpTimedrift {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUpdateMachineAuthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUpdateMachineAuthResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filename"),
    2: .same(proto: "eresult"),
    3: .same(proto: "filesize"),
    4: .standard(proto: "sha_file"),
    5: .same(proto: "getlasterror"),
    6: .same(proto: "offset"),
    7: .same(proto: "cubwrote"),
    8: .standard(proto: "otp_type"),
    9: .standard(proto: "otp_value"),
    10: .standard(proto: "otp_identifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._filename) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._eresult) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._filesize) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._shaFile) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._getlasterror) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._offset) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._cubwrote) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self._otpType) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._otpValue) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self._otpIdentifier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._filename {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._eresult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._filesize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._shaFile {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }
    if let v = self._getlasterror {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._offset {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._cubwrote {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._otpType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
    }
    if let v = self._otpValue {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    }
    if let v = self._otpIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUpdateMachineAuthResponse, rhs: CMsgClientUpdateMachineAuthResponse) -> Bool {
    if lhs._filename != rhs._filename {return false}
    if lhs._eresult != rhs._eresult {return false}
    if lhs._filesize != rhs._filesize {return false}
    if lhs._shaFile != rhs._shaFile {return false}
    if lhs._getlasterror != rhs._getlasterror {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs._cubwrote != rhs._cubwrote {return false}
    if lhs._otpType != rhs._otpType {return false}
    if lhs._otpValue != rhs._otpValue {return false}
    if lhs._otpIdentifier != rhs._otpIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRequestMachineAuth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRequestMachineAuth"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filename"),
    2: .standard(proto: "eresult_sentryfile"),
    3: .same(proto: "filesize"),
    4: .standard(proto: "sha_sentryfile"),
    6: .standard(proto: "lock_account_action"),
    7: .standard(proto: "otp_type"),
    8: .standard(proto: "otp_identifier"),
    9: .standard(proto: "otp_sharedsecret"),
    10: .standard(proto: "otp_value"),
    11: .standard(proto: "machine_name"),
    12: .standard(proto: "machine_name_userchosen"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._filename) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._eresultSentryfile) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._filesize) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._shaSentryfile) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._lockAccountAction) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._otpType) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._otpIdentifier) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self._otpSharedsecret) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._otpValue) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._machineName) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._machineNameUserchosen) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._filename {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._eresultSentryfile {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._filesize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._shaSentryfile {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }
    if let v = self._lockAccountAction {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._otpType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._otpIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    }
    if let v = self._otpSharedsecret {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
    }
    if let v = self._otpValue {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    }
    if let v = self._machineName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    }
    if let v = self._machineNameUserchosen {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRequestMachineAuth, rhs: CMsgClientRequestMachineAuth) -> Bool {
    if lhs._filename != rhs._filename {return false}
    if lhs._eresultSentryfile != rhs._eresultSentryfile {return false}
    if lhs._filesize != rhs._filesize {return false}
    if lhs._shaSentryfile != rhs._shaSentryfile {return false}
    if lhs._lockAccountAction != rhs._lockAccountAction {return false}
    if lhs._otpType != rhs._otpType {return false}
    if lhs._otpIdentifier != rhs._otpIdentifier {return false}
    if lhs._otpSharedsecret != rhs._otpSharedsecret {return false}
    if lhs._otpValue != rhs._otpValue {return false}
    if lhs._machineName != rhs._machineName {return false}
    if lhs._machineNameUserchosen != rhs._machineNameUserchosen {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRequestMachineAuthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRequestMachineAuthResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._eresult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRequestMachineAuthResponse, rhs: CMsgClientRequestMachineAuthResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRegisterKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRegisterKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRegisterKey, rhs: CMsgClientRegisterKey) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientPurchaseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientPurchaseResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "purchase_result_details"),
    3: .standard(proto: "purchase_receipt_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._purchaseResultDetails) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._purchaseReceiptInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._purchaseResultDetails {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._purchaseReceiptInfo {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientPurchaseResponse, rhs: CMsgClientPurchaseResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs._purchaseResultDetails != rhs._purchaseResultDetails {return false}
    if lhs._purchaseReceiptInfo != rhs._purchaseReceiptInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientActivateOEMLicense: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientActivateOEMLicense"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bios_manufacturer"),
    2: .standard(proto: "bios_serialnumber"),
    3: .standard(proto: "license_file"),
    4: .standard(proto: "mainboard_manufacturer"),
    5: .standard(proto: "mainboard_product"),
    6: .standard(proto: "mainboard_serialnumber"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._biosManufacturer) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._biosSerialnumber) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._licenseFile) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._mainboardManufacturer) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._mainboardProduct) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._mainboardSerialnumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._biosManufacturer {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._biosSerialnumber {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._licenseFile {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    if let v = self._mainboardManufacturer {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._mainboardProduct {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._mainboardSerialnumber {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientActivateOEMLicense, rhs: CMsgClientActivateOEMLicense) -> Bool {
    if lhs._biosManufacturer != rhs._biosManufacturer {return false}
    if lhs._biosSerialnumber != rhs._biosSerialnumber {return false}
    if lhs._licenseFile != rhs._licenseFile {return false}
    if lhs._mainboardManufacturer != rhs._mainboardManufacturer {return false}
    if lhs._mainboardProduct != rhs._mainboardProduct {return false}
    if lhs._mainboardSerialnumber != rhs._mainboardSerialnumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRegisterOEMMachine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRegisterOEMMachine"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "oem_register_file"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._oemRegisterFile) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._oemRegisterFile {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRegisterOEMMachine, rhs: CMsgClientRegisterOEMMachine) -> Bool {
    if lhs._oemRegisterFile != rhs._oemRegisterFile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRegisterOEMMachineResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRegisterOEMMachineResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._eresult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRegisterOEMMachineResponse, rhs: CMsgClientRegisterOEMMachineResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientPurchaseWithMachineID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientPurchaseWithMachineID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "package_id"),
    2: .standard(proto: "machine_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._packageID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._machineInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._packageID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._machineInfo {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientPurchaseWithMachineID, rhs: CMsgClientPurchaseWithMachineID) -> Bool {
    if lhs._packageID != rhs._packageID {return false}
    if lhs._machineInfo != rhs._machineInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgTrading_InitiateTradeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgTrading_InitiateTradeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trade_request_id"),
    2: .standard(proto: "other_steamid"),
    3: .standard(proto: "other_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._tradeRequestID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._otherSteamid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._otherName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._tradeRequestID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._otherSteamid {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    if let v = self._otherName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgTrading_InitiateTradeRequest, rhs: CMsgTrading_InitiateTradeRequest) -> Bool {
    if lhs._tradeRequestID != rhs._tradeRequestID {return false}
    if lhs._otherSteamid != rhs._otherSteamid {return false}
    if lhs._otherName != rhs._otherName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgTrading_InitiateTradeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgTrading_InitiateTradeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "response"),
    2: .standard(proto: "trade_request_id"),
    3: .standard(proto: "other_steamid"),
    4: .standard(proto: "steamguard_required_days"),
    5: .standard(proto: "new_device_cooldown_days"),
    6: .standard(proto: "default_password_reset_probation_days"),
    7: .standard(proto: "password_reset_probation_days"),
    8: .standard(proto: "default_email_change_probation_days"),
    9: .standard(proto: "email_change_probation_days"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._response) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._tradeRequestID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._otherSteamid) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._steamguardRequiredDays) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._newDeviceCooldownDays) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._defaultPasswordResetProbationDays) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._passwordResetProbationDays) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._defaultEmailChangeProbationDays) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._emailChangeProbationDays) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._response {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._tradeRequestID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._otherSteamid {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }
    if let v = self._steamguardRequiredDays {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._newDeviceCooldownDays {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._defaultPasswordResetProbationDays {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._passwordResetProbationDays {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._defaultEmailChangeProbationDays {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    }
    if let v = self._emailChangeProbationDays {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgTrading_InitiateTradeResponse, rhs: CMsgTrading_InitiateTradeResponse) -> Bool {
    if lhs._response != rhs._response {return false}
    if lhs._tradeRequestID != rhs._tradeRequestID {return false}
    if lhs._otherSteamid != rhs._otherSteamid {return false}
    if lhs._steamguardRequiredDays != rhs._steamguardRequiredDays {return false}
    if lhs._newDeviceCooldownDays != rhs._newDeviceCooldownDays {return false}
    if lhs._defaultPasswordResetProbationDays != rhs._defaultPasswordResetProbationDays {return false}
    if lhs._passwordResetProbationDays != rhs._passwordResetProbationDays {return false}
    if lhs._defaultEmailChangeProbationDays != rhs._defaultEmailChangeProbationDays {return false}
    if lhs._emailChangeProbationDays != rhs._emailChangeProbationDays {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgTrading_CancelTradeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgTrading_CancelTradeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "other_steamid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._otherSteamid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._otherSteamid {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgTrading_CancelTradeRequest, rhs: CMsgTrading_CancelTradeRequest) -> Bool {
    if lhs._otherSteamid != rhs._otherSteamid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgTrading_StartSession: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgTrading_StartSession"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "other_steamid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._otherSteamid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._otherSteamid {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgTrading_StartSession, rhs: CMsgTrading_StartSession) -> Bool {
    if lhs._otherSteamid != rhs._otherSteamid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientGetCDNAuthToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientGetCDNAuthToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "depot_id"),
    2: .standard(proto: "host_name"),
    3: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._depotID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._hostName) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._depotID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._hostName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._appID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientGetCDNAuthToken, rhs: CMsgClientGetCDNAuthToken) -> Bool {
    if lhs._depotID != rhs._depotID {return false}
    if lhs._hostName != rhs._hostName {return false}
    if lhs._appID != rhs._appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientGetDepotDecryptionKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientGetDepotDecryptionKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "depot_id"),
    2: .standard(proto: "app_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._depotID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._appID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._depotID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._appID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientGetDepotDecryptionKey, rhs: CMsgClientGetDepotDecryptionKey) -> Bool {
    if lhs._depotID != rhs._depotID {return false}
    if lhs._appID != rhs._appID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientGetDepotDecryptionKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientGetDepotDecryptionKeyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "depot_id"),
    3: .standard(proto: "depot_encryption_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._depotID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._depotEncryptionKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._depotID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._depotEncryptionKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientGetDepotDecryptionKeyResponse, rhs: CMsgClientGetDepotDecryptionKeyResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs._depotID != rhs._depotID {return false}
    if lhs._depotEncryptionKey != rhs._depotEncryptionKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientCheckAppBetaPassword: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientCheckAppBetaPassword"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .same(proto: "betapassword"),
    3: .same(proto: "language"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._appID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._betapassword) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._language) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._appID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._betapassword {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._language {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientCheckAppBetaPassword, rhs: CMsgClientCheckAppBetaPassword) -> Bool {
    if lhs._appID != rhs._appID {return false}
    if lhs._betapassword != rhs._betapassword {return false}
    if lhs._language != rhs._language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientCheckAppBetaPasswordResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientCheckAppBetaPasswordResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    4: .same(proto: "betapasswords"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.betapasswords) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if !self.betapasswords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.betapasswords, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientCheckAppBetaPasswordResponse, rhs: CMsgClientCheckAppBetaPasswordResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs.betapasswords != rhs.betapasswords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientCheckAppBetaPasswordResponse.BetaPassword: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientCheckAppBetaPasswordResponse.protoMessageName + ".BetaPassword"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "betaname"),
    2: .same(proto: "betapassword"),
    3: .same(proto: "betadescription"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._betaname) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._betapassword) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._betadescription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._betaname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._betapassword {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._betadescription {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientCheckAppBetaPasswordResponse.BetaPassword, rhs: CMsgClientCheckAppBetaPasswordResponse.BetaPassword) -> Bool {
    if lhs._betaname != rhs._betaname {return false}
    if lhs._betapassword != rhs._betapassword {return false}
    if lhs._betadescription != rhs._betadescription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUpdateAppJobReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUpdateAppJobReport"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "depot_ids"),
    3: .standard(proto: "app_state"),
    4: .standard(proto: "job_app_error"),
    5: .standard(proto: "error_details"),
    6: .standard(proto: "job_duration"),
    7: .standard(proto: "files_validation_failed"),
    8: .standard(proto: "job_bytes_downloaded"),
    9: .standard(proto: "job_bytes_staged"),
    10: .standard(proto: "bytes_comitted"),
    11: .standard(proto: "start_app_state"),
    12: .standard(proto: "stats_machine_id"),
    13: .standard(proto: "branch_name"),
    14: .standard(proto: "total_bytes_downloaded"),
    15: .standard(proto: "total_bytes_staged"),
    16: .standard(proto: "total_bytes_restored"),
    17: .standard(proto: "is_borrowed"),
    18: .standard(proto: "is_free_weekend"),
    19: .standard(proto: "total_bytes_legacy"),
    20: .standard(proto: "total_bytes_patched"),
    21: .standard(proto: "total_bytes_saved"),
    22: .standard(proto: "cell_id"),
  ]

  fileprivate class _StorageClass {
    var _appID: UInt32? = nil
    var _depotIds: [UInt32] = []
    var _appState: UInt32? = nil
    var _jobAppError: UInt32? = nil
    var _errorDetails: String? = nil
    var _jobDuration: UInt32? = nil
    var _filesValidationFailed: UInt32? = nil
    var _jobBytesDownloaded: UInt64? = nil
    var _jobBytesStaged: UInt64? = nil
    var _bytesComitted: UInt64? = nil
    var _startAppState: UInt32? = nil
    var _statsMachineID: UInt64? = nil
    var _branchName: String? = nil
    var _totalBytesDownloaded: UInt64? = nil
    var _totalBytesStaged: UInt64? = nil
    var _totalBytesRestored: UInt64? = nil
    var _isBorrowed: Bool? = nil
    var _isFreeWeekend: Bool? = nil
    var _totalBytesLegacy: UInt64? = nil
    var _totalBytesPatched: UInt64? = nil
    var _totalBytesSaved: UInt64? = nil
    var _cellID: UInt32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _appID = source._appID
      _depotIds = source._depotIds
      _appState = source._appState
      _jobAppError = source._jobAppError
      _errorDetails = source._errorDetails
      _jobDuration = source._jobDuration
      _filesValidationFailed = source._filesValidationFailed
      _jobBytesDownloaded = source._jobBytesDownloaded
      _jobBytesStaged = source._jobBytesStaged
      _bytesComitted = source._bytesComitted
      _startAppState = source._startAppState
      _statsMachineID = source._statsMachineID
      _branchName = source._branchName
      _totalBytesDownloaded = source._totalBytesDownloaded
      _totalBytesStaged = source._totalBytesStaged
      _totalBytesRestored = source._totalBytesRestored
      _isBorrowed = source._isBorrowed
      _isFreeWeekend = source._isFreeWeekend
      _totalBytesLegacy = source._totalBytesLegacy
      _totalBytesPatched = source._totalBytesPatched
      _totalBytesSaved = source._totalBytesSaved
      _cellID = source._cellID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._appID) }()
        case 2: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._depotIds) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._appState) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._jobAppError) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._errorDetails) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._jobDuration) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._filesValidationFailed) }()
        case 8: try { try decoder.decodeSingularUInt64Field(value: &_storage._jobBytesDownloaded) }()
        case 9: try { try decoder.decodeSingularUInt64Field(value: &_storage._jobBytesStaged) }()
        case 10: try { try decoder.decodeSingularUInt64Field(value: &_storage._bytesComitted) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._startAppState) }()
        case 12: try { try decoder.decodeSingularFixed64Field(value: &_storage._statsMachineID) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._branchName) }()
        case 14: try { try decoder.decodeSingularUInt64Field(value: &_storage._totalBytesDownloaded) }()
        case 15: try { try decoder.decodeSingularUInt64Field(value: &_storage._totalBytesStaged) }()
        case 16: try { try decoder.decodeSingularUInt64Field(value: &_storage._totalBytesRestored) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._isBorrowed) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._isFreeWeekend) }()
        case 19: try { try decoder.decodeSingularUInt64Field(value: &_storage._totalBytesLegacy) }()
        case 20: try { try decoder.decodeSingularUInt64Field(value: &_storage._totalBytesPatched) }()
        case 21: try { try decoder.decodeSingularUInt64Field(value: &_storage._totalBytesSaved) }()
        case 22: try { try decoder.decodeSingularUInt32Field(value: &_storage._cellID) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._appID {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
      }
      if !_storage._depotIds.isEmpty {
        try visitor.visitRepeatedUInt32Field(value: _storage._depotIds, fieldNumber: 2)
      }
      if let v = _storage._appState {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      }
      if let v = _storage._jobAppError {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      }
      if let v = _storage._errorDetails {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._jobDuration {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
      }
      if let v = _storage._filesValidationFailed {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
      }
      if let v = _storage._jobBytesDownloaded {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
      }
      if let v = _storage._jobBytesStaged {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 9)
      }
      if let v = _storage._bytesComitted {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 10)
      }
      if let v = _storage._startAppState {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
      }
      if let v = _storage._statsMachineID {
        try visitor.visitSingularFixed64Field(value: v, fieldNumber: 12)
      }
      if let v = _storage._branchName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 13)
      }
      if let v = _storage._totalBytesDownloaded {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 14)
      }
      if let v = _storage._totalBytesStaged {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 15)
      }
      if let v = _storage._totalBytesRestored {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 16)
      }
      if let v = _storage._isBorrowed {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      }
      if let v = _storage._isFreeWeekend {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 18)
      }
      if let v = _storage._totalBytesLegacy {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 19)
      }
      if let v = _storage._totalBytesPatched {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 20)
      }
      if let v = _storage._totalBytesSaved {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 21)
      }
      if let v = _storage._cellID {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUpdateAppJobReport, rhs: CMsgClientUpdateAppJobReport) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._depotIds != rhs_storage._depotIds {return false}
        if _storage._appState != rhs_storage._appState {return false}
        if _storage._jobAppError != rhs_storage._jobAppError {return false}
        if _storage._errorDetails != rhs_storage._errorDetails {return false}
        if _storage._jobDuration != rhs_storage._jobDuration {return false}
        if _storage._filesValidationFailed != rhs_storage._filesValidationFailed {return false}
        if _storage._jobBytesDownloaded != rhs_storage._jobBytesDownloaded {return false}
        if _storage._jobBytesStaged != rhs_storage._jobBytesStaged {return false}
        if _storage._bytesComitted != rhs_storage._bytesComitted {return false}
        if _storage._startAppState != rhs_storage._startAppState {return false}
        if _storage._statsMachineID != rhs_storage._statsMachineID {return false}
        if _storage._branchName != rhs_storage._branchName {return false}
        if _storage._totalBytesDownloaded != rhs_storage._totalBytesDownloaded {return false}
        if _storage._totalBytesStaged != rhs_storage._totalBytesStaged {return false}
        if _storage._totalBytesRestored != rhs_storage._totalBytesRestored {return false}
        if _storage._isBorrowed != rhs_storage._isBorrowed {return false}
        if _storage._isFreeWeekend != rhs_storage._isFreeWeekend {return false}
        if _storage._totalBytesLegacy != rhs_storage._totalBytesLegacy {return false}
        if _storage._totalBytesPatched != rhs_storage._totalBytesPatched {return false}
        if _storage._totalBytesSaved != rhs_storage._totalBytesSaved {return false}
        if _storage._cellID != rhs_storage._cellID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientDPContentStatsReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientDPContentStatsReport"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stats_machine_id"),
    2: .standard(proto: "country_code"),
    3: .standard(proto: "os_type"),
    4: .same(proto: "language"),
    5: .standard(proto: "num_install_folders"),
    6: .standard(proto: "num_installed_games"),
    7: .standard(proto: "size_installed_games"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._statsMachineID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._countryCode) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._osType) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._language) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._numInstallFolders) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._numInstalledGames) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self._sizeInstalledGames) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._statsMachineID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._countryCode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._osType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._language {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._numInstallFolders {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._numInstalledGames {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._sizeInstalledGames {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientDPContentStatsReport, rhs: CMsgClientDPContentStatsReport) -> Bool {
    if lhs._statsMachineID != rhs._statsMachineID {return false}
    if lhs._countryCode != rhs._countryCode {return false}
    if lhs._osType != rhs._osType {return false}
    if lhs._language != rhs._language {return false}
    if lhs._numInstallFolders != rhs._numInstallFolders {return false}
    if lhs._numInstalledGames != rhs._numInstalledGames {return false}
    if lhs._sizeInstalledGames != rhs._sizeInstalledGames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientGetCDNAuthTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientGetCDNAuthTokenResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .same(proto: "token"),
    3: .standard(proto: "expiration_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._token) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._expirationTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._token {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._expirationTime {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientGetCDNAuthTokenResponse, rhs: CMsgClientGetCDNAuthTokenResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs._token != rhs._token {return false}
    if lhs._expirationTime != rhs._expirationTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgDownloadRateStatistics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgDownloadRateStatistics"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cell_id"),
    2: .same(proto: "stats"),
    3: .standard(proto: "throttling_kbps"),
    4: .standard(proto: "steam_realm"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._cellID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.stats) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._throttlingKbps) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._steamRealm) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._cellID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if !self.stats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stats, fieldNumber: 2)
    }
    if let v = self._throttlingKbps {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._steamRealm {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgDownloadRateStatistics, rhs: CMsgDownloadRateStatistics) -> Bool {
    if lhs._cellID != rhs._cellID {return false}
    if lhs.stats != rhs.stats {return false}
    if lhs._throttlingKbps != rhs._throttlingKbps {return false}
    if lhs._steamRealm != rhs._steamRealm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgDownloadRateStatistics.StatsInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgDownloadRateStatistics.protoMessageName + ".StatsInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_type"),
    2: .standard(proto: "source_id"),
    3: .same(proto: "seconds"),
    4: .same(proto: "bytes"),
    5: .standard(proto: "host_name"),
    6: .same(proto: "microseconds"),
    7: .standard(proto: "used_ipv6"),
    8: .same(proto: "proxied"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._sourceType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._sourceID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._seconds) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._bytes) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._hostName) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._microseconds) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._usedIpv6) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._proxied) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sourceType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._sourceID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._seconds {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._bytes {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    }
    if let v = self._hostName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._microseconds {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    }
    if let v = self._usedIpv6 {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    }
    if let v = self._proxied {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgDownloadRateStatistics.StatsInfo, rhs: CMsgDownloadRateStatistics.StatsInfo) -> Bool {
    if lhs._sourceType != rhs._sourceType {return false}
    if lhs._sourceID != rhs._sourceID {return false}
    if lhs._seconds != rhs._seconds {return false}
    if lhs._bytes != rhs._bytes {return false}
    if lhs._hostName != rhs._hostName {return false}
    if lhs._microseconds != rhs._microseconds {return false}
    if lhs._usedIpv6 != rhs._usedIpv6 {return false}
    if lhs._proxied != rhs._proxied {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRequestAccountData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRequestAccountData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_or_email"),
    2: .same(proto: "action"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._accountOrEmail) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._action) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._accountOrEmail {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._action {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRequestAccountData, rhs: CMsgClientRequestAccountData) -> Bool {
    if lhs._accountOrEmail != rhs._accountOrEmail {return false}
    if lhs._action != rhs._action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRequestAccountDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRequestAccountDataResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "eresult"),
    3: .standard(proto: "account_name"),
    4: .standard(proto: "ct_matches"),
    5: .standard(proto: "account_name_suggestion1"),
    6: .standard(proto: "account_name_suggestion2"),
    7: .standard(proto: "account_name_suggestion3"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._action) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._eresult) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._accountName) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._ctMatches) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._accountNameSuggestion1) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._accountNameSuggestion2) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._accountNameSuggestion3) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._action {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._eresult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._accountName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._ctMatches {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._accountNameSuggestion1 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._accountNameSuggestion2 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._accountNameSuggestion3 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRequestAccountDataResponse, rhs: CMsgClientRequestAccountDataResponse) -> Bool {
    if lhs._action != rhs._action {return false}
    if lhs._eresult != rhs._eresult {return false}
    if lhs._accountName != rhs._accountName {return false}
    if lhs._ctMatches != rhs._ctMatches {return false}
    if lhs._accountNameSuggestion1 != rhs._accountNameSuggestion1 {return false}
    if lhs._accountNameSuggestion2 != rhs._accountNameSuggestion2 {return false}
    if lhs._accountNameSuggestion3 != rhs._accountNameSuggestion3 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUGSGetGlobalStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUGSGetGlobalStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gameid"),
    2: .standard(proto: "history_days_requested"),
    3: .standard(proto: "time_last_requested"),
    4: .standard(proto: "first_day_cached"),
    5: .standard(proto: "days_cached"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._gameid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._historyDaysRequested) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._timeLastRequested) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._firstDayCached) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._daysCached) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._gameid {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._historyDaysRequested {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._timeLastRequested {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    }
    if let v = self._firstDayCached {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._daysCached {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUGSGetGlobalStats, rhs: CMsgClientUGSGetGlobalStats) -> Bool {
    if lhs._gameid != rhs._gameid {return false}
    if lhs._historyDaysRequested != rhs._historyDaysRequested {return false}
    if lhs._timeLastRequested != rhs._timeLastRequested {return false}
    if lhs._firstDayCached != rhs._firstDayCached {return false}
    if lhs._daysCached != rhs._daysCached {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUGSGetGlobalStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUGSGetGlobalStatsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .same(proto: "timestamp"),
    3: .standard(proto: "day_current"),
    4: .same(proto: "days"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._timestamp) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._dayCurrent) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.days) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._timestamp {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    }
    if let v = self._dayCurrent {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if !self.days.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.days, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUGSGetGlobalStatsResponse, rhs: CMsgClientUGSGetGlobalStatsResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._dayCurrent != rhs._dayCurrent {return false}
    if lhs.days != rhs.days {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUGSGetGlobalStatsResponse.Day: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientUGSGetGlobalStatsResponse.protoMessageName + ".Day"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "day_id"),
    2: .same(proto: "stats"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._dayID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.stats) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._dayID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if !self.stats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stats, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUGSGetGlobalStatsResponse.Day, rhs: CMsgClientUGSGetGlobalStatsResponse.Day) -> Bool {
    if lhs._dayID != rhs._dayID {return false}
    if lhs.stats != rhs.stats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUGSGetGlobalStatsResponse.Day.Stat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientUGSGetGlobalStatsResponse.Day.protoMessageName + ".Stat"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stat_id"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._statID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._statID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._data {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUGSGetGlobalStatsResponse.Day.Stat, rhs: CMsgClientUGSGetGlobalStatsResponse.Day.Stat) -> Bool {
    if lhs._statID != rhs._statID {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRedeemGuestPass: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRedeemGuestPass"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guest_pass_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._guestPassID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._guestPassID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRedeemGuestPass, rhs: CMsgClientRedeemGuestPass) -> Bool {
    if lhs._guestPassID != rhs._guestPassID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRedeemGuestPassResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRedeemGuestPassResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "package_id"),
    3: .standard(proto: "must_own_appid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._packageID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._mustOwnAppid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._packageID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._mustOwnAppid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRedeemGuestPassResponse, rhs: CMsgClientRedeemGuestPassResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs._packageID != rhs._packageID {return false}
    if lhs._mustOwnAppid != rhs._mustOwnAppid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientGetClanActivityCounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientGetClanActivityCounts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "steamid_clans"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.steamidClans) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.steamidClans.isEmpty {
      try visitor.visitRepeatedUInt64Field(value: self.steamidClans, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientGetClanActivityCounts, rhs: CMsgClientGetClanActivityCounts) -> Bool {
    if lhs.steamidClans != rhs.steamidClans {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientGetClanActivityCountsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientGetClanActivityCountsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._eresult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientGetClanActivityCountsResponse, rhs: CMsgClientGetClanActivityCountsResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientOGSReportString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientOGSReportString"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accumulated"),
    2: .same(proto: "sessionid"),
    3: .same(proto: "severity"),
    4: .same(proto: "formatter"),
    5: .same(proto: "varargs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._accumulated) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._sessionid) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._severity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._formatter) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._varargs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._accumulated {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    if let v = self._sessionid {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    if let v = self._severity {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._formatter {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._varargs {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientOGSReportString, rhs: CMsgClientOGSReportString) -> Bool {
    if lhs._accumulated != rhs._accumulated {return false}
    if lhs._sessionid != rhs._sessionid {return false}
    if lhs._severity != rhs._severity {return false}
    if lhs._formatter != rhs._formatter {return false}
    if lhs._varargs != rhs._varargs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientOGSReportBug: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientOGSReportBug"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sessionid"),
    2: .same(proto: "bugtext"),
    3: .same(proto: "screenshot"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._sessionid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._bugtext) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._screenshot) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sessionid {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._bugtext {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._screenshot {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientOGSReportBug, rhs: CMsgClientOGSReportBug) -> Bool {
    if lhs._sessionid != rhs._sessionid {return false}
    if lhs._bugtext != rhs._bugtext {return false}
    if lhs._screenshot != rhs._screenshot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientSentLogs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientSentLogs"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientSentLogs, rhs: CMsgClientSentLogs) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgGCClient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgGCClient"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appid"),
    2: .same(proto: "msgtype"),
    3: .same(proto: "payload"),
    4: .same(proto: "steamid"),
    5: .same(proto: "gcname"),
    6: .same(proto: "ip"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._appid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._msgtype) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._payload) }()
      case 4: try { try decoder.decodeSingularFixed64Field(value: &self._steamid) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._gcname) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._ip) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._appid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._msgtype {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._payload {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    if let v = self._steamid {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 4)
    }
    if let v = self._gcname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if let v = self._ip {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgGCClient, rhs: CMsgGCClient) -> Bool {
    if lhs._appid != rhs._appid {return false}
    if lhs._msgtype != rhs._msgtype {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs._steamid != rhs._steamid {return false}
    if lhs._gcname != rhs._gcname {return false}
    if lhs._ip != rhs._ip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRequestFreeLicense: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRequestFreeLicense"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "appids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.appids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appids.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.appids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRequestFreeLicense, rhs: CMsgClientRequestFreeLicense) -> Bool {
    if lhs.appids != rhs.appids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRequestFreeLicenseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRequestFreeLicenseResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "granted_packageids"),
    3: .standard(proto: "granted_appids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.grantedPackageids) }()
      case 3: try { try decoder.decodeRepeatedUInt32Field(value: &self.grantedAppids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if !self.grantedPackageids.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.grantedPackageids, fieldNumber: 2)
    }
    if !self.grantedAppids.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.grantedAppids, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRequestFreeLicenseResponse, rhs: CMsgClientRequestFreeLicenseResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs.grantedPackageids != rhs.grantedPackageids {return false}
    if lhs.grantedAppids != rhs.grantedAppids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgDRMDownloadRequestWithCrashData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgDRMDownloadRequestWithCrashData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "download_flags"),
    2: .standard(proto: "download_types_known"),
    3: .standard(proto: "guid_drm"),
    4: .standard(proto: "guid_split"),
    5: .standard(proto: "guid_merge"),
    6: .standard(proto: "module_name"),
    7: .standard(proto: "module_path"),
    8: .standard(proto: "crash_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._downloadFlags) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._downloadTypesKnown) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._guidDrm) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._guidSplit) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._guidMerge) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._moduleName) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._modulePath) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self._crashData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._downloadFlags {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._downloadTypesKnown {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._guidDrm {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    if let v = self._guidSplit {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }
    if let v = self._guidMerge {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }
    if let v = self._moduleName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    if let v = self._modulePath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }
    if let v = self._crashData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgDRMDownloadRequestWithCrashData, rhs: CMsgDRMDownloadRequestWithCrashData) -> Bool {
    if lhs._downloadFlags != rhs._downloadFlags {return false}
    if lhs._downloadTypesKnown != rhs._downloadTypesKnown {return false}
    if lhs._guidDrm != rhs._guidDrm {return false}
    if lhs._guidSplit != rhs._guidSplit {return false}
    if lhs._guidMerge != rhs._guidMerge {return false}
    if lhs._moduleName != rhs._moduleName {return false}
    if lhs._modulePath != rhs._modulePath {return false}
    if lhs._crashData != rhs._crashData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgDRMDownloadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgDRMDownloadResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "app_id"),
    3: .standard(proto: "blob_download_type"),
    4: .standard(proto: "merge_guid"),
    5: .standard(proto: "download_file_dfs_ip"),
    6: .standard(proto: "download_file_dfs_port"),
    7: .standard(proto: "download_file_url"),
    8: .standard(proto: "module_path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._appID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._blobDownloadType) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._mergeGuid) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._downloadFileDfsIp) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._downloadFileDfsPort) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._downloadFileURL) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._modulePath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._appID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._blobDownloadType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._mergeGuid {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }
    if let v = self._downloadFileDfsIp {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._downloadFileDfsPort {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._downloadFileURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }
    if let v = self._modulePath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgDRMDownloadResponse, rhs: CMsgDRMDownloadResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs._appID != rhs._appID {return false}
    if lhs._blobDownloadType != rhs._blobDownloadType {return false}
    if lhs._mergeGuid != rhs._mergeGuid {return false}
    if lhs._downloadFileDfsIp != rhs._downloadFileDfsIp {return false}
    if lhs._downloadFileDfsPort != rhs._downloadFileDfsPort {return false}
    if lhs._downloadFileURL != rhs._downloadFileURL {return false}
    if lhs._modulePath != rhs._modulePath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgDRMFinalResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgDRMFinalResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eResult"),
    2: .standard(proto: "app_id"),
    3: .standard(proto: "blob_download_type"),
    4: .standard(proto: "error_detail"),
    5: .standard(proto: "merge_guid"),
    6: .standard(proto: "download_file_dfs_ip"),
    7: .standard(proto: "download_file_dfs_port"),
    8: .standard(proto: "download_file_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._eResult) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._appID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._blobDownloadType) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._errorDetail) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._mergeGuid) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._downloadFileDfsIp) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._downloadFileDfsPort) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._downloadFileURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eResult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._appID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._blobDownloadType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._errorDetail {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._mergeGuid {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }
    if let v = self._downloadFileDfsIp {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._downloadFileDfsPort {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._downloadFileURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgDRMFinalResult, rhs: CMsgDRMFinalResult) -> Bool {
    if lhs._eResult != rhs._eResult {return false}
    if lhs._appID != rhs._appID {return false}
    if lhs._blobDownloadType != rhs._blobDownloadType {return false}
    if lhs._errorDetail != rhs._errorDetail {return false}
    if lhs._mergeGuid != rhs._mergeGuid {return false}
    if lhs._downloadFileDfsIp != rhs._downloadFileDfsIp {return false}
    if lhs._downloadFileDfsPort != rhs._downloadFileDfsPort {return false}
    if lhs._downloadFileURL != rhs._downloadFileURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientDPCheckSpecialSurvey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientDPCheckSpecialSurvey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "survey_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._surveyID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._surveyID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientDPCheckSpecialSurvey, rhs: CMsgClientDPCheckSpecialSurvey) -> Bool {
    if lhs._surveyID != rhs._surveyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientDPCheckSpecialSurveyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientDPCheckSpecialSurveyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eResult"),
    2: .same(proto: "state"),
    3: .same(proto: "name"),
    4: .standard(proto: "custom_url"),
    5: .standard(proto: "include_software"),
    6: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._eResult) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._state) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._customURL) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._includeSoftware) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eResult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._state {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._customURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._includeSoftware {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    if let v = self._token {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientDPCheckSpecialSurveyResponse, rhs: CMsgClientDPCheckSpecialSurveyResponse) -> Bool {
    if lhs._eResult != rhs._eResult {return false}
    if lhs._state != rhs._state {return false}
    if lhs._name != rhs._name {return false}
    if lhs._customURL != rhs._customURL {return false}
    if lhs._includeSoftware != rhs._includeSoftware {return false}
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientDPSendSpecialSurveyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientDPSendSpecialSurveyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "survey_id"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._surveyID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._surveyID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._data {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientDPSendSpecialSurveyResponse, rhs: CMsgClientDPSendSpecialSurveyResponse) -> Bool {
    if lhs._surveyID != rhs._surveyID {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientDPSendSpecialSurveyResponseReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientDPSendSpecialSurveyResponseReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eResult"),
    2: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._eResult) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eResult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._token {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientDPSendSpecialSurveyResponseReply, rhs: CMsgClientDPSendSpecialSurveyResponseReply) -> Bool {
    if lhs._eResult != rhs._eResult {return false}
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRequestForgottenPasswordEmail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRequestForgottenPasswordEmail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_name"),
    2: .standard(proto: "password_tried"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._accountName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._passwordTried) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._accountName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._passwordTried {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRequestForgottenPasswordEmail, rhs: CMsgClientRequestForgottenPasswordEmail) -> Bool {
    if lhs._accountName != rhs._accountName {return false}
    if lhs._passwordTried != rhs._passwordTried {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRequestForgottenPasswordEmailResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRequestForgottenPasswordEmailResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eResult"),
    2: .standard(proto: "use_secret_question"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._eResult) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._useSecretQuestion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eResult {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._useSecretQuestion {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRequestForgottenPasswordEmailResponse, rhs: CMsgClientRequestForgottenPasswordEmailResponse) -> Bool {
    if lhs._eResult != rhs._eResult {return false}
    if lhs._useSecretQuestion != rhs._useSecretQuestion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientItemAnnouncements: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientItemAnnouncements"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "count_new_items"),
    2: .standard(proto: "unseen_items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._countNewItems) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.unseenItems) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._countNewItems {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if !self.unseenItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.unseenItems, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientItemAnnouncements, rhs: CMsgClientItemAnnouncements) -> Bool {
    if lhs._countNewItems != rhs._countNewItems {return false}
    if lhs.unseenItems != rhs.unseenItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientItemAnnouncements.UnseenItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientItemAnnouncements.protoMessageName + ".UnseenItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appid"),
    2: .standard(proto: "context_id"),
    3: .standard(proto: "asset_id"),
    4: .same(proto: "amount"),
    5: .standard(proto: "rtime32_gained"),
    6: .standard(proto: "source_appid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._appid) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._contextID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._assetID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._amount) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._rtime32Gained) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._sourceAppid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._appid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._contextID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    if let v = self._assetID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }
    if let v = self._amount {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    }
    if let v = self._rtime32Gained {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    }
    if let v = self._sourceAppid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientItemAnnouncements.UnseenItem, rhs: CMsgClientItemAnnouncements.UnseenItem) -> Bool {
    if lhs._appid != rhs._appid {return false}
    if lhs._contextID != rhs._contextID {return false}
    if lhs._assetID != rhs._assetID {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs._rtime32Gained != rhs._rtime32Gained {return false}
    if lhs._sourceAppid != rhs._sourceAppid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRequestItemAnnouncements: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRequestItemAnnouncements"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRequestItemAnnouncements, rhs: CMsgClientRequestItemAnnouncements) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUserNotifications: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUserNotifications"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notifications"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.notifications) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.notifications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notifications, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUserNotifications, rhs: CMsgClientUserNotifications) -> Bool {
    if lhs.notifications != rhs.notifications {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUserNotifications.Notification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientUserNotifications.protoMessageName + ".Notification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_notification_type"),
    2: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._userNotificationType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._userNotificationType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._count {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUserNotifications.Notification, rhs: CMsgClientUserNotifications.Notification) -> Bool {
    if lhs._userNotificationType != rhs._userNotificationType {return false}
    if lhs._count != rhs._count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientCommentNotifications: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientCommentNotifications"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "count_new_comments"),
    2: .standard(proto: "count_new_comments_owner"),
    3: .standard(proto: "count_new_comments_subscriptions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._countNewComments) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._countNewCommentsOwner) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._countNewCommentsSubscriptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._countNewComments {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._countNewCommentsOwner {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._countNewCommentsSubscriptions {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientCommentNotifications, rhs: CMsgClientCommentNotifications) -> Bool {
    if lhs._countNewComments != rhs._countNewComments {return false}
    if lhs._countNewCommentsOwner != rhs._countNewCommentsOwner {return false}
    if lhs._countNewCommentsSubscriptions != rhs._countNewCommentsSubscriptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRequestCommentNotifications: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRequestCommentNotifications"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRequestCommentNotifications, rhs: CMsgClientRequestCommentNotifications) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientOfflineMessageNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientOfflineMessageNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "offline_messages"),
    2: .standard(proto: "friends_with_offline_messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._offlineMessages) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.friendsWithOfflineMessages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._offlineMessages {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if !self.friendsWithOfflineMessages.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.friendsWithOfflineMessages, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientOfflineMessageNotification, rhs: CMsgClientOfflineMessageNotification) -> Bool {
    if lhs._offlineMessages != rhs._offlineMessages {return false}
    if lhs.friendsWithOfflineMessages != rhs.friendsWithOfflineMessages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientRequestOfflineMessageCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientRequestOfflineMessageCount"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientRequestOfflineMessageCount, rhs: CMsgClientRequestOfflineMessageCount) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientChatGetFriendMessageHistory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientChatGetFriendMessageHistory"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "steamid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._steamid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._steamid {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientChatGetFriendMessageHistory, rhs: CMsgClientChatGetFriendMessageHistory) -> Bool {
    if lhs._steamid != rhs._steamid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientChatGetFriendMessageHistoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientChatGetFriendMessageHistoryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "steamid"),
    2: .same(proto: "success"),
    3: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._steamid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._success) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._steamid {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._success {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientChatGetFriendMessageHistoryResponse, rhs: CMsgClientChatGetFriendMessageHistoryResponse) -> Bool {
    if lhs._steamid != rhs._steamid {return false}
    if lhs._success != rhs._success {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientChatGetFriendMessageHistoryResponse.protoMessageName + ".FriendMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accountid"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "message"),
    4: .same(proto: "unread"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._accountid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._timestamp) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._message) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._unread) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._accountid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._timestamp {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._message {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._unread {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage, rhs: CMsgClientChatGetFriendMessageHistoryResponse.FriendMessage) -> Bool {
    if lhs._accountid != rhs._accountid {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._message != rhs._message {return false}
    if lhs._unread != rhs._unread {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientChatGetFriendMessageHistoryForOfflineMessages: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientChatGetFriendMessageHistoryForOfflineMessages"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientChatGetFriendMessageHistoryForOfflineMessages, rhs: CMsgClientChatGetFriendMessageHistoryForOfflineMessages) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientFSGetFriendsSteamLevels: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientFSGetFriendsSteamLevels"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accountids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.accountids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountids.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.accountids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientFSGetFriendsSteamLevels, rhs: CMsgClientFSGetFriendsSteamLevels) -> Bool {
    if lhs.accountids != rhs.accountids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientFSGetFriendsSteamLevelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientFSGetFriendsSteamLevelsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "friends"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.friends) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.friends.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.friends, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientFSGetFriendsSteamLevelsResponse, rhs: CMsgClientFSGetFriendsSteamLevelsResponse) -> Bool {
    if lhs.friends != rhs.friends {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientFSGetFriendsSteamLevelsResponse.Friend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientFSGetFriendsSteamLevelsResponse.protoMessageName + ".Friend"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accountid"),
    2: .same(proto: "level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._accountid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._level) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._accountid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._level {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientFSGetFriendsSteamLevelsResponse.Friend, rhs: CMsgClientFSGetFriendsSteamLevelsResponse.Friend) -> Bool {
    if lhs._accountid != rhs._accountid {return false}
    if lhs._level != rhs._level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientEmailAddrInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientEmailAddrInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "email_address"),
    2: .standard(proto: "email_is_validated"),
    3: .standard(proto: "email_validation_changed"),
    4: .standard(proto: "credential_change_requires_code"),
    5: .standard(proto: "password_or_secretqa_change_requires_code"),
    6: .standard(proto: "remind_user_about_email"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._emailAddress) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._emailIsValidated) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._emailValidationChanged) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._credentialChangeRequiresCode) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._passwordOrSecretqaChangeRequiresCode) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._remindUserAboutEmail) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._emailAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._emailIsValidated {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._emailValidationChanged {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    if let v = self._credentialChangeRequiresCode {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if let v = self._passwordOrSecretqaChangeRequiresCode {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    if let v = self._remindUserAboutEmail {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientEmailAddrInfo, rhs: CMsgClientEmailAddrInfo) -> Bool {
    if lhs._emailAddress != rhs._emailAddress {return false}
    if lhs._emailIsValidated != rhs._emailIsValidated {return false}
    if lhs._emailValidationChanged != rhs._emailValidationChanged {return false}
    if lhs._credentialChangeRequiresCode != rhs._credentialChangeRequiresCode {return false}
    if lhs._passwordOrSecretqaChangeRequiresCode != rhs._passwordOrSecretqaChangeRequiresCode {return false}
    if lhs._remindUserAboutEmail != rhs._remindUserAboutEmail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgCREItemVoteSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgCREItemVoteSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "published_file_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.publishedFileIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publishedFileIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publishedFileIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgCREItemVoteSummary, rhs: CMsgCREItemVoteSummary) -> Bool {
    if lhs.publishedFileIds != rhs.publishedFileIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgCREItemVoteSummary.PublishedFileId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgCREItemVoteSummary.protoMessageName + ".PublishedFileId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "published_file_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._publishedFileID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._publishedFileID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgCREItemVoteSummary.PublishedFileId, rhs: CMsgCREItemVoteSummary.PublishedFileId) -> Bool {
    if lhs._publishedFileID != rhs._publishedFileID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgCREItemVoteSummaryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgCREItemVoteSummaryResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "item_vote_summaries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.itemVoteSummaries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if !self.itemVoteSummaries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.itemVoteSummaries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgCREItemVoteSummaryResponse, rhs: CMsgCREItemVoteSummaryResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs.itemVoteSummaries != rhs.itemVoteSummaries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgCREItemVoteSummaryResponse.ItemVoteSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgCREItemVoteSummaryResponse.protoMessageName + ".ItemVoteSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "published_file_id"),
    2: .standard(proto: "votes_for"),
    3: .standard(proto: "votes_against"),
    4: .same(proto: "reports"),
    5: .same(proto: "score"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._publishedFileID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._votesFor) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._votesAgainst) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._reports) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._score) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._publishedFileID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._votesFor {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._votesAgainst {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._reports {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._score {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgCREItemVoteSummaryResponse.ItemVoteSummary, rhs: CMsgCREItemVoteSummaryResponse.ItemVoteSummary) -> Bool {
    if lhs._publishedFileID != rhs._publishedFileID {return false}
    if lhs._votesFor != rhs._votesFor {return false}
    if lhs._votesAgainst != rhs._votesAgainst {return false}
    if lhs._reports != rhs._reports {return false}
    if lhs._score != rhs._score {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgCREUpdateUserPublishedItemVote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgCREUpdateUserPublishedItemVote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "published_file_id"),
    2: .standard(proto: "vote_up"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._publishedFileID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._voteUp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._publishedFileID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._voteUp {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgCREUpdateUserPublishedItemVote, rhs: CMsgCREUpdateUserPublishedItemVote) -> Bool {
    if lhs._publishedFileID != rhs._publishedFileID {return false}
    if lhs._voteUp != rhs._voteUp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgCREUpdateUserPublishedItemVoteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgCREUpdateUserPublishedItemVoteResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgCREUpdateUserPublishedItemVoteResponse, rhs: CMsgCREUpdateUserPublishedItemVoteResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgCREGetUserPublishedItemVoteDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgCREGetUserPublishedItemVoteDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "published_file_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.publishedFileIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publishedFileIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publishedFileIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgCREGetUserPublishedItemVoteDetails, rhs: CMsgCREGetUserPublishedItemVoteDetails) -> Bool {
    if lhs.publishedFileIds != rhs.publishedFileIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgCREGetUserPublishedItemVoteDetails.protoMessageName + ".PublishedFileId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "published_file_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._publishedFileID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._publishedFileID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId, rhs: CMsgCREGetUserPublishedItemVoteDetails.PublishedFileId) -> Bool {
    if lhs._publishedFileID != rhs._publishedFileID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgCREGetUserPublishedItemVoteDetailsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgCREGetUserPublishedItemVoteDetailsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "user_item_vote_details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.userItemVoteDetails) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if !self.userItemVoteDetails.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userItemVoteDetails, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgCREGetUserPublishedItemVoteDetailsResponse, rhs: CMsgCREGetUserPublishedItemVoteDetailsResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs.userItemVoteDetails != rhs.userItemVoteDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgCREGetUserPublishedItemVoteDetailsResponse.protoMessageName + ".UserItemVoteDetail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "published_file_id"),
    2: .same(proto: "vote"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._publishedFileID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._vote) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._publishedFileID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._vote {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail, rhs: CMsgCREGetUserPublishedItemVoteDetailsResponse.UserItemVoteDetail) -> Bool {
    if lhs._publishedFileID != rhs._publishedFileID {return false}
    if lhs._vote != rhs._vote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgFSGetFollowerCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgFSGetFollowerCount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "steam_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._steamID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._steamID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgFSGetFollowerCount, rhs: CMsgFSGetFollowerCount) -> Bool {
    if lhs._steamID != rhs._steamID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgFSGetFollowerCountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgFSGetFollowerCountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._count {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgFSGetFollowerCountResponse, rhs: CMsgFSGetFollowerCountResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs._count != rhs._count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgFSGetIsFollowing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgFSGetIsFollowing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "steam_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._steamID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._steamID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgFSGetIsFollowing, rhs: CMsgFSGetIsFollowing) -> Bool {
    if lhs._steamID != rhs._steamID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgFSGetIsFollowingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgFSGetIsFollowingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "is_following"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isFollowing) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._isFollowing {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgFSGetIsFollowingResponse, rhs: CMsgFSGetIsFollowingResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs._isFollowing != rhs._isFollowing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgFSEnumerateFollowingList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgFSEnumerateFollowingList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._startIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._startIndex {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgFSEnumerateFollowingList, rhs: CMsgFSEnumerateFollowingList) -> Bool {
    if lhs._startIndex != rhs._startIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgFSEnumerateFollowingListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgFSEnumerateFollowingListResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "total_results"),
    3: .standard(proto: "steam_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._totalResults) }()
      case 3: try { try decoder.decodeRepeatedFixed64Field(value: &self.steamIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._totalResults {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if !self.steamIds.isEmpty {
      try visitor.visitRepeatedFixed64Field(value: self.steamIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgFSEnumerateFollowingListResponse, rhs: CMsgFSEnumerateFollowingListResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs._totalResults != rhs._totalResults {return false}
    if lhs.steamIds != rhs.steamIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgDPGetNumberOfCurrentPlayers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgDPGetNumberOfCurrentPlayers"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._appid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._appid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgDPGetNumberOfCurrentPlayers, rhs: CMsgDPGetNumberOfCurrentPlayers) -> Bool {
    if lhs._appid != rhs._appid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgDPGetNumberOfCurrentPlayersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgDPGetNumberOfCurrentPlayersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "player_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._playerCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._playerCount {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgDPGetNumberOfCurrentPlayersResponse, rhs: CMsgDPGetNumberOfCurrentPlayersResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs._playerCount != rhs._playerCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientFriendUserStatusPublished: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientFriendUserStatusPublished"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "friend_steamid"),
    2: .same(proto: "appid"),
    3: .standard(proto: "status_text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._friendSteamid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._appid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._statusText) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._friendSteamid {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._appid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._statusText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientFriendUserStatusPublished, rhs: CMsgClientFriendUserStatusPublished) -> Bool {
    if lhs._friendSteamid != rhs._friendSteamid {return false}
    if lhs._appid != rhs._appid {return false}
    if lhs._statusText != rhs._statusText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientServiceMethodLegacy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientServiceMethodLegacy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "method_name"),
    2: .standard(proto: "serialized_method"),
    3: .standard(proto: "is_notification"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._methodName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._serializedMethod) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._isNotification) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._methodName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._serializedMethod {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._isNotification {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientServiceMethodLegacy, rhs: CMsgClientServiceMethodLegacy) -> Bool {
    if lhs._methodName != rhs._methodName {return false}
    if lhs._serializedMethod != rhs._serializedMethod {return false}
    if lhs._isNotification != rhs._isNotification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientServiceMethodLegacyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientServiceMethodLegacyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "method_name"),
    2: .standard(proto: "serialized_method_response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._methodName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._serializedMethodResponse) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._methodName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._serializedMethodResponse {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientServiceMethodLegacyResponse, rhs: CMsgClientServiceMethodLegacyResponse) -> Bool {
    if lhs._methodName != rhs._methodName {return false}
    if lhs._serializedMethodResponse != rhs._serializedMethodResponse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUIMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUIMode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uimode"),
    2: .standard(proto: "chat_mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._uimode) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._chatMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._uimode {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._chatMode {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUIMode, rhs: CMsgClientUIMode) -> Bool {
    if lhs._uimode != rhs._uimode {return false}
    if lhs._chatMode != rhs._chatMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientVanityURLChangedNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientVanityURLChangedNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vanity_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._vanityURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._vanityURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientVanityURLChangedNotification, rhs: CMsgClientVanityURLChangedNotification) -> Bool {
    if lhs._vanityURL != rhs._vanityURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientAuthorizeLocalDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientAuthorizeLocalDeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_description"),
    2: .standard(proto: "owner_account_id"),
    3: .standard(proto: "local_device_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._deviceDescription) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._ownerAccountID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._localDeviceToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._deviceDescription {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._ownerAccountID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._localDeviceToken {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientAuthorizeLocalDeviceRequest, rhs: CMsgClientAuthorizeLocalDeviceRequest) -> Bool {
    if lhs._deviceDescription != rhs._deviceDescription {return false}
    if lhs._ownerAccountID != rhs._ownerAccountID {return false}
    if lhs._localDeviceToken != rhs._localDeviceToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientAuthorizeLocalDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientAuthorizeLocalDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "owner_account_id"),
    3: .standard(proto: "authed_device_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._ownerAccountID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._authedDeviceToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._ownerAccountID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._authedDeviceToken {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientAuthorizeLocalDevice, rhs: CMsgClientAuthorizeLocalDevice) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs._ownerAccountID != rhs._ownerAccountID {return false}
    if lhs._authedDeviceToken != rhs._authedDeviceToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientAuthorizeLocalDeviceNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientAuthorizeLocalDeviceNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "owner_account_id"),
    3: .standard(proto: "local_device_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._ownerAccountID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._localDeviceToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._ownerAccountID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._localDeviceToken {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientAuthorizeLocalDeviceNotification, rhs: CMsgClientAuthorizeLocalDeviceNotification) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs._ownerAccountID != rhs._ownerAccountID {return false}
    if lhs._localDeviceToken != rhs._localDeviceToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientDeauthorizeDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientDeauthorizeDeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deauthorization_account_id"),
    2: .standard(proto: "deauthorization_device_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._deauthorizationAccountID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._deauthorizationDeviceToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._deauthorizationAccountID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._deauthorizationDeviceToken {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientDeauthorizeDeviceRequest, rhs: CMsgClientDeauthorizeDeviceRequest) -> Bool {
    if lhs._deauthorizationAccountID != rhs._deauthorizationAccountID {return false}
    if lhs._deauthorizationDeviceToken != rhs._deauthorizationDeviceToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientDeauthorizeDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientDeauthorizeDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "deauthorization_account_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._deauthorizationAccountID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._deauthorizationAccountID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientDeauthorizeDevice, rhs: CMsgClientDeauthorizeDevice) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs._deauthorizationAccountID != rhs._deauthorizationAccountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUseLocalDeviceAuthorizations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientUseLocalDeviceAuthorizations"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "authorization_account_id"),
    2: .standard(proto: "device_tokens"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.authorizationAccountID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.deviceTokens) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authorizationAccountID.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.authorizationAccountID, fieldNumber: 1)
    }
    if !self.deviceTokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deviceTokens, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUseLocalDeviceAuthorizations, rhs: CMsgClientUseLocalDeviceAuthorizations) -> Bool {
    if lhs.authorizationAccountID != rhs.authorizationAccountID {return false}
    if lhs.deviceTokens != rhs.deviceTokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientUseLocalDeviceAuthorizations.DeviceToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientUseLocalDeviceAuthorizations.protoMessageName + ".DeviceToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_account_id"),
    2: .standard(proto: "token_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._ownerAccountID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._tokenID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._ownerAccountID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._tokenID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientUseLocalDeviceAuthorizations.DeviceToken, rhs: CMsgClientUseLocalDeviceAuthorizations.DeviceToken) -> Bool {
    if lhs._ownerAccountID != rhs._ownerAccountID {return false}
    if lhs._tokenID != rhs._tokenID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientGetAuthorizedDevices: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientGetAuthorizedDevices"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientGetAuthorizedDevices, rhs: CMsgClientGetAuthorizedDevices) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientGetAuthorizedDevicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientGetAuthorizedDevicesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "authorized_device"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.authorizedDevice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if !self.authorizedDevice.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.authorizedDevice, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientGetAuthorizedDevicesResponse, rhs: CMsgClientGetAuthorizedDevicesResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs.authorizedDevice != rhs.authorizedDevice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientGetAuthorizedDevicesResponse.protoMessageName + ".AuthorizedDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auth_device_token"),
    2: .standard(proto: "device_name"),
    3: .standard(proto: "last_access_time"),
    4: .standard(proto: "borrower_id"),
    5: .standard(proto: "is_pending"),
    6: .standard(proto: "app_played"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._authDeviceToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._deviceName) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._lastAccessTime) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._borrowerID) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._isPending) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._appPlayed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._authDeviceToken {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._deviceName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._lastAccessTime {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._borrowerID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._isPending {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    if let v = self._appPlayed {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice, rhs: CMsgClientGetAuthorizedDevicesResponse.AuthorizedDevice) -> Bool {
    if lhs._authDeviceToken != rhs._authDeviceToken {return false}
    if lhs._deviceName != rhs._deviceName {return false}
    if lhs._lastAccessTime != rhs._lastAccessTime {return false}
    if lhs._borrowerID != rhs._borrowerID {return false}
    if lhs._isPending != rhs._isPending {return false}
    if lhs._appPlayed != rhs._appPlayed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientSharedLibraryLockStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientSharedLibraryLockStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "locked_library"),
    2: .standard(proto: "own_library_locked_by"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.lockedLibrary) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._ownLibraryLockedBy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lockedLibrary.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lockedLibrary, fieldNumber: 1)
    }
    if let v = self._ownLibraryLockedBy {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientSharedLibraryLockStatus, rhs: CMsgClientSharedLibraryLockStatus) -> Bool {
    if lhs.lockedLibrary != rhs.lockedLibrary {return false}
    if lhs._ownLibraryLockedBy != rhs._ownLibraryLockedBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientSharedLibraryLockStatus.LockedLibrary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientSharedLibraryLockStatus.protoMessageName + ".LockedLibrary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_id"),
    2: .standard(proto: "locked_by"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._ownerID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._lockedBy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._ownerID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._lockedBy {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientSharedLibraryLockStatus.LockedLibrary, rhs: CMsgClientSharedLibraryLockStatus.LockedLibrary) -> Bool {
    if lhs._ownerID != rhs._ownerID {return false}
    if lhs._lockedBy != rhs._lockedBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientSharedLibraryStopPlaying: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientSharedLibraryStopPlaying"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "seconds_left"),
    2: .standard(proto: "stop_apps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._secondsLeft) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.stopApps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._secondsLeft {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if !self.stopApps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stopApps, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientSharedLibraryStopPlaying, rhs: CMsgClientSharedLibraryStopPlaying) -> Bool {
    if lhs._secondsLeft != rhs._secondsLeft {return false}
    if lhs.stopApps != rhs.stopApps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientSharedLibraryStopPlaying.StopApp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CMsgClientSharedLibraryStopPlaying.protoMessageName + ".StopApp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "owner_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._appID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._ownerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._appID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._ownerID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientSharedLibraryStopPlaying.StopApp, rhs: CMsgClientSharedLibraryStopPlaying.StopApp) -> Bool {
    if lhs._appID != rhs._appID {return false}
    if lhs._ownerID != rhs._ownerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientServiceCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientServiceCall"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sysid_routing"),
    2: .standard(proto: "call_handle"),
    3: .standard(proto: "module_crc"),
    4: .standard(proto: "module_hash"),
    5: .standard(proto: "function_id"),
    6: .standard(proto: "cub_output_max"),
    7: .same(proto: "flags"),
    8: .same(proto: "callparameter"),
    9: .standard(proto: "ping_only"),
    10: .standard(proto: "max_outstanding_calls"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._sysidRouting) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._callHandle) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._moduleCrc) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._moduleHash) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._functionID) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._cubOutputMax) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._flags) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self._callparameter) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self._pingOnly) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._maxOutstandingCalls) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sysidRouting {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._callHandle {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._moduleCrc {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._moduleHash {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }
    if let v = self._functionID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    if let v = self._cubOutputMax {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    if let v = self._flags {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._callparameter {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
    }
    if let v = self._pingOnly {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    }
    if let v = self._maxOutstandingCalls {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientServiceCall, rhs: CMsgClientServiceCall) -> Bool {
    if lhs._sysidRouting != rhs._sysidRouting {return false}
    if lhs._callHandle != rhs._callHandle {return false}
    if lhs._moduleCrc != rhs._moduleCrc {return false}
    if lhs._moduleHash != rhs._moduleHash {return false}
    if lhs._functionID != rhs._functionID {return false}
    if lhs._cubOutputMax != rhs._cubOutputMax {return false}
    if lhs._flags != rhs._flags {return false}
    if lhs._callparameter != rhs._callparameter {return false}
    if lhs._pingOnly != rhs._pingOnly {return false}
    if lhs._maxOutstandingCalls != rhs._maxOutstandingCalls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientServiceModule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientServiceModule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "module_crc"),
    2: .standard(proto: "module_hash"),
    3: .standard(proto: "module_content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._moduleCrc) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._moduleHash) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._moduleContent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._moduleCrc {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._moduleHash {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._moduleContent {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientServiceModule, rhs: CMsgClientServiceModule) -> Bool {
    if lhs._moduleCrc != rhs._moduleCrc {return false}
    if lhs._moduleHash != rhs._moduleHash {return false}
    if lhs._moduleContent != rhs._moduleContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientServiceCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientServiceCallResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sysid_routing"),
    2: .standard(proto: "call_handle"),
    3: .standard(proto: "module_crc"),
    4: .standard(proto: "module_hash"),
    5: .same(proto: "ecallresult"),
    6: .standard(proto: "result_content"),
    7: .standard(proto: "os_version_info"),
    8: .standard(proto: "system_info"),
    9: .standard(proto: "load_address"),
    10: .standard(proto: "exception_record"),
    11: .standard(proto: "portable_os_version_info"),
    12: .standard(proto: "portable_system_info"),
    13: .standard(proto: "was_converted"),
    14: .standard(proto: "internal_result"),
    15: .standard(proto: "current_count"),
    16: .standard(proto: "last_call_handle"),
    17: .standard(proto: "last_call_module_crc"),
    18: .standard(proto: "last_call_sysid_routing"),
    19: .standard(proto: "last_ecallresult"),
    20: .standard(proto: "last_callissue_delta"),
    21: .standard(proto: "last_callcomplete_delta"),
  ]

  fileprivate class _StorageClass {
    var _sysidRouting: Data? = nil
    var _callHandle: UInt32? = nil
    var _moduleCrc: UInt32? = nil
    var _moduleHash: Data? = nil
    var _ecallresult: UInt32? = nil
    var _resultContent: Data? = nil
    var _osVersionInfo: Data? = nil
    var _systemInfo: Data? = nil
    var _loadAddress: UInt64? = nil
    var _exceptionRecord: Data? = nil
    var _portableOsVersionInfo: Data? = nil
    var _portableSystemInfo: Data? = nil
    var _wasConverted: Bool? = nil
    var _internalResult: UInt32? = nil
    var _currentCount: UInt32? = nil
    var _lastCallHandle: UInt32? = nil
    var _lastCallModuleCrc: UInt32? = nil
    var _lastCallSysidRouting: Data? = nil
    var _lastEcallresult: UInt32? = nil
    var _lastCallissueDelta: UInt32? = nil
    var _lastCallcompleteDelta: UInt32? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sysidRouting = source._sysidRouting
      _callHandle = source._callHandle
      _moduleCrc = source._moduleCrc
      _moduleHash = source._moduleHash
      _ecallresult = source._ecallresult
      _resultContent = source._resultContent
      _osVersionInfo = source._osVersionInfo
      _systemInfo = source._systemInfo
      _loadAddress = source._loadAddress
      _exceptionRecord = source._exceptionRecord
      _portableOsVersionInfo = source._portableOsVersionInfo
      _portableSystemInfo = source._portableSystemInfo
      _wasConverted = source._wasConverted
      _internalResult = source._internalResult
      _currentCount = source._currentCount
      _lastCallHandle = source._lastCallHandle
      _lastCallModuleCrc = source._lastCallModuleCrc
      _lastCallSysidRouting = source._lastCallSysidRouting
      _lastEcallresult = source._lastEcallresult
      _lastCallissueDelta = source._lastCallissueDelta
      _lastCallcompleteDelta = source._lastCallcompleteDelta
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._sysidRouting) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._callHandle) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._moduleCrc) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._moduleHash) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._ecallresult) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._resultContent) }()
        case 7: try { try decoder.decodeSingularBytesField(value: &_storage._osVersionInfo) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._systemInfo) }()
        case 9: try { try decoder.decodeSingularFixed64Field(value: &_storage._loadAddress) }()
        case 10: try { try decoder.decodeSingularBytesField(value: &_storage._exceptionRecord) }()
        case 11: try { try decoder.decodeSingularBytesField(value: &_storage._portableOsVersionInfo) }()
        case 12: try { try decoder.decodeSingularBytesField(value: &_storage._portableSystemInfo) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._wasConverted) }()
        case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._internalResult) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._currentCount) }()
        case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._lastCallHandle) }()
        case 17: try { try decoder.decodeSingularUInt32Field(value: &_storage._lastCallModuleCrc) }()
        case 18: try { try decoder.decodeSingularBytesField(value: &_storage._lastCallSysidRouting) }()
        case 19: try { try decoder.decodeSingularUInt32Field(value: &_storage._lastEcallresult) }()
        case 20: try { try decoder.decodeSingularUInt32Field(value: &_storage._lastCallissueDelta) }()
        case 21: try { try decoder.decodeSingularUInt32Field(value: &_storage._lastCallcompleteDelta) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._sysidRouting {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
      }
      if let v = _storage._callHandle {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._moduleCrc {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      }
      if let v = _storage._moduleHash {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
      }
      if let v = _storage._ecallresult {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      }
      if let v = _storage._resultContent {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
      }
      if let v = _storage._osVersionInfo {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
      }
      if let v = _storage._systemInfo {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
      }
      if let v = _storage._loadAddress {
        try visitor.visitSingularFixed64Field(value: v, fieldNumber: 9)
      }
      if let v = _storage._exceptionRecord {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 10)
      }
      if let v = _storage._portableOsVersionInfo {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 11)
      }
      if let v = _storage._portableSystemInfo {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 12)
      }
      if let v = _storage._wasConverted {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      }
      if let v = _storage._internalResult {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 14)
      }
      if let v = _storage._currentCount {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 15)
      }
      if let v = _storage._lastCallHandle {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 16)
      }
      if let v = _storage._lastCallModuleCrc {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 17)
      }
      if let v = _storage._lastCallSysidRouting {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 18)
      }
      if let v = _storage._lastEcallresult {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 19)
      }
      if let v = _storage._lastCallissueDelta {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 20)
      }
      if let v = _storage._lastCallcompleteDelta {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientServiceCallResponse, rhs: CMsgClientServiceCallResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sysidRouting != rhs_storage._sysidRouting {return false}
        if _storage._callHandle != rhs_storage._callHandle {return false}
        if _storage._moduleCrc != rhs_storage._moduleCrc {return false}
        if _storage._moduleHash != rhs_storage._moduleHash {return false}
        if _storage._ecallresult != rhs_storage._ecallresult {return false}
        if _storage._resultContent != rhs_storage._resultContent {return false}
        if _storage._osVersionInfo != rhs_storage._osVersionInfo {return false}
        if _storage._systemInfo != rhs_storage._systemInfo {return false}
        if _storage._loadAddress != rhs_storage._loadAddress {return false}
        if _storage._exceptionRecord != rhs_storage._exceptionRecord {return false}
        if _storage._portableOsVersionInfo != rhs_storage._portableOsVersionInfo {return false}
        if _storage._portableSystemInfo != rhs_storage._portableSystemInfo {return false}
        if _storage._wasConverted != rhs_storage._wasConverted {return false}
        if _storage._internalResult != rhs_storage._internalResult {return false}
        if _storage._currentCount != rhs_storage._currentCount {return false}
        if _storage._lastCallHandle != rhs_storage._lastCallHandle {return false}
        if _storage._lastCallModuleCrc != rhs_storage._lastCallModuleCrc {return false}
        if _storage._lastCallSysidRouting != rhs_storage._lastCallSysidRouting {return false}
        if _storage._lastEcallresult != rhs_storage._lastEcallresult {return false}
        if _storage._lastCallissueDelta != rhs_storage._lastCallissueDelta {return false}
        if _storage._lastCallcompleteDelta != rhs_storage._lastCallcompleteDelta {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgAMUnlockStreaming: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgAMUnlockStreaming"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgAMUnlockStreaming, rhs: CMsgAMUnlockStreaming) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgAMUnlockStreamingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgAMUnlockStreamingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
    2: .standard(proto: "encryption_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._encryptionKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._encryptionKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgAMUnlockStreamingResponse, rhs: CMsgAMUnlockStreamingResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs._encryptionKey != rhs._encryptionKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgAMUnlockHEVC: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgAMUnlockHEVC"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgAMUnlockHEVC, rhs: CMsgAMUnlockHEVC) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgAMUnlockHEVCResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgAMUnlockHEVCResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eresult"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgAMUnlockHEVCResponse, rhs: CMsgAMUnlockHEVCResponse) -> Bool {
    if lhs._eresult != rhs._eresult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientPlayingSessionState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientPlayingSessionState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "playing_blocked"),
    3: .standard(proto: "playing_app"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBoolField(value: &self._playingBlocked) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._playingApp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._playingBlocked {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._playingApp {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientPlayingSessionState, rhs: CMsgClientPlayingSessionState) -> Bool {
    if lhs._playingBlocked != rhs._playingBlocked {return false}
    if lhs._playingApp != rhs._playingApp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientKickPlayingSession: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientKickPlayingSession"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "only_stop_game"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._onlyStopGame) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._onlyStopGame {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientKickPlayingSession, rhs: CMsgClientKickPlayingSession) -> Bool {
    if lhs._onlyStopGame != rhs._onlyStopGame {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientVoiceCallPreAuthorize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientVoiceCallPreAuthorize"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "caller_steamid"),
    2: .standard(proto: "receiver_steamid"),
    3: .standard(proto: "caller_id"),
    4: .same(proto: "hangup"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._callerSteamid) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self._receiverSteamid) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._callerID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._hangup) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._callerSteamid {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._receiverSteamid {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 2)
    }
    if let v = self._callerID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._hangup {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientVoiceCallPreAuthorize, rhs: CMsgClientVoiceCallPreAuthorize) -> Bool {
    if lhs._callerSteamid != rhs._callerSteamid {return false}
    if lhs._receiverSteamid != rhs._receiverSteamid {return false}
    if lhs._callerID != rhs._callerID {return false}
    if lhs._hangup != rhs._hangup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgClientVoiceCallPreAuthorizeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgClientVoiceCallPreAuthorizeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "caller_steamid"),
    2: .standard(proto: "receiver_steamid"),
    3: .same(proto: "eresult"),
    4: .standard(proto: "caller_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._callerSteamid) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self._receiverSteamid) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._eresult) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._callerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._callerSteamid {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._receiverSteamid {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 2)
    }
    if let v = self._eresult {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._callerID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgClientVoiceCallPreAuthorizeResponse, rhs: CMsgClientVoiceCallPreAuthorizeResponse) -> Bool {
    if lhs._callerSteamid != rhs._callerSteamid {return false}
    if lhs._receiverSteamid != rhs._receiverSteamid {return false}
    if lhs._eresult != rhs._eresult {return false}
    if lhs._callerID != rhs._callerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CMsgBadgeCraftedNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CMsgBadgeCraftedNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appid"),
    2: .standard(proto: "badge_level"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._appid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._badgeLevel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._appid {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }
    if let v = self._badgeLevel {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CMsgBadgeCraftedNotification, rhs: CMsgBadgeCraftedNotification) -> Bool {
    if lhs._appid != rhs._appid {return false}
    if lhs._badgeLevel != rhs._badgeLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
